{
open Location
open Identifier
open Dyp
open Parsetree
open Ast_helper

(* Used for error messages and as a default, in case anything slips through
   without an explicit loc. *)
let first_loc = ref Location.dummy_loc
let last_loc = ref Location.dummy_loc
let dyp_merge = keep_all

let last_state_printer = ref (fun () -> ())

let when_debug ?(n=0) thunk =
  if !Grain_utils.Config.parser_debug_level > n then
    thunk()

let prerr_string s = when_debug ~n:1 (fun () -> Pervasives.prerr_string s)

let debug_print_state () =
  when_debug !last_state_printer

let symbol_rloc dyp =
  let ret = {
    loc_start = dyp.symbol_start_pos ();
    loc_end = dyp.symbol_end_pos ();
    loc_ghost = false;
  } in
  last_state_printer := (fun () -> dyp.print_state stderr);
  when_debug ~n:1 !last_state_printer;
  last_loc := ret;
  ret

let symbol_gloc dyp =
  let ret = {
    loc_start = dyp.symbol_start_pos ();
    loc_end = dyp.symbol_end_pos ();
    loc_ghost = true;
  } in
  last_state_printer := (fun () -> dyp.print_state stderr);
  when_debug ~n:1 !last_state_printer;
  last_loc := ret;
  ret

let rhs_loc dyp n =
  let ret = {
    loc_start = dyp.rhs_start_pos n;
    loc_end = dyp.rhs_end_pos n;
    loc_ghost = false;
  } in
  last_state_printer := (fun () -> dyp.print_state stderr);
  when_debug ~n:1 !last_state_printer;
  last_loc := ret;
  ret

let fix_block_mapper super =
  let open Ast_mapper in
  let expr mapper ({pexp_desc; pexp_loc} as e) =
    match pexp_desc with
    | PExpBlock([]) -> super.expr mapper e
    | PExpBlock(elts) ->
      let elts = List.map (mapper.expr mapper) elts in
      let pre, last = List.fold_left (fun (acc_l, acc_last) cur ->
          match acc_last with
          | None -> (acc_l, Some cur)
          | Some e -> (e::acc_l, Some cur)) ([], None) elts in
      let pre = List.rev pre in
      let last = match last with
        | None -> raise (Syntaxerr.Error(LetWithoutBody(pexp_loc)))
        | Some(l) -> l in
      let fixed = List.fold_right (fun ({pexp_desc; pexp_loc; _} as e) acc ->
          match pexp_desc with
          | PExpLet(r, vbs, {pexp_desc=PExpBlock(b)}) ->
            [{e with pexp_desc=PExpLet(r, vbs, Ast_helper.Exp.block ~loc:pexp_loc (b @ acc))}]
          | _ -> e::acc) pre [last] in
      (match fixed with
       | [x] -> x
       | _ -> {e with pexp_desc=PExpBlock(fixed)})
    | _ -> super.expr mapper e in
  {super with expr}

let fix_tyvar_mapper super =
  let open Ast_mapper in
  let open Ast_helper in
  let typ mapper ({ptyp_desc; ptyp_loc} as t) =
    match ptyp_desc with
    | PTyVar v when (v <> "") && (match v.[0] with 'A'..'Z' -> true | _ -> false) ->
      let id = mkloc (IdentName v) ptyp_loc in
      {t with ptyp_desc=PTyConstr(id, [])}
    | _ -> super.typ mapper t in
  {super with typ}

let fix_blocks ({statements; body} as prog) =
  let open Ast_mapper in
  let mapper = default_mapper
    |> fix_block_mapper
    |> fix_tyvar_mapper in
  {prog with
   statements=List.map (mapper.toplevel mapper) statements;
   body=mapper.expr mapper body}


let mkid ns =
  let help ns =
    let rec help ns (acc_ident, acc_str) =
      let ident = Option.map_default (fun i -> IdentExternal(i, acc_str)) (IdentName acc_str) acc_ident in
      match ns with
        | [] -> ident
        | n::tl -> help tl (Some ident, n) in
    match ns with
      | [] -> failwith "Should be impossible"
      | n::tl -> help tl (None, n) in
  mkloc @@ help ns

let mkstr dyp s = mkloc s (symbol_rloc dyp)

let make_program statements body =
  let prog_loc = {
    loc_start=(!first_loc).loc_end;
    loc_end=(!last_loc).loc_end;
    loc_ghost=false;
  } in
  fix_blocks {statements; body; prog_loc}

}

%relation pe<pt<pp<pb<pc

%token <int> NUM
%token <string> ID
%token <string> STRING
%token LBRACK RBRACK LPAREN LPARENNOSPACE RPAREN LBRACE RBRACE
%token COMMA SEMI
%token THICKARROW ARROW PIPE
%token EQEQ LESS GREATER LESSEQ GREATEREQ
%token EQUAL GETS
%token UNDERSCORE
%token COLON COLONCOLON

%token ADD1 SUB1 ISBOOL ISNUM ISTUPLE
%token PLUS MINUS TIMES
%token TRUE FALSE

%token LET REC IF ELSE MATCH
%token AND OR NOT

%token DATA IMPORT
%token EOF

%start <Parsetree.parsed_program> program

%parser

const :
  | NUM { Const.int $1 }
  | TRUE { Const.bool true }
  | FALSE { Const.bool false }
  | STRING { Const.string $1 }

prim1 :
  | ADD1 { Add1 }
  | SUB1 { Sub1 }
  | NOT { Not }
  | ISBOOL { IsBool }
  | ISNUM { IsNum }
  | ISTUPLE { IsTuple }

binop_expr:
  | binop_expr(<=pp) PLUS      binop_expr(<pp) { prerr_string "\nbinop_expr_plus\n"; when_debug ~n:1 (fun () -> dyp.print_state stderr); Exp.prim2 ~loc:(symbol_rloc dyp) Plus $1 $3 } pp
  | binop_expr(<=pp) MINUS     binop_expr(<pp) { Exp.prim2 ~loc:(symbol_rloc dyp) Minus $1 $3 } pp
  | binop_expr(<=pt) TIMES     binop_expr(<pt) { Exp.prim2 ~loc:(symbol_rloc dyp) Times $1 $3 } pt
  | binop_expr(<=pc) EQEQ      binop_expr(<pc) { Exp.prim2 ~loc:(symbol_rloc dyp) Eq $1 $3 } pc
  | binop_expr(<=pc) LESS      binop_expr(<pc) { Exp.prim2 ~loc:(symbol_rloc dyp) Less $1 $3 } pc
  | binop_expr(<=pc) GREATER   binop_expr(<pc) { Exp.prim2 ~loc:(symbol_rloc dyp) Greater $1 $3 } pc
  | binop_expr(<=pc) LESSEQ    binop_expr(<pc) { Exp.prim2 ~loc:(symbol_rloc dyp) LessEq $1 $3 } pc
  | binop_expr(<=pc) GREATEREQ binop_expr(<pc) { Exp.prim2 ~loc:(symbol_rloc dyp) GreaterEq $1 $3 } pc
  | binop_expr(<=pb) AND       binop_expr(<pb) { Exp.prim2 ~loc:(symbol_rloc dyp) And $1 $3 } pb
  | binop_expr(<=pb) OR        binop_expr(<pb) { Exp.prim2 ~loc:(symbol_rloc dyp) Or $1 $3 } pb
  | expr { prerr_string "\nbinop_expr\n"; when_debug ~n:1 (fun () -> dyp.print_state stderr); $1 } pe

pattern :
  | UNDERSCORE { Pat.any ~loc:(symbol_rloc dyp) () }
  /* If the pattern uses an external ID, we know it's a constructor, not a variable */
  | ext_id { Pat.construct ~loc:(symbol_rloc dyp) $1 [] }
  | ID { Pat.var ~loc:(symbol_rloc dyp) (mkstr dyp $1) }
  | LPAREN tuple_patterns RPAREN { Pat.tuple ~loc:(symbol_rloc dyp) $2 }
  | LPAREN pattern RPAREN { $2 }
  | pattern COLON typ { Pat.constraint_ ~loc:(symbol_rloc dyp) $1 $3 }
  | id LPAREN tuple_patterns RPAREN { Pat.construct ~loc:(symbol_rloc dyp) $1 $3 }

patterns :
  | pattern [COMMA pattern {$2}]* { $1::$2 }

tuple_patterns :
  | pattern COMMA { [$1] }
  | pattern [COMMA pattern {$2}]+ { $1::$2 }

typ :
  /* It's a little sad that we can't do `a -> b`, but it makes sense for consistency's sake */
  | LPAREN typs RPAREN ARROW typ { Typ.arrow ~loc:(symbol_rloc dyp) $2 $5 }
  | LPAREN tuple_typs RPAREN { Typ.tuple ~loc:(symbol_rloc dyp) $2 }
  | LPAREN typ RPAREN { $2 }
  | typ+ id { Typ.constr $2 $1 }
  | ID { Typ.var $1 }

typs :
  | [typ [COMMA typ {$2}]* {$1::$2}]? { Option.default [] $1 }

tuple_typs :
  | typ COMMA { [$1] }
  | typ [COMMA typ {$2}]+ { $1::$2 }

value_bind :
  | pattern EQUAL binop_expr { Vb.mk ~loc:(symbol_rloc dyp) $1 $3 }

value_binds :
  | value_bind [COMMA value_bind {$2}]* { $1::$2 }

import_stmt :
  | IMPORT id { Imp.mk $2 }

data_constructor :
  | ID { CDecl.singleton ~loc:(symbol_rloc dyp) (mkstr dyp $1) }
  | ID LPAREN typs RPAREN { CDecl.tuple ~loc:(symbol_rloc dyp) (mkstr dyp $1) $3 }

data_constructors :
  | data_constructor [PIPE data_constructor {$2}]* { $1::$2 }
  | [PIPE data_constructor {$2}]+ { $1 }

data_declaration :
  | DATA ID* ID EQUAL data_constructors { Dat.mk ~loc:(symbol_rloc dyp) (mkstr dyp $3) (List.map Typ.var $2) (PDataVariant $5) }

prim1_expr :
  | prim1 LPAREN binop_expr RPAREN { Exp.prim1 ~loc:(symbol_rloc dyp) $1 $3 }

paren_expr :
  | LPAREN binop_expr RPAREN { $2 }

app_arg_exprs :
  | [binop_expr [COMMA binop_expr {$2}]* { $1::$2 }]? { Option.default [] $1 }

app_expr :
  | expr LPAREN app_arg_exprs RPAREN { prerr_string "\napp_expr\n"; when_debug ~n:1 (fun () -> dyp.print_state stderr); Exp.apply ~loc:(symbol_rloc dyp) $1 $3 }

ext_id :
  | ID [COLONCOLON ID {$2}]+ { prerr_string "\nid\n"; when_debug ~n:1 (fun () -> dyp.print_state stderr); (mkid ($1::$2)) (symbol_rloc dyp) }

id :
  | ID [COLONCOLON ID {$2}]* { prerr_string "\nid\n"; when_debug ~n:1 (fun () -> dyp.print_state stderr); (mkid ($1::$2)) (symbol_rloc dyp) }

simple_expr :
  | const { Exp.constant ~loc:(symbol_rloc dyp) $1 }
  | id { prerr_string "\nsimple_expr\n"; when_debug ~n:1 (fun () -> dyp.print_state stderr); Exp.ident ~loc:(symbol_rloc dyp) $1 }
  | LPAREN tuple_exprs RPAREN { Exp.tuple ~loc:(symbol_rloc dyp) $2 }

block_expr :
  | LBRACE block RBRACE { Exp.block ~loc:(symbol_rloc dyp) $2 }

lam_args :
  | patterns? { Option.default [] $1 }

lam_expr :
  | LPAREN lam_args RPAREN THICKARROW block_expr { Exp.lambda ~loc:(symbol_rloc dyp) $2 $5 }

let_expr :
  | LET REC value_binds { Exp.let_ ~loc:(symbol_rloc dyp) Recursive $3 (Exp.block []) }
  | LET value_binds { Exp.let_ ~loc:(symbol_rloc dyp) Nonrecursive $2 (Exp.block []) }

if_expr :
  | IF binop_expr block_expr { Exp.if_ ~loc:(symbol_rloc dyp) $2 $3 (Exp.block []) }
  | IF binop_expr block_expr ELSE block_expr { Exp.if_ ~loc:(symbol_rloc dyp) $2 $3 $5 }

match_branch :
  | pattern THICKARROW binop_expr { Mb.mk ~loc:(symbol_rloc dyp) $1 $3 }

match_branches :
  | [PIPE match_branch {$2}]+ { $1 }

match_expr :
  | MATCH expr LBRACE match_branches RBRACE { Exp.match_ ~loc:(symbol_rloc dyp) $2 $4 }

expr :
  | app_expr    { prerr_string "\nexpr_app_expr\n"; when_debug ~n:1 (fun () -> dyp.print_state stderr); $1 }
  | simple_expr { prerr_string "\nexpr_simple_expr\n"; when_debug ~n:1 (fun () -> dyp.print_state stderr); $1 }
  | paren_expr  { $1 }
  | prim1_expr  { $1 }
  | block_expr  { $1 }
  | lam_expr    { $1 }
  | let_expr    { $1 }
  | if_expr     { $1 }
  | match_expr  { $1 }

tuple_exprs :
  | binop_expr COMMA { [$1] }
  | binop_expr [COMMA binop_expr {$2}]+ { $1::$2 }

block :
  | binop_expr [SEMI binop_expr {$2}]* { $1::$2 }

toplevel_stmt :
  | LET REC value_binds { Top.let_ Recursive $3 }
  | LET value_binds { Top.let_ Nonrecursive $2 }
  | import_stmt { Top.import $1 }
  | data_declaration { Top.data $1 }

toplevel_stmts :
  | toplevel_stmt [SEMI toplevel_stmt {$2}]* { $1::$2 }

program :
  | toplevel_stmts SEMI EOF { make_program $1 (Exp.null ~loc:dummy_loc ()) }
  | toplevel_stmts SEMI binop_expr EOF { make_program $1 $3 }
  | binop_expr EOF { prerr_string "\nprogram\n"; when_debug ~n:1 (fun () -> dyp.print_state stderr); make_program [] $1 }

%%

{
let parse_program t lexbuf =
  Dyp.dypgen_verbose := !Grain_utils.Config.parser_debug_level;
  first_loc := Location.curr lexbuf;
  with_default_loc_src (fun() -> !last_loc) (fun() -> program t lexbuf)

let print_syntax_error =
  let open Printf in
  let open Location in
  function
  | Syntax_error -> begin
      debug_print_state();
      Some(errorf ~loc:(!last_loc) "Syntax error")
    end
  | _ -> None

let () =
  Dyp.dypgen_verbose := !Grain_utils.Config.parser_debug_level;
  Location.register_error_of_exn print_syntax_error
}

%mli {
val parse_program : Lexing.lexbuf -> ((Parsetree.parsed_program * 'a) list)
}
