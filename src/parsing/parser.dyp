{
open Location
open Identifier
open Dyp
open Parsetree
open Ast_helper

(* Used for error messages and as a default, in case anything slips through
   without an explicit loc. *)
let first_loc = ref Location.dummy_loc
let last_loc = ref Location.dummy_loc
let dyp_merge = keep_all

let last_state_printer = ref (fun () -> ())

let when_debug ?n thunk =
  match n with
  | Some(n) ->
      if !Grain_utils.Config.parser_debug_level >= n then
        thunk()
  | None -> ()

let prerr_string s = when_debug ~n:1 (fun () -> Stdlib.prerr_string s)

let debug_print_state () =
  when_debug !last_state_printer

let symbol_rloc dyp =
  let ret = {
    loc_start = dyp.symbol_start_pos ();
    loc_end = dyp.symbol_end_pos ();
    loc_ghost = false;
  } in
  last_state_printer := (fun () -> dyp.print_state stderr);
  when_debug ~n:1 !last_state_printer;
  last_loc := ret;
  ret

let symbol_gloc dyp =
  let ret = {
    loc_start = dyp.symbol_start_pos ();
    loc_end = dyp.symbol_end_pos ();
    loc_ghost = true;
  } in
  last_state_printer := (fun () -> dyp.print_state stderr);
  when_debug ~n:1 !last_state_printer;
  last_loc := ret;
  ret

let rhs_loc dyp n =
  let ret = {
    loc_start = dyp.rhs_start_pos n;
    loc_end = dyp.rhs_end_pos n;
    loc_ghost = false;
  } in
  last_state_printer := (fun () -> dyp.print_state stderr);
  when_debug ~n:1 !last_state_printer;
  last_loc := ret;
  ret

let fix_block_mapper super =
  let open Ast_mapper in
  let expr mapper ({pexp_desc; pexp_loc} as e) =
    match pexp_desc with
    | PExpBlock([]) -> super.expr mapper e
    | PExpBlock(elts) ->
      let elts = List.map (mapper.expr mapper) elts in
      (* Properly nest let bindings *)
      let elts = List.fold_right (fun ({pexp_desc} as stmt) elts ->
        match pexp_desc with
        | PExpLet(r, binds, _) -> [{stmt with pexp_desc=PExpLet(r, binds, {stmt with pexp_desc=PExpBlock(elts)})}]
        | _ -> stmt::elts
      ) elts [] in
      {e with pexp_desc=PExpBlock(elts)}
    | _ -> super.expr mapper e in
  {super with expr}

let fix_tyvar_mapper super =
  let open Ast_mapper in
  let open Ast_helper in
  let typ mapper ({ptyp_desc; ptyp_loc} as t) =
    match ptyp_desc with
    | PTyVar v when (v <> "") && (match v.[0] with 'A'..'Z' -> true | _ -> false) ->
      let id = mkloc (IdentName v) ptyp_loc in
      {t with ptyp_desc=PTyConstr(id, [])}
    | _ -> super.typ mapper t in
  {super with typ}

let fix_blocks ({statements; body} as prog) =
  let open Ast_mapper in
  let mapper = default_mapper
    |> fix_block_mapper
    |> fix_tyvar_mapper in
  {prog with
   statements=List.map (mapper.toplevel mapper) statements;
   body=mapper.expr mapper body}

let block_resembles_record exprs =
  match exprs with
  | {pexp_desc=PExpId {txt=IdentName _}}::_ -> true
  | _ -> false

let is_uppercase_ident expr =
  match expr.pexp_desc with
  | PExpId {txt=id} ->
    let first_char = String.get (Identifier.last id) 0 in
    first_char = BatChar.uppercase first_char
  | _ -> false


let mkid ns =
  let help ns =
    let rec help ns (acc_ident, acc_str) =
      let ident = Option.map_default (fun i -> IdentExternal(i, acc_str)) (IdentName acc_str) acc_ident in
      match ns with
        | [] -> ident
        | n::tl -> help tl (Some ident, n) in
    match ns with
      | [] -> failwith "Should be impossible"
      | n::tl -> help tl (None, n) in
  mkloc @@ help ns

let mkstr dyp s = mkloc s (symbol_rloc dyp)

let make_program statements body =
  let prog_loc = {
    loc_start=(!first_loc).loc_end;
    loc_end=(!last_loc).loc_end;
    loc_ghost=false;
  } in
  fix_blocks {statements; body; prog_loc}

}

%relation pe<pt<pp<pb<pc<pa

%token <int> NUM
%token <string> ID
%token <string> TYPEID
%token <string> STRING
%token LBRACK RBRACK LPAREN LPARENNOSPACE RPAREN LBRACE RBRACE LCARET RCARET
%token COMMA SEMI AS
%token THICKARROW ARROW PIPE
%token EQEQ LESSEQ GREATEREQ
%token EQUAL GETS
%token UNDERSCORE
%token COLON COLONCOLON DOT

%token ADD1 SUB1 ISBOOL ISNUM ISTUPLE
%token BOX UNBOX
%token PLUS DASH STAR
%token TRUE FALSE

%token LET REC IF ELSE MATCH WHILE
%token AND OR NOT

%token DATA IMPORT EXPORT FOREIGN WASM 
%token EXCEPT FROM
%token EOL EOF

%start <Parsetree.parsed_program> program

%parser

eos :
  | EOL { None }
  | SEMI EOL? { None }

lparen : 
  | LPAREN EOL? { () }

rparen : 
  | EOL? RPAREN { () }

lbrace : 
  | LBRACE EOL? { () }

rbrace : 
  | EOL? RBRACE { () }

lcaret : 
  | LCARET EOL? { () }

rcaret : 
  | EOL? RCARET { () }

comma :
  | EOL? COMMA EOL? { () }

colon :
  | EOL? COLON EOL? { () }

dot :
  | EOL? DOT EOL? { () }

arrow :
  | EOL? ARROW EOL? { () }

thickarrow :
  | EOL? THICKARROW EOL? { () }

pipe :
  | EOL? PIPE EOL? { () }

equal :
  | EOL? EQUAL EOL? { () }

const :
  | NUM { Const.int $1 }
  | TRUE { Const.bool true }
  | FALSE { Const.bool false }
  | STRING { Const.string $1 }

prim1 :
  | ADD1 { Add1 }
  | SUB1 { Sub1 }
  | NOT { Not }
  | BOX { Box }
  | UNBOX { Unbox }
  | ISBOOL { IsBool }
  | ISNUM { IsNum }
  | ISTUPLE { IsTuple }

expr :
  binop_expr

binop_expr :
  | binop_expr(<=pp) EOL? PLUS EOL?      binop_expr(<pp) { prerr_string "\nbinop_expr_plus\n"; when_debug ~n:1 (fun () -> dyp.print_state stderr); Exp.prim2 ~loc:(symbol_rloc dyp) Plus $1 $5 } pp
  | binop_expr(<=pp) EOL? DASH EOL?      binop_expr(<pp) { Exp.prim2 ~loc:(symbol_rloc dyp) Minus $1 $5 } pp
  | binop_expr(<=pt) EOL? STAR EOL?      binop_expr(<pt) { Exp.prim2 ~loc:(symbol_rloc dyp) Times $1 $5 } pt
  | binop_expr(<=pc) EOL? EQEQ EOL?      binop_expr(<pc) { Exp.prim2 ~loc:(symbol_rloc dyp) Eq $1 $5 } pc
  | binop_expr(<=pc) EOL? LCARET EOL?    binop_expr(<pc) { Exp.prim2 ~loc:(symbol_rloc dyp) Less $1 $5 } pc
  | binop_expr(<=pc) EOL? RCARET EOL?    binop_expr(<pc) { Exp.prim2 ~loc:(symbol_rloc dyp) Greater $1 $5 } pc
  | binop_expr(<=pc) EOL? LESSEQ EOL?    binop_expr(<pc) { Exp.prim2 ~loc:(symbol_rloc dyp) LessEq $1 $5 } pc
  | binop_expr(<=pc) EOL? GREATEREQ EOL? binop_expr(<pc) { Exp.prim2 ~loc:(symbol_rloc dyp) GreaterEq $1 $5 } pc
  | binop_expr(<=pb) EOL? AND EOL?       binop_expr(<pb) { Exp.prim2 ~loc:(symbol_rloc dyp) And $1 $5 } pb
  | binop_expr(<=pb) EOL? OR EOL?        binop_expr(<pb) { Exp.prim2 ~loc:(symbol_rloc dyp) Or $1 $5 } pb
  | non_assign_expr { $1 } pe
  | assign_expr { $1 } pa

non_binop_expr :
  | non_assign_expr { $1 } pe
  | assign_expr { $1 } pa

pattern :
  | pattern colon typ { Pat.constraint_ ~loc:(symbol_rloc dyp) $1 $3 }
  | UNDERSCORE { Pat.any ~loc:(symbol_rloc dyp) () }
  /* If the pattern uses an external ID, we know it's a constructor, not a variable */
  | ext_constructor { Pat.construct ~loc:(symbol_rloc dyp) $1 [] }
  | ID { Pat.var ~loc:(symbol_rloc dyp) (mkstr dyp $1) }
  | lparen tuple_patterns rparen { Pat.tuple ~loc:(symbol_rloc dyp) $2 }
  | lparen pattern rparen { $2 }
  | lbrace record_patterns rbrace { Pat.record ~loc:(symbol_rloc dyp) $2 }
  | type_id lparen tuple_patterns rparen { Pat.construct ~loc:(symbol_rloc dyp) $1 $3 }
  | type_id { Pat.construct ~loc:(symbol_rloc dyp) $1 [] }

patterns :
  | pattern [comma pattern {$2}]* { $1::$2 }

tuple_patterns :
  | pattern comma { [$1] }
  | pattern [comma pattern {$2}]+ { $1::$2 }

record_patterns :
  | record_pattern [comma record_pattern {$2}]* { $1::$2 }

record_pattern :
  | UNDERSCORE { None, Open }
  | id colon pattern { Some($1, $3), Closed }
  | id { Some($1, Pat.var ~loc:(symbol_rloc dyp) (mkstr dyp (Identifier.last $1.txt))), Closed }

data_typ :
  | type_id lcaret typ [comma typ {$2}]* rcaret { Typ.constr $1 ($3::$4) }
  | type_id { Typ.constr $1 [] }

typ :
  /* Convenience: Parens optional for single-argument functions */
  | data_typ arrow typ { Typ.arrow ~loc:(symbol_rloc dyp) [$1] $3 }
  | ID arrow typ { Typ.arrow ~loc:(symbol_rloc dyp) [(Typ.var $1)] $3 }
  | lparen typs rparen arrow typ { Typ.arrow ~loc:(symbol_rloc dyp) $2 $5 }
  | lparen tuple_typs rparen { Typ.tuple ~loc:(symbol_rloc dyp) $2 }
  | lparen typ rparen { $2 }
  | ID { Typ.var $1 }
  | data_typ

typs :
  | [typ [comma typ {$2}]* {$1::$2}]? { Option.default [] $1 }

tuple_typs :
  | typ comma { [$1] }
  | typ [comma typ {$2}]+ { $1::$2 }

value_bind :
  | pattern equal expr { Vb.mk ~loc:(symbol_rloc dyp) $1 $3 }

value_binds :
  | value_bind [comma value_bind {$2}]* { $1::$2 }

import_shape :
  | id { PImportModule, Some $1 }
  | STAR [EXCEPT lbrace id [comma id {$2}]* rbrace {$3::$4}]? [AS id {$2}]? { PImportAllExcept (Option.default [] $2), $3 }
  | lbrace [id [AS id {$2}]? [comma id [AS id {$2}]? {($2, $3)}]* {($1, $2)::$3}]? rbrace [AS id {$2}]? { PImportValues (Option.default [] $2), $4 }

import_stmt :
  | IMPORT import_shape [comma import_shape {$2}]* FROM file_path { Imp.mk ($2::$3) $5 }

export_stmt :
  | EXPORT LET REC value_binds { Top.let_ Exported Recursive $4 }
  | EXPORT LET value_binds { Top.let_ Exported Nonrecursive $3 }
  | EXPORT foreign_stmt { Top.foreign ~loc:(symbol_rloc dyp) Exported $2 }
  | EXPORT data_declaration { Top.data Exported $2 }
  | EXPORT any_id_str [AS any_id_str {$2}]? [comma any_id_str [AS any_id_str {$2}]? {$2, $3}]* { Top.export ~loc:(symbol_rloc dyp) (Ex.mk ~loc:(symbol_rloc dyp) (($2, $3)::$4)) }
  | EXPORT STAR [EXCEPT export_id_str [comma export_id_str {$2}]* {$2::$3}]? { Top.export_all ~loc:(symbol_rloc dyp) (Option.default [] $3) }

data_constructor :
  | TYPEID { CDecl.singleton ~loc:(symbol_rloc dyp) (mkstr dyp $1) }
  | TYPEID lparen typs rparen { CDecl.tuple ~loc:(symbol_rloc dyp) (mkstr dyp $1) $3 }

data_constructors :
  | [PIPE EOL?]? data_constructor [pipe data_constructor {$2}]* { $2::$3 }

data_label :
  | simple_id colon typ { LDecl.mk ~loc:(symbol_rloc dyp) $1 $3 }

data_labels :
  | lbrace data_label [comma data_label {$2}]* rbrace { $2::$3 }

data_declaration :
  | DATA TYPEID [lcaret ID [comma ID {$2}]* rcaret {$2::$3}]? equal data_constructors { Dat.variant ~loc:(symbol_rloc dyp) (mkstr dyp $2) (List.map Typ.var (Option.default [] $3)) $5 }
  | DATA TYPEID [lcaret ID [comma ID {$2}]* rcaret {$2::$3}]? equal data_labels { Dat.record ~loc:(symbol_rloc dyp) (mkstr dyp $2) (List.map Typ.var (Option.default [] $3)) $5 }

prim1_expr :
  | prim1 lparen expr rparen { Exp.prim1 ~loc:(symbol_rloc dyp) $1 $3 }

paren_expr :
  | lparen expr rparen { $2 }

app_arg_exprs :
  | [expr [comma expr {$2}]* { $1::$2 }]? { Option.default [] $1 }

app_expr :
  | id_expr lparen app_arg_exprs rparen { prerr_string "\napp_expr\n"; when_debug ~n:1 (fun () -> dyp.print_state stderr); Exp.apply ~loc:(symbol_rloc dyp) $1 $3 }
  | paren_expr lparen app_arg_exprs rparen { prerr_string "\napp_expr\n"; when_debug ~n:1 (fun () -> dyp.print_state stderr); Exp.apply ~loc:(symbol_rloc dyp) $1 $3 }
  | app_expr lparen app_arg_exprs rparen { prerr_string "\napp_expr\n"; when_debug ~n:1 (fun () -> dyp.print_state stderr); Exp.apply ~loc:(symbol_rloc dyp) $1 $3 }

ext_constructor :
  | TYPEID [dot TYPEID {$2}]+ { prerr_string "\nid\n"; when_debug ~n:1 (fun () -> dyp.print_state stderr); (mkid ($1::$2)) (symbol_rloc dyp) }

id :
  | [TYPEID dot {$1}]* [ID | TYPEID] { prerr_string "\nid\n"; when_debug ~n:1 (fun () -> dyp.print_state stderr); (mkid (List.append $1 [$2])) (symbol_rloc dyp) }

simple_id :
  | ID { (mkid [$1]) (symbol_rloc dyp) }

type_id :
  | TYPEID { prerr_string "\nid\n"; when_debug ~n:1 (fun () -> dyp.print_state stderr); (mkid [$1]) (symbol_rloc dyp) }

id_expr :
  | id { prerr_string "\nsimple_expr\n"; when_debug ~n:1 (fun () -> dyp.print_state stderr); Exp.ident ~loc:(symbol_rloc dyp) $1 }

simple_expr :
  | const { Exp.constant ~loc:(symbol_rloc dyp) $1 }
  | lparen tuple_exprs rparen { Exp.tuple ~loc:(symbol_rloc dyp) $2 }
  | lbrace record_exprs rbrace { Exp.record ~loc:(symbol_rloc dyp) $2 }
  | id_expr { $1 }

block_expr :
  | lbrace block_body rbrace { if block_resembles_record $2 then raise Dyp.Giveup else Exp.block ~loc:(symbol_rloc dyp) $2 }

block :
  | lbrace block_body rbrace { Exp.block ~loc:(symbol_rloc dyp) $2 }

lam_args :
  | patterns? { Option.default [] $1 }

lam_expr :
  | lparen lam_args rparen thickarrow block { Exp.lambda ~loc:(symbol_rloc dyp) $2 $5 }

let_expr :
  | LET REC value_binds { Exp.let_ ~loc:(symbol_rloc dyp) Recursive $3 (Exp.block []) }
  | LET value_binds { Exp.let_ ~loc:(symbol_rloc dyp) Nonrecursive $2 (Exp.block []) }

if_expr :
  | IF lparen expr rparen EOL? block { Exp.if_ ~loc:(symbol_rloc dyp) $3 $6 (Exp.block []) }
  | IF lparen expr rparen EOL? block ELSE EOL? block { Exp.if_ ~loc:(symbol_rloc dyp) $3 $6 $9 }

while_expr :
  | WHILE lparen expr rparen block { Exp.while_ ~loc:(symbol_rloc dyp) $3 $5 }

match_branch :
  | pattern thickarrow expr { Mb.mk ~loc:(symbol_rloc dyp) $1 $3 }

match_branches :
  | [pipe match_branch {$2}]+ { $1 }

match_expr :
  | MATCH lparen expr rparen lbrace match_branches rbrace { Exp.match_ ~loc:(symbol_rloc dyp) $3 $6 }

assign_expr :
  | expr EOL? GETS EOL? expr { Exp.assign ~loc:(symbol_rloc dyp) $1 $5 }

non_assign_expr :
  | app_expr    { prerr_string "\nexpr_app_expr\n"; when_debug ~n:1 (fun () -> dyp.print_state stderr); $1 }
  | prim1_expr  { $1 }
  | simple_expr { prerr_string "\nexpr_simple_expr\n"; when_debug ~n:1 (fun () -> dyp.print_state stderr); $1 }
  | record_get  { $1 }
  | paren_expr  { $1 }
  | block_expr  { $1 }
  | lam_expr    { $1 }
  | if_expr     { $1 }
  | while_expr  { $1 }
  | match_expr  { $1 }

block_body_expr :
  | let_expr    { $1 }
  | expr  { $1 }

tuple_exprs :
  | expr comma { [$1] }
  | expr [comma expr {$2}]+ { $1::$2 }

record_get :
  | non_binop_expr dot simple_id { if is_uppercase_ident $1 then raise Dyp.Giveup else Exp.record_get $1 $3 }

record_field :
  | id colon expr { $1, $3 }

record_pun :
  | ID { mkid [$1] (symbol_rloc dyp), Exp.ident ~loc:(symbol_rloc dyp) (mkid [$1] (symbol_rloc dyp)) }

record_exprs :
  | [record_field | record_pun] [comma [record_field | record_pun] {$2}]* {$1::$2}

block_body :
  | block_body_expr [eos block_body_expr {$2}]* eos? { $1::$2 }

file_path :
  | STRING { Location.mkloc $1 (symbol_rloc dyp) }

id_str :
  | ID { Location.mkloc $1 (symbol_rloc dyp) }

type_id_str :
  | TYPEID { Location.mkloc $1 (symbol_rloc dyp) }

any_id_str :
  | id_str { $1 }
  | type_id_str { $1 }

export_id_str :
  | id_str { ExportExceptValue $1 }
  | type_id_str { ExportExceptData $1 }

foreign_stmt :
  | FOREIGN WASM id_str id_str colon typ { Val.mk ~loc:(symbol_rloc dyp) ~mod_:$3 ~name:$4 ~typ:$6 ~prim:[$4.txt] }

toplevel_stmt :
  | LET REC value_binds { Top.let_ Nonexported Recursive $3 }
  | LET value_binds { Top.let_ Nonexported Nonrecursive $2 }
  | import_stmt { Top.import $1 }
  | export_stmt { $1 }
  | foreign_stmt { Top.foreign ~loc:(symbol_rloc dyp) Nonexported $1 }
  | data_declaration { Top.data Nonexported $1 }

toplevel_stmts :
  | toplevel_stmt [eos toplevel_stmt {$2}]* { $1::$2 }

program :
  | EOL? toplevel_stmts eos? EOF { make_program $2 (Exp.null ~loc:dummy_loc ()) }
  | EOL? toplevel_stmts eos expr eos? EOF { make_program $2 $4 }
  | EOL? expr eos? EOF { prerr_string "\nprogram\n"; when_debug ~n:1 (fun () -> dyp.print_state stderr); make_program [] $2 }

%%

{
let parse_program t lexbuf =
  Dyp.dypgen_verbose := !Grain_utils.Config.parser_debug_level;
  first_loc := Location.curr lexbuf;
  with_default_loc_src (fun() -> !last_loc) (fun() -> program t lexbuf)

let print_syntax_error =
  let open Printf in
  let open Location in
  function
  | Syntax_error -> begin
      debug_print_state();
      Some(errorf ~loc:(!last_loc) "Syntax error")
    end
  | _ -> None

let () =
  Dyp.dypgen_verbose := !Grain_utils.Config.parser_debug_level;
  Location.register_error_of_exn print_syntax_error
}

%mli {
val parse_program : Lexing.lexbuf -> ((Parsetree.parsed_program * 'a) list)
}
