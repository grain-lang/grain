import Map from 'map';
import List from 'list';
import Array from 'array';

# Data types used in multiple tests
data Resource = Grain | Sheep | Brick | Wood;
data ResourceData = { name: String, emoji: String }

### Map.isEmpty()

let e = Map.make();

assert Map.isEmpty(e) == true;
Map.set("ğŸŒ¾", "ğŸŒ¾", e);
assert Map.isEmpty(e) == false;

### Map.size()

let s = Map.make();

Map.set("ğŸŒ¾", 1, s);
Map.set("ğŸ‘", 2, s);
Map.set("ğŸ§±", 3, s);

assert Map.size(s) == 3;

### Map.clear()

let c = Map.make();

Map.set("ğŸŒ¾", 1, c);
Map.set("ğŸ‘", 2, c);
Map.set("ğŸ§±", 3, c);

assert Map.isEmpty(c) == false;

assert Map.clear(c) == void;

assert Map.isEmpty(c) == true;

### Map.contains()

let h = Map.make();

Map.set("ğŸŒ¾", 1, h);
Map.set("ğŸ‘", 2, h);
Map.set("ğŸ§±", 3, h);

assert Map.contains("ğŸŒ¾", h) == true;
assert Map.contains("ğŸ‘", h) == true;
assert Map.contains("ğŸ§±", h) == true;
assert Map.contains("ğŸŒ³", h) == false;

### Map.set() & Map.get()

# With Number keys
let nums = Map.make();

assert Map.set(1, "ğŸŒ¾", nums) == void;
assert Map.set(2, "ğŸ‘", nums) == void;
assert Map.set(3, "ğŸ§±", nums) == void;

assert Map.get(1, nums) == Some("ğŸŒ¾");
assert Map.get(2, nums) == Some("ğŸ‘");
assert Map.get(3, nums) == Some("ğŸ§±");
assert Map.get(4, nums) == None;

# With String keys
let strs = Map.make();

assert Map.set("ğŸŒ¾", 1, strs) == void;
assert Map.set("ğŸ‘", 2, strs) == void;
assert Map.set("ğŸ§±", 3, strs) == void;

assert Map.get("ğŸŒ¾", strs) == Some(1);
assert Map.get("ğŸ‘", strs) == Some(2);
assert Map.get("ğŸ§±", strs) == Some(3);
assert Map.get("ğŸŒ³", strs) == None;

# With variant keys
let vars = Map.make();

assert Map.set(Grain, "ğŸŒ¾", vars) == void;
assert Map.set(Sheep, "ğŸ‘", vars) == void;
assert Map.set(Brick, "ğŸ§±", vars) == void;

assert Map.get(Grain, vars) == Some("ğŸŒ¾");
assert Map.get(Sheep, vars) == Some("ğŸ‘");
assert Map.get(Brick, vars) == Some("ğŸ§±");
assert Map.get(Wood, vars) == None;

# With record keys
let recs = Map.make();

assert Map.set({ name: "Grain", emoji: "ğŸŒ¾" }, 1, recs) == void;
assert Map.set({ name: "Sheep", emoji: "ğŸ‘" }, 2, recs) == void;
assert Map.set({ name: "Brick", emoji: "ğŸ§±" }, 3, recs) == void;

assert Map.get({ name: "Grain", emoji: "ğŸŒ¾" }, recs) == Some(1);
assert Map.get({ name: "Sheep", emoji: "ğŸ‘" }, recs) == Some(2);
assert Map.get({ name: "Brick", emoji: "ğŸ§±" }, recs) == Some(3);
assert Map.get({ name: "Wood", emoji: "ğŸŒ³" }, recs) == None;

# Overwriting data
let o = Map.make();

assert Map.set(1, "ğŸ‘", o) == void;
assert Map.set(1, "ğŸŒ¾", o) == void;

assert Map.get(1, o) == Some("ğŸŒ¾");

### Map.remove()

let r = Map.make();

Map.set("ğŸŒ¾", 1, r);
Map.set("ğŸ‘", 2, r);
Map.set("ğŸ§±", 3, r);

assert Map.size(r) == 3;

assert Map.remove("ğŸ‘", r) == void;

assert Map.size(r) == 2;
assert Map.get("ğŸ‘", r) == None;

assert Map.remove("ğŸŒ³", r) == void;

assert Map.size(r) == 2;

assert Map.remove("ğŸŒ¾", r) == void;
assert Map.get("ğŸŒ¾", r) == None;

assert Map.remove("ğŸ§±", r) == void;
assert Map.get("ğŸ§±", r) == None;

assert Map.isEmpty(r);

### Map.forEach()

let fe = Map.make();

Map.set(Grain, "ğŸŒ¾", fe);
Map.set(Sheep, "ğŸ‘", fe);
Map.set(Brick, "ğŸ§±", fe);

let mut called = 0;

Map.forEach((key, value) => {
  called += 1;
  match (key) {
    | Grain => assert value == "ğŸŒ¾"
    | Sheep => assert value == "ğŸ‘"
    | Brick => assert value == "ğŸ§±"
    | _ => fail "Map.forEach() should not contain this value."
  }
}, fe);

assert called == 3;

### Map.reduce()

let r = Map.make();

Map.set(Grain, 1, r);
Map.set(Sheep, 2, r);
Map.set(Brick, 3, r);

let mut called = 0;

let result = Map.reduce((acc, key, value) => {
  called += 1;
  match (key) {
    | Grain => assert value == 1
    | Sheep => assert value == 2
    | Brick => assert value == 3
    | _ => fail "Map.reduce() should not contain this value."
  };
  acc + value
}, 0, r);

assert called == 3;
assert result == 6;

### Map.keys() & Map.values();

let kvs = Map.make();

Map.set(Grain, "ğŸŒ¾", kvs);
Map.set(Sheep, "ğŸ‘", kvs);
Map.set(Brick, "ğŸ§±", kvs);

let keys = Map.keys(kvs);

# No order is guaranteed
assert List.contains(Grain, keys);
assert List.contains(Sheep, keys);
assert List.contains(Brick, keys);
assert List.contains(Wood, keys) == false;

let vals = Map.values(kvs);

# No order is guaranteed
assert List.contains("ğŸŒ¾", vals);
assert List.contains("ğŸ‘", vals);
assert List.contains("ğŸ§±", vals);
assert List.contains("ğŸŒ³", vals) == false;

### Map.toList()

let tl = Map.make();

Map.set(Grain, "ğŸŒ¾", tl);
Map.set(Sheep, "ğŸ‘", tl);
Map.set(Brick, "ğŸ§±", tl);

let lis = Map.toList(tl);

# No order is guaranteed
assert List.contains((Grain, "ğŸŒ¾"), lis);
assert List.contains((Sheep, "ğŸ‘"), lis);
assert List.contains((Brick, "ğŸ§±"), lis);
assert List.contains((Wood, "ğŸŒ³"), lis) == false;

### Map.fromList()

let fl = Map.fromList([
  (Grain, "ğŸŒ¾"),
  (Sheep, "ğŸ‘"),
  (Brick, "ğŸ§±")
]);

assert Map.contains(Grain, fl);
assert Map.contains(Sheep, fl);
assert Map.contains(Brick, fl);
assert Map.contains(Wood, fl) == false;

### Map.toArray()

let ta = Map.make();

Map.set(Grain, "ğŸŒ¾", ta);
Map.set(Sheep, "ğŸ‘", ta);
Map.set(Brick, "ğŸ§±", ta);

let arr = Map.toArray(ta);

# No order is guaranteed
assert Array.contains((Grain, "ğŸŒ¾"), arr);
assert Array.contains((Sheep, "ğŸ‘"), arr);
assert Array.contains((Brick, "ğŸ§±"), arr);
assert Array.contains((Wood, "ğŸŒ³"), arr) == false;

### Map.fromArray()

let fa = Map.fromArray([> (Grain, "ğŸŒ¾"), (Sheep, "ğŸ‘"), (Brick, "ğŸ§±")]);

assert Map.contains(Grain, fa);
assert Map.contains(Sheep, fa);
assert Map.contains(Brick, fa);
assert Map.contains(Wood, fa) == false;

### Resizes the map when it grows
# TODO: Don't use these internals, as they need to change
# after https://github.com/grain-lang/grain/issues/190 is fixed

let resize = Map.makeSized(1);

# (nodeCount, bucketLength)
assert Map.getInternalStats(resize) == (0, 1);

Map.set("ğŸŒ¾", 1, resize);
Map.set("ğŸ‘", 1, resize);

# (nodeCount, bucketLength)
assert Map.getInternalStats(resize) == (2, 1);

Map.set("ğŸ§±", 1, resize);

# (nodeCount, bucketLength)
assert Map.getInternalStats(resize) == (3, 2);
