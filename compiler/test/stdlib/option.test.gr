import Option from 'option'
import String from 'string'

# Option.isSome

assert Option.isSome(Some(1)) == true
assert Option.isSome(Some('ğŸŒ¾')) == true
assert Option.isSome(None) == false

# Option.isNone

assert Option.isNone(None) == true
assert Option.isNone(Some(1)) == false
assert Option.isNone(Some('ğŸŒ¾')) == false

# Option.contains

assert Option.contains(1, Some(1)) == true
assert Option.contains(2, Some(1)) == false
assert Option.contains('ğŸŒ¾', Some('ğŸŒ¾')) == true
assert Option.contains('ğŸŒ¾', Some('ğŸ‘')) == false
assert Option.contains('ğŸŒ¾', None) == false

# Option.expect

assert Option.expect('Fails with this message if none', Some(1)) == 1
assert Option.expect('Fails with this message if none', Some('ğŸŒ¾')) == 'ğŸŒ¾'
# TODO: Test this when we can
# assert Option.expect('Failed with this message', None)

# Option.unwrap

assert Option.unwrap(Some(1)) == 1
assert Option.unwrap(Some('ğŸŒ¾')) == 'ğŸŒ¾'
# TODO: Test this when we can
# assert Option.unwrap(None)

# Option.unwrapWithDefault

assert Option.unwrapWithDefault(2, Some(1)) == 1
assert Option.unwrapWithDefault('ğŸ‘', Some('ğŸŒ¾')) == 'ğŸŒ¾'
assert Option.unwrapWithDefault(2, None) == 2
assert Option.unwrapWithDefault('ğŸ‘', None) == 'ğŸ‘'

# Option.map

assert Option.map((x) => x * 2, Some(2)) == Some(4)
assert Option.map((x) => String.concat('hello ', x), Some('ğŸŒ¾')) == Some('hello ğŸŒ¾')
assert Option.map((x) => fail 'Should not be called', None) == None

# Option.mapWithDefault

assert Option.mapWithDefault(1, (x) => x * 2, Some(2)) == 4
assert Option.mapWithDefault('ğŸ‘', (x) => String.concat('hello ', x), Some('ğŸŒ¾')) == 'hello ğŸŒ¾'
assert Option.mapWithDefault(1, (x) => x * 2, None) == 1
assert Option.mapWithDefault('ğŸ‘', (x) => String.concat('hello ', x), None) == 'ğŸ‘'

# Option.flatMap

assert Option.flatMap((x) => Some(x * 2), Some(2)) == Some(4)
assert Option.flatMap((x) => Some(String.concat('hello ', x)), Some('ğŸŒ¾')) == Some('hello ğŸŒ¾')
assert Option.flatMap((x) => None, Some('ğŸŒ¾')) == None
assert Option.flatMap((x) => fail 'Should not be called', None) == None

# Option.filter

assert Option.filter((x) => x == 2, Some(2)) == Some(2)
assert Option.filter((x) => x == 2, Some(1)) == None
assert Option.filter((x) => fail 'Should not be called', None) == None

# Option.zip

assert Option.zip(Some(1), Some(2)) == Some((1, 2))
assert Option.zip(Some(1), Some('ğŸŒ¾')) == Some((1, 'ğŸŒ¾'))
assert Option.zip(Some(1), None) == None
assert Option.zip(None, Some('ğŸŒ¾')) == None

# Option.zipWith

assert Option.zipWith((a, b) => a + b, Some(1), Some(2)) == Some(3)
assert Option.zipWith((a, b) => (a, b), Some(1), Some('ğŸŒ¾')) == Some((1, 'ğŸŒ¾'))
assert Option.zipWith((a, b) => fail 'Should not be called',Some(1), None) == None
assert Option.zipWith((a, b) => fail 'Should not be called', None, Some('ğŸŒ¾')) == None

# Option.flatten

assert Option.flatten(Some(Some(1))) == Some(1)
assert Option.flatten(Some(None)) == None
assert Option.flatten(None) == None

# Option.toList

assert Option.toList(Some(1)) == [1]
assert Option.toList(Some('ğŸŒ¾')) == ['ğŸŒ¾']
assert Option.toList(None) == []

# Option.toArray

assert Option.toArray(Some(1)) == [> 1]
assert Option.toArray(Some('ğŸŒ¾')) == [> 'ğŸŒ¾']
assert Option.toArray(None) == [>]

# Option.sideEffect

let mut a = 2

Option.sideEffect((x) => ignore(a *= x), Some(2))

assert a == 4

let mut b = 'ğŸŒ¾'

Option.sideEffect((x) => fail 'Should not be called', None)

assert b == 'ğŸŒ¾'

# Option.peek

let mut c = 2

assert Option.peek((x) => ignore(c *= x), Some(2)) == Some(2)
assert c == 4

let mut d = 'ğŸŒ¾'
assert Option.peek((x) => fail 'Should not be called', None) == None
assert d == 'ğŸŒ¾'
