module OptionTest

from "option" include Option
from "string" include String

// Option.isSome

assert Option.isSome(Some(1)) == true
assert Option.isSome(Some("ðŸŒ¾")) == true
assert Option.isSome(None) == false

// Option.isNone

assert Option.isNone(None) == true
assert Option.isNone(Some(1)) == false
assert Option.isNone(Some("ðŸŒ¾")) == false

// Option.contains

assert Option.contains(1, Some(1)) == true
assert Option.contains(2, Some(1)) == false
assert Option.contains("ðŸŒ¾", Some("ðŸŒ¾")) == true
assert Option.contains("ðŸŒ¾", Some("ðŸ‘")) == false
assert Option.contains("ðŸŒ¾", None) == false

// Option.expect

assert Option.expect("Fails with this message if none", Some(1)) == 1
assert Option.expect("Fails with this message if none", Some("ðŸŒ¾")) == "ðŸŒ¾"
// TODO: Test this when we can
// assert Option.expect("Failed with this message", None)

// Option.unwrap

assert Option.unwrap(Some(1)) == 1
assert Option.unwrap(Some("ðŸŒ¾")) == "ðŸŒ¾"
// TODO: Test this when we can
// assert Option.unwrap(None)

// Option.unwrapWithDefault

assert Option.unwrapWithDefault(2, Some(1)) == 1
assert Option.unwrapWithDefault("ðŸ‘", Some("ðŸŒ¾")) == "ðŸŒ¾"
assert Option.unwrapWithDefault(2, None) == 2
assert Option.unwrapWithDefault("ðŸ‘", None) == "ðŸ‘"

// Option.map

assert Option.map(x => x * 2, Some(2)) == Some(4)
assert Option.map(x => String.concat("hello ", x), Some("ðŸŒ¾")) == Some("hello ðŸŒ¾")
assert Option.map(x => fail "Shouldn't be called", None) == None

// Option.mapWithDefault

assert Option.mapWithDefault(x => x * 2, 1, Some(2)) == 4
assert Option.mapWithDefault(x => String.concat("hello ", x), "ðŸ‘", Some("ðŸŒ¾")) ==
  "hello ðŸŒ¾"
assert Option.mapWithDefault(x => x * 2, 1, None) == 1
assert Option.mapWithDefault(x => String.concat("hello ", x), "ðŸ‘", None) == "ðŸ‘"

// Option.mapWithDefaultFn

assert Option.mapWithDefaultFn(
  x => x * 2,
  () => fail "Shouldn't be called",
  Some(2)
) ==
  4
assert Option.mapWithDefaultFn(
  x => String.concat("hello ", x),
  () => fail "Shouldn't be called",
  Some("ðŸŒ¾")
) ==
  "hello ðŸŒ¾"
assert Option.mapWithDefaultFn(x => fail "Shouldn't be called", () => 1, None) ==
  1
assert Option.mapWithDefaultFn(x => fail "Shouldn't be called", () => "ðŸ‘", None) ==
  "ðŸ‘"

// Option.flatMap

assert Option.flatMap(x => Some(x * 2), Some(2)) == Some(4)
assert Option.flatMap(x => Some(String.concat("hello ", x)), Some("ðŸŒ¾")) ==
  Some("hello ðŸŒ¾")
assert Option.flatMap(x => None, Some("ðŸŒ¾")) == None
assert Option.flatMap(x => fail "Shouldn't be called", None) == None

// Option.filter

assert Option.filter(x => x == 2, Some(2)) == Some(2)
assert Option.filter(x => x == 2, Some(1)) == None
assert Option.filter(x => fail "Shouldn't be called", None) == None

// Option.zip

assert Option.zip(Some(1), Some(2)) == Some((1, 2))
assert Option.zip(Some(1), Some("ðŸŒ¾")) == Some((1, "ðŸŒ¾"))
assert Option.zip(Some(1), None) == None
assert Option.zip(None, Some("ðŸŒ¾")) == None

// Option.zipWith

assert Option.zipWith((a, b) => a + b, Some(1), Some(2)) == Some(3)
assert Option.zipWith((a, b) => (a, b), Some(1), Some("ðŸŒ¾")) == Some((1, "ðŸŒ¾"))
assert Option.zipWith((a, b) => fail "Shouldn't be called", Some(1), None) ==
  None
assert Option.zipWith((a, b) => fail "Shouldn't be called", None, Some("ðŸŒ¾")) ==
  None

// Option.flatten

assert Option.flatten(Some(Some(1))) == Some(1)
assert Option.flatten(Some(None)) == None
assert Option.flatten(None) == None

// Option.toList

assert Option.toList(Some(1)) == [1]
assert Option.toList(Some("ðŸŒ¾")) == ["ðŸŒ¾"]
assert Option.toList(None) == []

// Option.toArray

assert Option.toArray(Some(1)) == [> 1]
assert Option.toArray(Some("ðŸŒ¾")) == [> "ðŸŒ¾"]
assert Option.toArray(None) == [>]

// Option.sideEffect

let mut a = 2

Option.sideEffect(x => a *= x, Some(2))

assert a == 4

let mut b = "ðŸŒ¾"

Option.sideEffect(x => fail "Shouldn't be called", None)

assert b == "ðŸŒ¾"

// Option.peek

let mut c = 2

assert Option.peek(x => c *= x, Some(2)) == Some(2)
assert c == 4

let mut d = "ðŸŒ¾"
assert Option.peek(x => fail "Shouldn't be called", None) == None
assert d == "ðŸŒ¾"

use Option.{ (||), (&&) }

// Option.(||)
assert (Some(1) || Some(2)) == Some(1)
assert (Some(1) || None) == Some(1)
assert (None || Some(2)) == Some(2)
assert (None || None) == None

// Option.(&&)
assert (Some(1) && Some(2)) == Some(2)
assert (Some(1) && None) == None
assert (None && Some(2)) == None
assert (None && None) == None

// Option.toResult
assert Option.toResult("Nope", Some(1)) == Ok(1)
assert Option.toResult("Yes!", None) == Err("Yes!")
