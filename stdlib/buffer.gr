/**
 * Utilities for working with buffers.
 *
 * Buffers are data structures that automatically expand as more data is appended. They are useful for storing and operating on an unknown number of bytes. All set or append operations mutate the buffer.
 * @example include "buffer"
 *
 * @since v0.4.0
 */

module Buffer

include "runtime/unsafe/memory"
include "runtime/unsafe/wasmi32"
include "runtime/unsafe/conv"
include "runtime/exception"
include "int32"
include "bytes"
include "string"
include "char"
include "runtime/numbers"
from Numbers use { coerceNumberToWasmI32 }

abstract record Buffer {
  mut len: Number,
  initialSize: Number,
  mut data: Bytes,
}

@unsafe
let mut _SIZE_OFFSET = 4n

@unsafe
let mut _VALUE_OFFSET = 8n

let _8BIT_LEN = 1

let _16BIT_LEN = 2

let _32BIT_LEN = 4

let _64BIT_LEN = 8

/* Gets the size of a Bytes via its ptr */
@unsafe
let getSize = ptr => WasmI32.load(ptr, _SIZE_OFFSET)

/* Doubles the size of buffer's underlying byte sequence, if the given size is larger than the size of a buffer's underlying byte sequence */
let autogrow = (len, buf) => {
  let requiredMinimumSize = buf.len + len
  let currentSize = Bytes.length(buf.data)

  if (requiredMinimumSize > currentSize) {
    let mut newSize = if (currentSize > 0) {
      currentSize
    } else {
      // Make sure bytes of 0 length grow too
      4
    }

    while (newSize < requiredMinimumSize) {
      newSize *= 2
    }

    let growBy = newSize - currentSize

    buf.data = Bytes.resize(0, growBy, buf.data)
  }
}

/* Memcopies bytes from a source byte sequence to a destination byte sequence via pointers */
@unsafe
let appendBytes = (srcOff, dstOff, len, src, dst) => {
  from WasmI32 use { (+) }
  Memory.copy(dst + _VALUE_OFFSET + dstOff, src + _VALUE_OFFSET + srcOff, len)
}

/*
 * If given index is negative, returns a positive index.
 * Throws if a given index + len is not within the bounds of a buffer's current length
 */
let checkIsIndexInBounds = (i, len, buf) => {
  if (i < 0) throw IndexOutOfBounds
  if (i >= buf.len || i + len > buf.len) throw IndexOutOfBounds
}

let addInt8help = (value, buffer) => {
  autogrow(_8BIT_LEN, buffer)
  let index = buffer.len
  buffer.len += _8BIT_LEN
  Bytes.setInt8(index, value, buffer.data)
}

let addUint8help = (value, buffer) => {
  autogrow(_8BIT_LEN, buffer)
  let index = buffer.len
  buffer.len += _8BIT_LEN
  Bytes.setUint8(index, value, buffer.data)
}

let addInt16help = (value, buffer) => {
  autogrow(_16BIT_LEN, buffer)
  let index = buffer.len
  buffer.len += _16BIT_LEN
  Bytes.setInt16(index, value, buffer.data)
}

let addUint16help = (value, buffer) => {
  autogrow(_16BIT_LEN, buffer)
  let index = buffer.len
  buffer.len += _16BIT_LEN
  Bytes.setUint16(index, value, buffer.data)
}

let addInt32help = (value, buffer) => {
  autogrow(_32BIT_LEN, buffer)
  let index = buffer.len
  buffer.len += _32BIT_LEN
  Bytes.setInt32(index, value, buffer.data)
}

let addUint32help = (value, buffer) => {
  autogrow(_32BIT_LEN, buffer)
  let index = buffer.len
  buffer.len += _32BIT_LEN
  Bytes.setUint32(index, value, buffer.data)
}

/**
 * Creates a fresh buffer, initially empty.
 *
 * The `initialSize` parameter is the initial size of the internal byte sequence that holds the buffer contents.
 * That byte sequence is automatically reallocated when more than `initialSize` bytes are stored in the buffer, but shrinks back to `initialSize` characters when reset is called.
 *
 * @param initialSize: The initial size of the buffer
 * @returns The new buffer
 *
 * @throws InvalidArgument(String): When the `initialSize` is a negative number
 *
 * @since v0.4.0
 */
provide let make = initialSize => {
  if (initialSize < 0)
    throw Exception.InvalidArgument("Buffers size must be >= 0")
  { len: 0, initialSize, data: Bytes.make(initialSize) }
}

/**
 * Gets the number of bytes currently contained in a buffer.
 *
 * @param buffer: The buffer to access
 * @returns The length of the buffer in bytes
 *
 * @since v0.4.0
 */
provide let length = buffer => buffer.len

/**
 * Clears data in the buffer and sets its length to zero.
 *
 * This operation does not resize the underlying byte sequence.
 *
 * @param buffer: The buffer to clear
 *
 * @since v0.4.0
 */
provide let clear = buffer => {
  Bytes.clear(buffer.data)
  buffer.len = 0
}

/**
 * Empty a buffer and deallocate the internal byte sequence holding the buffer contents.
 *
 * This operation resizes the underlying byte sequence to the initial size of the buffer.
 *
 * @param buffer: The buffer to reset
 *
 * @since v0.4.0
 */
provide let reset = buffer => {
  buffer.data = Bytes.make(buffer.initialSize)
  buffer.len = 0
}

/**
 * Shortens a buffer to the given length.
 *
 * This operation does not resize the underlying byte sequence.
 *
 * @param length: The number of bytes to truncate the buffer to
 * @param buffer: The buffer to truncate
 *
 * @throws IndexOutOfBounds: When the `length` is negative
 * @throws IndexOutOfBounds: When the `length` is greater than the buffer size
 *
 * @since v0.4.0
 */
@unsafe
provide let truncate = (length, buffer) => {
  if (length < 0 || length > buffer.len) throw IndexOutOfBounds

  from WasmI32 use { (+), (-) }
  let src = WasmI32.fromGrain(buffer.data)
  let size = getSize(src)
  let off = coerceNumberToWasmI32(length)
  let ret = Memory.fill(src + _VALUE_OFFSET + off, 0n, size - off)
  buffer.len = length
}

/**
 * Returns a copy of the current contents of the buffer as a byte sequence.
 *
 * @param buffer: The buffer to copy into a byte sequence
 * @returns A byte sequence made from copied buffer data
 *
 * @since v0.4.0
 */
provide let toBytes = buffer => {
  Bytes.slice(0, buffer.len, buffer.data)
}

/**
 * Returns a slice of the current contents of the buffer as a byte sequence.
 *
 * @param start: The start index
 * @param length: The number of bytes to include after the starting index
 * @param buffer: The buffer to copy from
 * @returns A byte sequence with bytes copied from the buffer
 *
 * @throws IndexOutOfBounds: When `start` is negative
 * @throws IndexOutOfBounds: When `start` is greater than or equal to the buffer size
 * @throws IndexOutOfBounds: When `start + length` is greater than the buffer size
 *
 * @since v0.4.0
 */
provide let toBytesSlice = (start, length, buffer) => {
  checkIsIndexInBounds(start, length, buffer)
  Bytes.slice(start, length, buffer.data)
}

/**
 * Returns a copy of the current contents of the buffer as a string.
 *
 * @param buffer: The buffer to stringify
 * @returns A string made with data copied from the buffer
 *
 * @since v0.4.0
 */
provide let toString = buffer => {
  Bytes.toString(toBytes(buffer))
}

/**
 * Returns a copy of a subset of the current contents of the buffer as a string.
 *
 * @param start: The start index
 * @param length: The number of bytes to include after the starting index
 * @param buffer: The buffer to copy from
 * @returns A string made with a subset of data copied from the buffer
 *
 * @since v0.4.0
 */
provide let toStringSlice = (start, length, buffer) => {
  Bytes.toString(toBytesSlice(start, length, buffer))
}

/**
 * Appends a byte sequence to a buffer.
 *
 * @param bytes: The byte sequence to append
 * @param buffer: The buffer to mutate
 *
 * @since v0.4.0
 */
@unsafe
provide let addBytes = (bytes, buffer) => {
  let bytelen = Bytes.length(bytes)

  autogrow(bytelen, buffer)

  let off = coerceNumberToWasmI32(buffer.len)
  let len = getSize(WasmI32.fromGrain(bytes))
  let src = WasmI32.fromGrain(bytes)
  let dst = WasmI32.fromGrain(buffer.data)
  appendBytes(0n, off, len, src, dst)

  buffer.len += bytelen
}

/**
 * Appends the bytes of a string to a buffer.
 *
 * @param string: The string to append
 * @param buffer: The buffer to mutate
 *
 * @since v0.4.0
 */
@unsafe
provide let addString = (string, buffer) => {
  let bytelen = String.byteLength(string)

  autogrow(bytelen, buffer)

  let off = coerceNumberToWasmI32(buffer.len)
  let len = getSize(WasmI32.fromGrain(string))
  let src = WasmI32.fromGrain(string)
  let dst = WasmI32.fromGrain(buffer.data)
  appendBytes(0n, off, len, src, dst)

  buffer.len += bytelen
}

/**
 * Appends the bytes of a character to a buffer.
 *
 * @param char: The character to append to the buffer
 * @param buffer: The buffer to mutate
 *
 * @since v0.4.0
 */
provide let addChar = (char, buffer) => {
  addString(Char.toString(char), buffer)
}

/**
 * Appends a character represented by a code point to a buffer.
 *
 * @param codePoint: The code point to append to the buffer
 * @param buffer: The buffer to mutate
 *
 * @since v0.6.0
 */
provide let addCharFromCodePoint = (codePoint: Number, buffer) => {
  addChar(Char.fromCode(codePoint), buffer)
}

/**
 * Appends the bytes of a subset of a string to a buffer.
 *
 * @param start: The char offset into the string
 * @param end: The end offset into the string
 * @param string: The string to append
 * @param buffer: The buffer to mutate
 *
 * @since v0.4.0
 * @history v0.5.0: Now takes the end offset instead of length
 */
@unsafe
provide let addStringSlice = (start: Number, end, string, buffer) => {
  let slice = String.slice(start, end=end, string)

  let bytelen = String.byteLength(slice)

  autogrow(bytelen, buffer)

  let srcOff = 0n
  let dstOff = coerceNumberToWasmI32(buffer.len)
  let src = WasmI32.fromGrain(slice)
  let dst = WasmI32.fromGrain(buffer.data)
  appendBytes(srcOff, dstOff, coerceNumberToWasmI32(bytelen), src, dst)

  buffer.len += bytelen
}

/**
 * Appends the bytes of a subset of a byte sequence to a buffer.
 *
 * @param start: The byte offset into the byte sequence
 * @param length: The number of bytes to append
 * @param bytes: The byte sequence to append
 * @param buffer: The buffer to mutate
 *
 * @throws IndexOutOfBounds: When the `start` is negative
 * @throws IndexOutOfBounds: When the `start` is greater than or equal to the `bytes` size
 * @throws IndexOutOfBounds: When the `length` is negative
 * @throws IndexOutOfBounds: When the `length` is greater than the `bytes` length minus `start`
 *
 * @since v0.4.0
 */
@unsafe
provide let addBytesSlice =
  (
    start: Number,
    length: Number,
    bytes: Bytes,
    buffer: Buffer,
  ) => {
  if (length != 0) {
    from WasmI32 use { (-), (<), (>), (>=) }

    // bounds check start
    let bytelen = WasmI32.load(WasmI32.fromGrain(bytes), 4n)
    let srcOff = coerceNumberToWasmI32(start)
    if (srcOff < 0n || srcOff >= bytelen) {
      throw IndexOutOfBounds
    }

    // bounds check length
    let len = coerceNumberToWasmI32(length)
    if (len < 0n || len > bytelen - srcOff) {
      throw IndexOutOfBounds
    }

    autogrow(length, buffer)

    let dstOff = coerceNumberToWasmI32(buffer.len)
    let src = WasmI32.fromGrain(bytes)
    let dst = WasmI32.fromGrain(buffer.data)
    appendBytes(srcOff, dstOff, len, src, dst)

    buffer.len += length
  }
}

/**
 * Appends the bytes of a source buffer to destination buffer.
 *
 * The source buffer is not mutated by this operation. The destination buffer, however, is mutated.
 *
 * @param srcBuffer: The buffer to append
 * @param dstBuffer: The buffer to mutate
 *
 * @since v0.4.0
 */
provide let addBuffer = (srcBuffer, dstBuffer) => {
  addBytesSlice(0, srcBuffer.len, srcBuffer.data, dstBuffer)
}

/**
 * Appends the bytes of a part of a buffer to the end of the buffer
 *
 * The source buffer is not mutated by this operation. The destination buffer, however, is mutated.
 *
 * @param start: The byte offset into the buffer
 * @param length: The number of bytes to append
 * @param srcBuffer: The buffer to append
 * @param dstBuffer: The buffer to mutate
 *
 * @since v0.4.0
 */
provide let addBufferSlice = (start, length, srcBuffer, dstBuffer) => {
  addBytesSlice(start, length, srcBuffer.data, dstBuffer)
}

/**
 * Gets a signed 8-bit integer starting at the given byte index.
 *
 * @param index: The byte index to access
 * @param buffer: The buffer to access
 * @returns A signed 8-bit integer that starts at the given index
 *
 * @throws IndexOutOfBounds: When `index` is negative
 * @throws IndexOutOfBounds: When `index` is greater than or equal to the buffer size
 * @throws IndexOutOfBounds: When `index + 1` is greater than the buffer size
 *
 * @since v0.6.0
 * @history v0.4.0: Originally called `getInt8S`, returning an `Int32`
 */
provide let getInt8 = (index, buffer) => {
  checkIsIndexInBounds(index, _8BIT_LEN, buffer)
  Bytes.getInt8(index, buffer.data)
}

/**
 * Sets a signed 8-bit integer starting at the given byte index.
 *
 * @param index: The byte index to update
 * @param value: The value to set
 * @param buffer: The buffer to mutate
 *
 * @throws IndexOutOfBounds: When `index` is negative
 * @throws IndexOutOfBounds: When `index` is greater than or equal to the buffer size
 * @throws IndexOutOfBounds: When `index + 1` is greater than the buffer size
 *
 * @since v0.4.0
 * @history v0.6.0: `value` argument type changed to `Int8`
 */
provide let setInt8 = (index, value, buffer) => {
  checkIsIndexInBounds(index, _8BIT_LEN, buffer)
  Bytes.setInt8(index, value, buffer.data)
}

/**
 * Appends a signed 8-bit integer to a buffer.
 *
 * @param value: The value to append
 * @param buffer: The buffer to mutate
 *
 * @since v0.4.0
 * @history v0.6.0: `value` argument type changed to `Int8`
 */
provide let addInt8 = (value, buffer) => {
  addInt8help(value, buffer)
}

/**
 * Gets an unsigned 8-bit integer starting at the given byte index.
 *
 * @param index: The byte index to access
 * @param buffer: The buffer to access
 * @returns An unsigned 8-bit integer that starts at the given index
 *
 * @throws IndexOutOfBounds: When `index` is negative
 * @throws IndexOutOfBounds: When `index` is greater than or equal to the buffer size
 * @throws IndexOutOfBounds: When `index + 1` is greater than the buffer size
 *
 * @since v0.6.0
 * @history v0.4.0: Originally called `getInt8U`, returning an `Int32`
 */
provide let getUint8 = (index, buffer) => {
  checkIsIndexInBounds(index, _8BIT_LEN, buffer)
  Bytes.getUint8(index, buffer.data)
}

/**
 * Sets an unsigned 8-bit integer starting at the given byte index.
 *
 * @param index: The byte index to update
 * @param value: The value to set
 * @param buffer: The buffer to mutate
 *
 * @throws IndexOutOfBounds: When `index` is negative
 * @throws IndexOutOfBounds: When `index` is greater than or equal to the buffer size
 * @throws IndexOutOfBounds: When `index + 1` is greater than the buffer size
 *
 * @since v0.6.0
 */
provide let setUint8 = (index, value, buffer) => {
  checkIsIndexInBounds(index, _8BIT_LEN, buffer)
  Bytes.setUint8(index, value, buffer.data)
}

/**
 * Appends an unsigned 8-bit integer to a buffer.
 *
 * @param value: The value to append
 * @param buffer: The buffer to mutate
 *
 * @since v0.6.0
 */
provide let addUint8 = (value, buffer) => {
  addUint8help(value, buffer)
}

/**
 * Gets a signed 16-bit integer starting at the given byte index.
 *
 * @param index: The byte index to access
 * @param buffer: The buffer to access
 * @returns A signed 16-bit integer that starts at the given index
 *
 * @throws IndexOutOfBounds: When `index` is negative
 * @throws IndexOutOfBounds: When `index` is greater than or equal to the buffer size
 * @throws IndexOutOfBounds: When `index + 2` is greater than the buffer size
 *
 * @since v0.6.0
 * @history v0.4.0: Originally called `getInt16S`, returning an `Int32`
 */
provide let getInt16 = (index, buffer) => {
  checkIsIndexInBounds(index, _16BIT_LEN, buffer)
  Bytes.getInt16(index, buffer.data)
}

/**
 * Sets a signed 16-bit integer starting at the given byte index.
 *
 * @param index: The byte index to update
 * @param value: The value to set
 * @param buffer: The buffer to mutate
 *
 * @throws IndexOutOfBounds: When `index` is negative
 * @throws IndexOutOfBounds: When `index` is greater than or equal to the buffer size
 * @throws IndexOutOfBounds: When `index + 2` is greater than the buffer size
 *
 * @since v0.4.0
 * @history v0.6.0: `value` argument type changed to `Int16`
 */
provide let setInt16 = (index, value, buffer) => {
  checkIsIndexInBounds(index, _16BIT_LEN, buffer)
  Bytes.setInt16(index, value, buffer.data)
}

/**
 * Appends a signed 16-bit integer to a buffer.
 *
 * @param value: The value to append
 * @param buffer: The buffer to mutate
 *
 * @since v0.4.0
 * @history v0.6.0: `value` argument type changed to `Int16`
 */
provide let addInt16 = (value, buffer) => {
  addInt16help(value, buffer)
}

/**
 * Gets an unsigned 16-bit integer starting at the given byte index.
 *
 * @param index: The byte index to access
 * @param buffer: The buffer to access
 * @returns An unsigned 16-bit integer that starts at the given index
 *
 * @throws IndexOutOfBounds: When `index` is negative
 * @throws IndexOutOfBounds: When `index` is greater than or equal to the buffer size
 * @throws IndexOutOfBounds: When `index + 2` is greater than the buffer size
 *
 * @since v0.6.0
 * @history v0.4.0: Originally called `getInt16U`, returning an `Int32`
 */
provide let getUint16 = (index, buffer) => {
  checkIsIndexInBounds(index, _16BIT_LEN, buffer)
  Bytes.getUint16(index, buffer.data)
}

/**
 * Sets an unsigned 16-bit integer starting at the given byte index.
 *
 * @param index: The byte index to update
 * @param value: The value to set
 * @param buffer: The buffer to mutate
 *
 * @throws IndexOutOfBounds: When `index` is negative
 * @throws IndexOutOfBounds: When `index` is greater than or equal to the buffer size
 * @throws IndexOutOfBounds: When `index + 2` is greater than the buffer size
 *
 * @since v0.6.0
 */
provide let setUint16 = (index, value, buffer) => {
  checkIsIndexInBounds(index, _16BIT_LEN, buffer)
  Bytes.setUint16(index, value, buffer.data)
}

/**
 * Appends an unsigned 16-bit integer to a buffer.
 *
 * @param value: The value to append
 * @param buffer: The buffer to mutate
 *
 * @since v0.6.0
 */
provide let addUint16 = (value, buffer) => {
  addUint16help(value, buffer)
}

/**
 * Gets a signed 32-bit integer starting at the given byte index.
 *
 * @param index: The byte index to access
 * @param buffer: The buffer to access
 * @returns A signed 32-bit integer that starts at the given index
 *
 * @throws IndexOutOfBounds: When `index` is negative
 * @throws IndexOutOfBounds: When `index` is greater than or equal to the buffer size
 * @throws IndexOutOfBounds: When `index + 4` is greater than the buffer size
 *
 * @since v0.4.0
 */
provide let getInt32 = (index, buffer) => {
  checkIsIndexInBounds(index, _32BIT_LEN, buffer)
  Bytes.getInt32(index, buffer.data)
}

/**
 * Sets a signed 32-bit integer starting at the given byte index.
 *
 * @param index: The byte index to update
 * @param value: The value to set
 * @param buffer: The buffer to mutate
 *
 * @throws IndexOutOfBounds: When `index` is negative
 * @throws IndexOutOfBounds: When `index` is greater than or equal to the buffer size
 * @throws IndexOutOfBounds: When `index + 4` is greater than the buffer size
 *
 * @since v0.4.0
 */
provide let setInt32 = (index, value, buffer) => {
  checkIsIndexInBounds(index, _32BIT_LEN, buffer)
  Bytes.setInt32(index, value, buffer.data)
}

/**
 * Appends a signed 32-bit integer to a buffer.
 *
 * @param value: The value to append
 * @param buffer: The buffer to mutate
 *
 * @since v0.4.0
 */
provide let addInt32 = (value, buffer) => {
  addInt32help(value, buffer)
}

/**
 * Gets an unsigned 32-bit integer starting at the given byte index.
 *
 * @param index: The byte index to access
 * @param buffer: The buffer to access
 * @returns An unsigned 32-bit integer that starts at the given index
 *
 * @throws IndexOutOfBounds: When `index` is negative
 * @throws IndexOutOfBounds: When `index` is greater than or equal to the buffer size
 * @throws IndexOutOfBounds: When `index + 4` is greater than the buffer size
 *
 * @since v0.6.0
 */
provide let getUint32 = (index, buffer) => {
  checkIsIndexInBounds(index, _32BIT_LEN, buffer)
  Bytes.getUint32(index, buffer.data)
}

/**
 * Sets an unsigned 32-bit integer starting at the given byte index.
 *
 * @param index: The byte index to update
 * @param value: The value to set
 * @param buffer: The buffer to mutate
 *
 * @throws IndexOutOfBounds: When `index` is negative
 * @throws IndexOutOfBounds: When `index` is greater than or equal to the buffer size
 * @throws IndexOutOfBounds: When `index + 4` is greater than the buffer size
 *
 * @since v0.6.0
 */
provide let setUint32 = (index, value, buffer) => {
  checkIsIndexInBounds(index, _32BIT_LEN, buffer)
  Bytes.setUint32(index, value, buffer.data)
}

/**
 * Appends an unsigned 32-bit integer to a buffer.
 *
 * @param value: The value to append
 * @param buffer: The buffer to mutate
 *
 * @since v0.6.0
 */
provide let addUint32 = (value, buffer) => {
  addUint32help(value, buffer)
}

/**
 * Gets a 32-bit float starting at the given byte index.
 *
 * @param index: The byte index to access
 * @param buffer: The buffer to access
 * @returns A 32-bit float that starts at the given index
 *
 * @throws IndexOutOfBounds: When `index` is negative
 * @throws IndexOutOfBounds: When `index` is greater than or equal to the buffer size
 * @throws IndexOutOfBounds: When `index + 4` is greater than the buffer size
 *
 * @since v0.4.0
 */
provide let getFloat32 = (index, buffer) => {
  checkIsIndexInBounds(index, _32BIT_LEN, buffer)
  Bytes.getFloat32(index, buffer.data)
}

/**
 * Sets a 32-bit float starting at the given byte index.
 *
 * @param index: The byte index to update
 * @param value: The value to set
 * @param buffer: The buffer to mutate
 *
 * @throws IndexOutOfBounds: When `index` is negative
 * @throws IndexOutOfBounds: When `index` is greater than or equal to the buffer size
 * @throws IndexOutOfBounds: When `index + 4` is greater than the buffer size
 *
 * @since v0.4.0
 */
provide let setFloat32 = (index, value, buffer) => {
  checkIsIndexInBounds(index, _32BIT_LEN, buffer)
  Bytes.setFloat32(index, value, buffer.data)
}

/**
 * Appends a 32-bit float to a buffer.
 *
 * @param value: The value to append
 * @param buffer: The buffer to mutate
 *
 * @since v0.4.0
 */
provide let addFloat32 = (value, buffer) => {
  autogrow(_32BIT_LEN, buffer)
  let index = buffer.len
  buffer.len += _32BIT_LEN
  setFloat32(index, value, buffer)
}

/**
 * Gets a signed 64-bit integer starting at the given byte index.
 *
 * @param index: The byte index to access
 * @param buffer: The buffer to access
 * @returns A signed 64-bit integer that starts at the given index
 *
 * @throws IndexOutOfBounds: When `index` is negative
 * @throws IndexOutOfBounds: When `index` is greater than or equal to the buffer size
 * @throws IndexOutOfBounds: When `index + 8` is greater than the buffer size
 *
 * @since v0.4.0
 */
provide let getInt64 = (index, buffer) => {
  checkIsIndexInBounds(index, _64BIT_LEN, buffer)
  Bytes.getInt64(index, buffer.data)
}

/**
 * Sets a signed 64-bit integer starting at the given byte index.
 *
 * @param index: The byte index to update
 * @param value: The value to set
 * @param buffer: The buffer to mutate
 *
 * @throws IndexOutOfBounds: When `index` is negative
 * @throws IndexOutOfBounds: When `index` is greater than or equal to the buffer size
 * @throws IndexOutOfBounds: When `index + 8` is greater than the buffer size
 *
 * @since v0.4.0
 */
provide let setInt64 = (index, value, buffer) => {
  checkIsIndexInBounds(index, _64BIT_LEN, buffer)
  Bytes.setInt64(index, value, buffer.data)
}

/**
 * Appends a signed 64-bit integer to a buffer.
 *
 * @param value: The value to set
 * @param buffer: The buffer to mutate
 *
 * @since v0.4.0
 */
provide let addInt64 = (value, buffer) => {
  autogrow(_64BIT_LEN, buffer)
  let index = buffer.len
  buffer.len += _64BIT_LEN
  setInt64(index, value, buffer)
}

/**
 * Gets an unsigned 64-bit integer starting at the given byte index.
 *
 * @param index: The byte index to access
 * @param buffer: The buffer to access
 * @returns An unsigned 64-bit integer that starts at the given index
 *
 * @throws IndexOutOfBounds: When `index` is negative
 * @throws IndexOutOfBounds: When `index` is greater than or equal to the buffer size
 * @throws IndexOutOfBounds: When `index + 8` is greater than the buffer size
 *
 * @since v0.6.0
 */
provide let getUint64 = (index, buffer) => {
  checkIsIndexInBounds(index, _64BIT_LEN, buffer)
  Bytes.getUint64(index, buffer.data)
}

/**
 * Sets an unsigned 64-bit integer starting at the given byte index.
 *
 * @param index: The byte index to update
 * @param value: The value to set
 * @param buffer: The buffer to mutate
 *
 * @throws IndexOutOfBounds: When `index` is negative
 * @throws IndexOutOfBounds: When `index` is greater than or equal to the buffer size
 * @throws IndexOutOfBounds: When `index + 8` is greater than the buffer size
 *
 * @since v0.6.0
 */
provide let setUint64 = (index, value, buffer) => {
  checkIsIndexInBounds(index, _64BIT_LEN, buffer)
  Bytes.setUint64(index, value, buffer.data)
}

/**
 * Appends an unsigned 64-bit integer to a buffer.
 *
 * @param value: The value to set
 * @param buffer: The buffer to mutate
 *
 * @since v0.6.0
 */
provide let addUint64 = (value, buffer) => {
  autogrow(_64BIT_LEN, buffer)
  let index = buffer.len
  buffer.len += _64BIT_LEN
  setUint64(index, value, buffer)
}

/**
 * Gets a 64-bit float starting at the given byte index.
 *
 * @param index: The byte index to access
 * @param buffer: The buffer to access
 * @returns A 64-bit float that starts at the given index
 *
 * @throws IndexOutOfBounds: When `index` is negative
 * @throws IndexOutOfBounds: When `index` is greater than or equal to the buffer size
 * @throws IndexOutOfBounds: When `index + 8` is greater than the buffer size
 *
 * @since v0.4.0
 */
provide let getFloat64 = (index, buffer) => {
  checkIsIndexInBounds(index, _64BIT_LEN, buffer)
  Bytes.getFloat64(index, buffer.data)
}

/**
 * Sets a 64-bit float starting at the given byte index.
 *
 * @param index: The byte index to update
 * @param value: The value to set
 * @param buffer: The buffer to mutate
 *
 * @throws IndexOutOfBounds: When `index` is negative
 * @throws IndexOutOfBounds: When `index` is greater than or equal to the buffer size
 * @throws IndexOutOfBounds: When `index + 8` is greater than the buffer size
 *
 * @since v0.4.0
 */
provide let setFloat64 = (index, value, buffer) => {
  checkIsIndexInBounds(index, _64BIT_LEN, buffer)
  Bytes.setFloat64(index, value, buffer.data)
}

/**
 * Appends a 64-bit float to a buffer.
 *
 * @param value: The value to append
 * @param buffer: The buffer to mutate
 *
 * @since v0.4.0
 */
provide let addFloat64 = (value, buffer) => {
  autogrow(_64BIT_LEN, buffer)
  let index = buffer.len
  buffer.len += _64BIT_LEN
  setFloat64(index, value, buffer)
}
