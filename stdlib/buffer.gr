/**
 * @module Buffer: Utilities for working with buffers.
 *
 * Buffers are data structures that automatically expand as more data is appended. They are useful for storing and operating on an unknown number of bytes. All set or append operations mutate the buffer.
 * @example import Buffer from "buffer"
 *
 * @since v0.4.0
 */

import Memory from "runtime/unsafe/memory"
import WasmI32 from "runtime/unsafe/wasmi32"
import Conv from "runtime/unsafe/conv"
import Exception from "runtime/exception"
import Int32 from "int32"
import Bytes from "bytes"
import String from "string"
import Char from "char"
import { coerceNumberToWasmI32 } from "runtime/numbers"

record Buffer {
  mut len: Number,
  initialSize: Number,
  mut data: Bytes,
}

@unsafe
let mut _SIZE_OFFSET = 4n

@unsafe
let mut _VALUE_OFFSET = 8n

let _8BIT_LEN = 1

let _16BIT_LEN = 2

let _32BIT_LEN = 4

let _64BIT_LEN = 8

/* Gets the size of a Bytes via its ptr */
@unsafe
let getSize = ptr => WasmI32.load(ptr, _SIZE_OFFSET)

/* Doubles the size of buffer's underlying byte sequence, if the given size is larger than the size of a buffer's underlying byte sequence */
let autogrow = (len, buf) => {
  let requiredMinimumSize = buf.len + len
  let currentSize = Bytes.length(buf.data)

  if (requiredMinimumSize > currentSize) {
    let mut newSize = if (currentSize > 0) {
      currentSize
    } else {
      // Make sure bytes of 0 length grow too
      4
    }

    while (newSize < requiredMinimumSize) {
      newSize *= 2
    }

    let growBy = newSize - currentSize

    buf.data = Bytes.resize(0, growBy, buf.data)
  }
}

/* Memcopies bytes from a source byte sequence to a destination byte sequence via pointers */
@unsafe
let rec appendBytes = (srcOff, dstOff, len, src, dst) => {
  let (+) = WasmI32.add
  Memory.copy(dst + _VALUE_OFFSET + dstOff, src + _VALUE_OFFSET + srcOff, len)
}

/*
 * If given index is negative, returns a positive index.
 * Throws if a given index + len is not within the bounds of a buffer's current length
 */
let checkIsIndexInBounds = (i, len, buf) => {
  if (i < 0) throw Exception.IndexOutOfBounds
  if (i >= buf.len || i + len > buf.len) throw Exception.IndexOutOfBounds
}

let addInt8help = (value, buffer) => {
  autogrow(_8BIT_LEN, buffer)
  let index = buffer.len
  buffer.len += _8BIT_LEN
  Bytes.setInt8(index, value, buffer.data)
}

let addInt16help = (value, buffer) => {
  autogrow(_16BIT_LEN, buffer)
  let index = buffer.len
  buffer.len += _16BIT_LEN
  Bytes.setInt16(index, value, buffer.data)
}

let addInt32help = (value, buffer) => {
  autogrow(_32BIT_LEN, buffer)
  let index = buffer.len
  buffer.len += _32BIT_LEN
  Bytes.setInt32(index, value, buffer.data)
}

/**
 * @section Values: Functions for working with the Buffer data type.
 */

/**
 * Creates a fresh buffer, initially empty.
 *
 * The `initialSize` parameter is the initial size of the internal byte sequence that holds the buffer contents.
 * That byte sequence is automatically reallocated when more than `initialSize` bytes are stored in the buffer, but shrinks back to `initialSize` characters when reset is called.
 *
 * @param initialSize: The initial size of the buffer
 * @returns The new buffer
 *
 * @since v0.4.0
 */
export let make = initialSize => {
  if (initialSize < 0)
    throw Exception.InvalidArgument("Buffers size must be >= 0")
  { len: 0, initialSize, data: Bytes.make(initialSize) }
}

/**
 * Gets the number of bytes currently contained in a buffer.
 *
 * @param buffer: The buffer to access
 * @returns The length of the buffer in bytes
 *
 * @since v0.4.0
 */
export let length = buffer => buffer.len

/**
 * Clears data in the buffer and sets its length to zero.
 *
 * This operation does not resize the underlying byte sequence.
 *
 * @param buffer: The buffer to clear
 *
 * @since v0.4.0
 */
export let clear = buffer => {
  Bytes.clear(buffer.data)
  buffer.len = 0
}

/**
 * Empty a buffer and deallocate the internal byte sequence holding the buffer contents.
 *
 * This operation resizes the underlying byte sequence to the initial size of the buffer.
 *
 * @param buffer: The buffer to reset
 *
 * @since v0.4.0
 */
export let reset = buffer => {
  buffer.data = Bytes.make(buffer.initialSize)
  buffer.len = 0
}

/**
 * Shortens a buffer to the given length.
 *
 * This operation does not resize the underlying byte sequence.
 *
 * @param length: The number of bytes to truncate the buffer to
 * @param buffer: The buffer to truncate
 *
 * @since v0.4.0
 */
@unsafe
export let truncate = (length, buffer) => {
  if (length < 0 || length > buffer.len) throw Exception.IndexOutOfBounds

  let (+) = WasmI32.add
  let src = WasmI32.fromGrain(buffer.data)
  let size = getSize(src)
  let off = coerceNumberToWasmI32(length)
  let ret = Memory.fill(src + _VALUE_OFFSET + off, 0n, size)
  buffer.len = length
}

/**
 * Returns a copy of the current contents of the buffer as a byte sequence.
 *
 * @param buffer: The buffer to copy into a byte sequence
 * @returns A byte sequence made from copied buffer data
 *
 * @since v0.4.0
 */
export let toBytes = buffer => {
  Bytes.slice(0, buffer.len, buffer.data)
}

/**
 * Returns a slice of the current contents of the buffer as a byte sequence.
 *
 * @param start: The start index
 * @param length: The number of bytes to include after the starting index
 * @param buffer: The buffer to copy from
 * @returns A byte sequence with bytes copied from the buffer
 *
 * @since v0.4.0
 */
export let toBytesSlice = (start, length, buffer) => {
  checkIsIndexInBounds(start, length, buffer)
  Bytes.slice(start, length, buffer.data)
}

/**
 * Returns a copy of the current contents of the buffer as a string.
 *
 * @param buffer: The buffer to stringify
 * @returns A string made with data copied from the buffer
 *
 * @since v0.4.0
 */
export let toString = buffer => {
  Bytes.toString(toBytes(buffer))
}

/**
 * Returns a copy of a subset of the current contents of the buffer as a string.
 *
 * @param start: The start index
 * @param length: The number of bytes to include after the starting index
 * @param buffer: The buffer to copy from
 * @returns A string made with a subset of data copied from the buffer
 *
 * @since v0.4.0
 */
export let toStringSlice = (start, length, buffer) => {
  Bytes.toString(toBytesSlice(start, length, buffer))
}

/**
 * Appends a byte sequence to a buffer.
 *
 * @param bytes: The byte sequence to append
 * @param buffer: The buffer to mutate
 *
 * @since v0.4.0
 */
@unsafe
export let addBytes = (bytes, buffer) => {
  let bytelen = Bytes.length(bytes)

  autogrow(bytelen, buffer)

  let off = coerceNumberToWasmI32(buffer.len)
  let len = getSize(WasmI32.fromGrain(bytes))
  let src = WasmI32.fromGrain(bytes)
  let dst = WasmI32.fromGrain(buffer.data)
  appendBytes(0n, off, len, src, dst)

  buffer.len += bytelen
}

/**
 * Appends the bytes of a string to a buffer.
 *
 * @param string: The string to append
 * @param buffer: The buffer to mutate
 *
 * @since v0.4.0
 */
@unsafe
export let addString = (string, buffer) => {
  let bytelen = String.byteLength(string)

  autogrow(bytelen, buffer)

  let off = coerceNumberToWasmI32(buffer.len)
  let len = getSize(WasmI32.fromGrain(string))
  let src = WasmI32.fromGrain(string)
  let dst = WasmI32.fromGrain(buffer.data)
  appendBytes(0n, off, len, src, dst)

  buffer.len += bytelen
}

/**
 * Appends the bytes of a char to a buffer.
 *
 * @param char: The character to append to the buffer
 * @param buffer: The buffer to mutate
 *
 * @since v0.4.0
 */
export let addChar = (char, buffer) => {
  addString(Char.toString(char), buffer)
}

/**
 * Appends the bytes of a subset of a string to a buffer.
 *
 * @param start: The char offset into the string
 * @param end: The end offset into the string
 * @param string: The string to append
 * @param buffer: The buffer to mutate
 *
 * @since v0.4.0
 * @history v0.5.0: Now takes the end offset instead of length
 */
@unsafe
export let addStringSlice = (start: Number, end, string, buffer) => {
  let slice = String.slice(start, end, string)

  let bytelen = String.byteLength(slice)

  autogrow(bytelen, buffer)

  let srcOff = 0n
  let dstOff = coerceNumberToWasmI32(buffer.len)
  let src = WasmI32.fromGrain(slice)
  let dst = WasmI32.fromGrain(buffer.data)
  appendBytes(srcOff, dstOff, coerceNumberToWasmI32(bytelen), src, dst)

  buffer.len += bytelen
}

/**
 * Appends the bytes of a subset of a byte sequence to a buffer.
 *
 * @param start: The byte offset into the byte sequence
 * @param length: The number of bytes to append
 * @param bytes: The byte sequence to append
 * @param buffer: The buffer to mutate
 *
 * @since v0.4.0
 */
@unsafe
export let addBytesSlice =
  (
    start: Number,
    length: Number,
    bytes: Bytes,
    buffer: Buffer,
  ) => {
  let (-) = WasmI32.sub
  let (<) = WasmI32.ltS
  let (>) = WasmI32.gtS
  let (>=) = WasmI32.geS

  // bounds check start
  let bytelen = WasmI32.load(WasmI32.fromGrain(bytes), 4n)
  let srcOff = coerceNumberToWasmI32(start)
  if (srcOff < 0n || srcOff >= bytelen) {
    throw Exception.IndexOutOfBounds
  }

  // bounds check length
  let len = coerceNumberToWasmI32(length)
  if (len < 0n || len > bytelen - srcOff) {
    throw Exception.IndexOutOfBounds
  }

  autogrow(length, buffer)

  let dstOff = coerceNumberToWasmI32(buffer.len)
  let src = WasmI32.fromGrain(bytes)
  let dst = WasmI32.fromGrain(buffer.data)
  appendBytes(srcOff, dstOff, len, src, dst)

  buffer.len += length
}

/**
 * Appends the bytes of a source buffer to destination buffer.
 *
 * The source buffer is not mutated by this operation. The destination buffer, however, is mutated.
 *
 * @param srcBuffer: The buffer to append
 * @param dstBuffer: The buffer to mutate
 *
 * @since v0.4.0
 */
export let addBuffer = (srcBuffer, dstBuffer) => {
  addBytesSlice(0, srcBuffer.len, srcBuffer.data, dstBuffer)
}

/**
 * Appends the bytes of a part of a buffer to the end of the buffer
 *
 * The source buffer is not mutated by this operation. The destination buffer, however, is mutated.
 *
 * @param start: The byte offset into the buffer
 * @param length: The number of bytes to append
 * @param srcBuffer: The buffer to append
 * @param dstBuffer: The buffer to mutate
 *
 * @since v0.4.0
 */
export let addBufferSlice = (start, length, srcBuffer, dstBuffer) => {
  addBytesSlice(start, length, srcBuffer.data, dstBuffer)
}

/**
 * @section Binary operations on integers: Functions for encoding and decoding integers stored in a buffer.
 */

/**
 * Gets a signed 8-bit integer starting at the given byte index.
 *
 * @param index: The byte index to access
 * @param buffer: The buffer to access
 * @returns A 32-bit integer representing a signed 8-bit integer that starts at the given index
 *
 * @since v0.4.0
 */
export let getInt8S = (index, buffer) => {
  checkIsIndexInBounds(index, _8BIT_LEN, buffer)
  Bytes.getInt8S(index, buffer.data)
}

/**
 * Gets an unsigned 8-bit integer starting at the given byte index.
 *
 * @param index: The byte index to access
 * @param buffer: The buffer to access
 * @returns A 32-bit integer representing an unsigned 8-bit integer that starts at the given index
 *
 * @since v0.4.0
 */
export let getInt8U = (index, buffer) => {
  checkIsIndexInBounds(index, _8BIT_LEN, buffer)
  Bytes.getInt8U(index, buffer.data)
}

/**
 * Sets a signed 8-bit integer starting at the given byte index.
 *
 * @param index: The byte index to update
 * @param value: The value to set
 * @param buffer: The buffer to mutate
 *
 * @since v0.4.0
 */
export let setInt8 = (index, value, buffer) => {
  checkIsIndexInBounds(index, _8BIT_LEN, buffer)
  Bytes.setInt8(index, value, buffer.data)
}

/**
 * Appends a signed 8-bit integer to a buffer.
 *
 * @param value: The value to append
 * @param buffer: The buffer to mutate
 *
 * @since v0.4.0
 */
export let addInt8 = (value, buffer) => {
  addInt8help(value, buffer)
}

/**
 * Gets a signed 16-bit integer starting at the given byte index.
 *
 * @param index: The byte index to access
 * @param buffer: The buffer to access
 * @returns A 32-bit integer representing a signed 16-bit integer that starts at the given index
 *
 * @since v0.4.0
 */
export let getInt16S = (index, buffer) => {
  checkIsIndexInBounds(index, _16BIT_LEN, buffer)
  Bytes.getInt16S(index, buffer.data)
}

/**
 * Gets an unsigned 16-bit integer starting at the given byte index.
 *
 * @param index: The byte index to access
 * @param buffer: The buffer to access
 * @returns A 32-bit integer representing an unsigned 16-bit integer that starts at the given index
 *
 * @since v0.4.0
 */
export let getInt16U = (index, buffer) => {
  checkIsIndexInBounds(index, _16BIT_LEN, buffer)
  Bytes.getInt16U(index, buffer.data)
}

/**
 * Sets a signed 16-bit integer starting at the given byte index.
 *
 * @param index: The byte index to update
 * @param value: The value to set
 * @param buffer: The buffer to mutate
 *
 * @since v0.4.0
 */
export let setInt16 = (index, value, buffer) => {
  checkIsIndexInBounds(index, _16BIT_LEN, buffer)
  Bytes.setInt16(index, value, buffer.data)
}

/**
 * Appends a signed 16-bit integer to a buffer.
 *
 * @param value: The value to append
 * @param buffer: The buffer to mutate
 *
 * @since v0.4.0
 */
export let addInt16 = (value, buffer) => {
  addInt16help(value, buffer)
}

/**
 * Gets a signed 32-bit integer starting at the given byte index.
 *
 * @param index: The byte index to access
 * @param buffer: The buffer to access
 * @returns A signed 32-bit integer that starts at the given index
 *
 * @since v0.4.0
 */
export let getInt32 = (index, buffer) => {
  checkIsIndexInBounds(index, _32BIT_LEN, buffer)
  Bytes.getInt32(index, buffer.data)
}

/**
 * Sets a signed 32-bit integer starting at the given byte index.
 *
 * @param index: The byte index to update
 * @param value: The value to set
 * @param buffer: The buffer to mutate
 *
 * @since v0.4.0
 */
export let setInt32 = (index, value, buffer) => {
  checkIsIndexInBounds(index, _32BIT_LEN, buffer)
  Bytes.setInt32(index, value, buffer.data)
}

/**
 * Appends a signed 32-bit integer to a buffer.
 *
 * @param value: The value to append
 * @param buffer: The buffer to mutate
 *
 * @since v0.4.0
 */
export let addInt32 = (value, buffer) => {
  addInt32help(value, buffer)
}

/**
 * Gets a 32-bit float starting at the given byte index.
 *
 * @param index: The byte index to access
 * @param buffer: The buffer to access
 * @returns A 32-bit float that starts at the given index
 *
 * @since v0.4.0
 */
export let getFloat32 = (index, buffer) => {
  checkIsIndexInBounds(index, _32BIT_LEN, buffer)
  Bytes.getFloat32(index, buffer.data)
}

/**
 * Sets a 32-bit float starting at the given byte index.
 *
 * @param index: The byte index to update
 * @param value: The value to set
 * @param buffer: The buffer to mutate
 *
 * @since v0.4.0
 */
export let setFloat32 = (index, value, buffer) => {
  checkIsIndexInBounds(index, _32BIT_LEN, buffer)
  Bytes.setFloat32(index, value, buffer.data)
}

/**
 * Appends a 32-bit float to a buffer.
 *
 * @param value: The value to append
 * @param buffer: The buffer to mutate
 *
 * @since v0.4.0
 */
export let addFloat32 = (value, buffer) => {
  autogrow(_32BIT_LEN, buffer)
  let index = buffer.len
  buffer.len += _32BIT_LEN
  setFloat32(index, value, buffer)
}

/**
 * Gets a signed 64-bit integer starting at the given byte index.
 *
 * @param index: The byte index to access
 * @param buffer: The buffer to access
 * @returns A signed 64-bit integer that starts at the given index
 *
 * @since v0.4.0
 */
export let getInt64 = (index, buffer) => {
  checkIsIndexInBounds(index, _64BIT_LEN, buffer)
  Bytes.getInt64(index, buffer.data)
}

/**
 * Sets a signed 64-bit integer starting at the given byte index.
 *
 * @param index: The byte index to update
 * @param value: The value to set
 * @param buffer: The buffer to mutate
 *
 * @since v0.4.0
 */
export let setInt64 = (index, value, buffer) => {
  checkIsIndexInBounds(index, _64BIT_LEN, buffer)
  Bytes.setInt64(index, value, buffer.data)
}

/**
 * Appends a signed 64-bit integer to a buffer.
 *
 * @param value: The value to set
 * @param buffer: The buffer to mutate
 *
 * @since v0.4.0
 */
export let addInt64 = (value, buffer) => {
  autogrow(_64BIT_LEN, buffer)
  let index = buffer.len
  buffer.len += _64BIT_LEN
  setInt64(index, value, buffer)
}

/**
 * Gets a 64-bit float starting at the given byte index.
 *
 * @param index: The byte index to access
 * @param buffer: The buffer to access
 * @returns A 64-bit float that starts at the given index
 *
 * @since v0.4.0
 */
export let getFloat64 = (index, buffer) => {
  checkIsIndexInBounds(index, _64BIT_LEN, buffer)
  Bytes.getFloat64(index, buffer.data)
}

/**
 * Sets a 64-bit float starting at the given byte index.
 *
 * @param index: The byte index to update
 * @param value: The value to set
 * @param buffer: The buffer to mutate
 *
 * @since v0.4.0
 */
export let setFloat64 = (index, value, buffer) => {
  checkIsIndexInBounds(index, _64BIT_LEN, buffer)
  Bytes.setFloat64(index, value, buffer.data)
}

/**
 * Appends a 64-bit float to a buffer.
 *
 * @param value: The value to append
 * @param buffer: The buffer to mutate
 *
 * @since v0.4.0
 */
export let addFloat64 = (value, buffer) => {
  autogrow(_64BIT_LEN, buffer)
  let index = buffer.len
  buffer.len += _64BIT_LEN
  setFloat64(index, value, buffer)
}
