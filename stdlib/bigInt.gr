/**
 * Arbitary-precision integers.
 */
import WasmI32 from "runtime/unsafe/wasmi32"
import Memory from "runtime/unsafe/memory"
import BI from "runtime/bigInt"
import DS from "runtime/dataStructures"

import {
  coerceNumberToBigInt as fromNumber,
  coerceBigIntToNumber as toNumber,
} from "runtime/numbers"

export fromNumber
export toNumber

@unsafe
export let eq = (num1: BigInt, num2: BigInt) => {
  let num1 = WasmI32.fromGrain(num1)
  let num2 = WasmI32.fromGrain(num2)
  BI.eq(num1, num2)
}

@unsafe
export let ne = (num1: BigInt, num2: BigInt) => {
  let num1 = WasmI32.fromGrain(num1)
  let num2 = WasmI32.fromGrain(num2)
  BI.ne(num1, num2)
}

@unsafe
export let lt = (num1: BigInt, num2: BigInt) => {
  let num1 = WasmI32.fromGrain(num1)
  let num2 = WasmI32.fromGrain(num2)
  BI.lt(num1, num2)
}

@unsafe
export let lte = (num1: BigInt, num2: BigInt) => {
  let num1 = WasmI32.fromGrain(num1)
  let num2 = WasmI32.fromGrain(num2)
  BI.lte(num1, num2)
}

@unsafe
export let gt = (num1: BigInt, num2: BigInt) => {
  let num1 = WasmI32.fromGrain(num1)
  let num2 = WasmI32.fromGrain(num2)
  BI.gt(num1, num2)
}

@unsafe
export let gte = (num1: BigInt, num2: BigInt) => {
  let num1 = WasmI32.fromGrain(num1)
  let num2 = WasmI32.fromGrain(num2)
  BI.gte(num1, num2)
}

@unsafe
export let add = (num1: BigInt, num2: BigInt) => {
  WasmI32.toGrain(BI.add(WasmI32.fromGrain(num1), WasmI32.fromGrain(num2)))
}

@unsafe
export let sub = (num1: BigInt, num2: BigInt) => {
  WasmI32.toGrain(BI.sub(WasmI32.fromGrain(num1), WasmI32.fromGrain(num2)))
}

@unsafe
export let incr = (num: BigInt) => {
  WasmI32.toGrain(BI.incr(WasmI32.fromGrain(num)))
}

@unsafe
export let decr = (num: BigInt) => {
  WasmI32.toGrain(BI.decr(WasmI32.fromGrain(num)))
}

@unsafe
export let mul = (num1: BigInt, num2: BigInt) => {
  WasmI32.toGrain(BI.mul(WasmI32.fromGrain(num1), WasmI32.fromGrain(num2)))
}

@unsafe
export let shl = (num: BigInt, places: Int32) => {
  let num = WasmI32.fromGrain(num)
  let places = WasmI32.load(WasmI32.fromGrain(places), 8n)
  WasmI32.toGrain(BI.shl(num, places)): BigInt
}

@unsafe
export let shrS = (num: BigInt, places: Int32) => {
  let num = WasmI32.fromGrain(num)
  let places = WasmI32.load(WasmI32.fromGrain(places), 8n)
  WasmI32.toGrain(BI.shrS(num, places)): BigInt
}

@unsafe
export let lnot = (num: BigInt) => {
  WasmI32.toGrain(BI.bitwiseNot(WasmI32.fromGrain(num)))
}

@unsafe
export let land = (num1: BigInt, num2: BigInt) => {
  WasmI32.toGrain(
    BI.bitwiseAnd(WasmI32.fromGrain(num1), WasmI32.fromGrain(num2))
  )
}

@unsafe
export let lor = (num1: BigInt, num2: BigInt) => {
  WasmI32.toGrain(
    BI.bitwiseOr(WasmI32.fromGrain(num1), WasmI32.fromGrain(num2))
  )
}

@unsafe
export let lxor = (num1: BigInt, num2: BigInt) => {
  WasmI32.toGrain(
    BI.bitwiseXor(WasmI32.fromGrain(num1), WasmI32.fromGrain(num2))
  )
}

@unsafe
export let gcd = (num1: BigInt, num2: BigInt) => {
  WasmI32.toGrain(BI.gcd(WasmI32.fromGrain(num1), WasmI32.fromGrain(num2)))
}

@unsafe
export let quotRem = (num1: BigInt, num2: BigInt) => {
  let dest = Memory.malloc(8n)
  BI.quotRem(WasmI32.fromGrain(num1), WasmI32.fromGrain(num2), dest)
  let q = WasmI32.toGrain(WasmI32.load(dest, 0n)): BigInt
  let r = WasmI32.toGrain(WasmI32.load(dest, 4n)): BigInt
  Memory.free(dest)
  (q, r)
}

@unsafe
export let divMod = (num1: BigInt, num2: BigInt) => {
  let dest = Memory.malloc(8n)
  BI.divMod(WasmI32.fromGrain(num1), WasmI32.fromGrain(num2), dest)
  let q = WasmI32.toGrain(WasmI32.load(dest, 0n)): BigInt
  let r = WasmI32.toGrain(WasmI32.load(dest, 4n)): BigInt
  Memory.free(dest)
  (q, r)
}

@unsafe
export let quot = (num1: BigInt, num2: BigInt) => {
  WasmI32.toGrain(
    BI.quot(WasmI32.fromGrain(num1), WasmI32.fromGrain(num2))
  ): BigInt
}

@unsafe
export let div = (num1: BigInt, num2: BigInt) => {
  WasmI32.toGrain(
    BI.div(WasmI32.fromGrain(num1), WasmI32.fromGrain(num2))
  ): BigInt
}

@unsafe
export let mod = (num1: BigInt, num2: BigInt) => {
  WasmI32.toGrain(
    BI.mod(WasmI32.fromGrain(num1), WasmI32.fromGrain(num2))
  ): BigInt
}

@unsafe
export let rem = (num1: BigInt, num2: BigInt) => {
  WasmI32.toGrain(
    BI.rem(WasmI32.fromGrain(num1), WasmI32.fromGrain(num2))
  ): BigInt
}

@unsafe
export let negate = (num: BigInt) => {
  WasmI32.toGrain(BI.negate(WasmI32.fromGrain(num))): BigInt
}

@unsafe
export let abs = (num: BigInt) => {
  WasmI32.toGrain(BI.abs(WasmI32.fromGrain(num))): BigInt
}

@unsafe
export let toString = (num: BigInt) => {
  BI.bigIntToString10(WasmI32.fromGrain(num))
}

@unsafe
export let countLeadingZeros = (num: BigInt) => {
  WasmI32.toGrain(
    DS.newInt32(BI.countLeadingZeros(WasmI32.fromGrain(num)))
  ): Int32
}

@unsafe
export let countTrailingZeros = (num: BigInt) => {
  WasmI32.toGrain(
    DS.newInt64(BI.countTrailingZeros(WasmI32.fromGrain(num)))
  ): Int64
}

@unsafe
export let popcnt = (num: BigInt) => {
  WasmI32.toGrain(DS.newInt64(BI.popcnt(WasmI32.fromGrain(num)))): Int64
}
