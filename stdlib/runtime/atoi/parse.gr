@noPervasives
module Parse

from "runtime/unsafe/wasmi32" include WasmI32
use WasmI32.{
  (+),
  (-),
  gtU as (>),
  geU as (>=),
  ltU as (<),
  (>>),
  (==),
  (!=),
  (&),
}
from "runtime/unsafe/wasmi64" include WasmI64
from "runtime/unsafe/wasmref" include WasmRef
from "runtime/unsafe/memory" include Memory
from "runtime/unsafe/tags" include Tags
from "runtime/bigint" include Bigint as BI
from "runtime/dataStructures" include DataStructures
from "runtime/numbers" include Numbers
use Numbers.{ reducedInteger }

primitive (!) = "@not"

/**
 * Represents an error that occurred trying to parse an integer.
 *
 * @since v0.6.0
 */
provide enum ParseIntError {
  /**
   * Represents an error caused by trying to parse an empty string.
   */
  ParseIntEmptyString,
  /**
   * Represents an error caused by trying to parse a string with an invalid character.
   */
  ParseIntInvalidDigit,
  /**
   * Represents an error caused by trying to parse with an invalid radix.
   */
  ParseIntInvalidRadix,
}

primitive (&&) = "@and"
primitive (||) = "@or"

@unsafe
provide let parseInt = (string: String, radix: Number) => {
  use WasmI64.{ (+) as addWasmI64 }
  let _CHAR_0 = 0x30n
  let _CHAR_B = 0x42n
  let _CHAR_b = 0x62n
  let _CHAR_O = 0x4fn
  let _CHAR_o = 0x6fn
  let _CHAR_X = 0x58n
  let _CHAR_x = 0x78n

  let _CHAR_A = 0x41n
  let _CHAR_a = 0x61n

  let _CHAR_UNDERSCORE = 0x5fn
  let _CHAR_MINUS = 0x2dn

  let _INT_MIN = -9223372036854775808N

  let string = WasmRef.fromGrain(string)

  // Don't need to process Unicode length since if the string
  // contains non-ascii characters, it's not a valid integer
  let strLen = DataStructures.stringSize(string)

  let strPtr = DataStructures.getStringArrayRef(string)

  // Our offset within the string we're parsing
  let mut offset = 0n

  if (
    WasmRef.isGrainHeapValue(WasmRef.fromGrain(radix))
    || DataStructures.untagSimpleNumber(radix) < 2n
    || DataStructures.untagSimpleNumber(radix) > 36n
  ) {
    return Err(ParseIntInvalidRadix)
  }

  if (WasmI32.eqz(strLen)) {
    return Err(ParseIntEmptyString)
  }

  let mut char = WasmRef.arrayI8GetU(strPtr, 0n)

  let mut limit = addWasmI64(_INT_MIN, 1N)

  // Check for a sign
  let mut negative = false
  if (char == _CHAR_MINUS) {
    negative = true
    offset += 1n
    limit = _INT_MIN
    char = WasmRef.arrayI8GetU(strPtr, offset)
  }

  let mut radix = WasmI64.extendI32U(DataStructures.untagSimpleNumber(radix))

  // Check if we should override the supplied radix
  if (char == _CHAR_0 && strLen > 2n) {
    match (WasmRef.arrayI8GetU(strPtr, offset + 1n)) {
      c when c == _CHAR_B || c == _CHAR_b => {
        radix = 2N
        offset += 2n
      },
      c when c == _CHAR_O || c == _CHAR_o => {
        radix = 8N
        offset += 2n
      },
      c when c == _CHAR_X || c == _CHAR_x => {
        radix = 16N
        offset += 2n
      },
      _ => void,
    }
  }

  let mut value = 0N
  let mut radixBigInt = WasmRef.fromGrain(0t)
  let mut valueBigInt = WasmRef.fromGrain(0t)
  let mut isBigInt = false
  let mut sawDigit = false

  for (let mut i = offset; i < strLen; i += 1n) {
    let char = WasmRef.arrayI8GetU(strPtr, i)

    // Ignore underscore characters
    if (char == _CHAR_UNDERSCORE) {
      continue
    }

    sawDigit = true

    let mut digit = 0n

    match (char) {
      c when c - _CHAR_0 < 10n => digit = char - _CHAR_0,
      c when c - _CHAR_A < 26n => digit = char - _CHAR_A + 10n,
      c when c - _CHAR_a < 26n => digit = char - _CHAR_a + 10n,
      _ => {
        return Err(ParseIntInvalidDigit)
      },
    }

    if (digit >= WasmI32.wrapI64(radix)) {
      return Err(ParseIntInvalidDigit)
    }

    let digit = WasmI64.extendI32U(digit)

    if (!isBigInt) {
      use WasmI64.{ (+) }
      use WasmI64.{ (*), (<) }
      let prevValue = value
      value *= radix
      // Check for overflow
      // 64-bit int min + 1
      if (value < limit + digit) {
        // we overflowed. allocate BigInt and use instead
        isBigInt = true
        valueBigInt = BI.makeWrappedUint64(prevValue * -1N)
        radixBigInt = BI.makeWrappedUint64(radix)
        let newvalue = BI.mul(valueBigInt, radixBigInt)
        let newvalue = BI.addInt(newvalue, digit)
        valueBigInt = newvalue
      } else {
        use WasmI64.{ (-) }
        // To quote the OpenJDK,
        // "Accumulating negatively avoids surprises near MAX_VALUE"
        // The minimum value of a 64-bit integer (-9223372036854775808) can't be
        // represented as a positive number because it would be larger than the
        // maximum 64-bit integer (9223372036854775807), so we'd be unable to
        // parse negatives as positives and multiply by the sign at the end.
        // Instead, we represent all positive numbers as negative numbers since
        // we have one unit more headroom.
        value -= digit
      }
    } else {
      let newvalue = BI.mul(valueBigInt, radixBigInt)
      let newvalue = BI.addInt(newvalue, digit)
      valueBigInt = newvalue
    }
  }
  use WasmI64.{ (*) }
  // TODO: Verify this is suitable for handling "_"
  if (!sawDigit) return Err(ParseIntInvalidDigit)

  if (!isBigInt) {
    let value = if (negative) value else value * -1N
    let number = WasmRef.toGrain(reducedInteger(value)): Number
    return Ok(number)
  }

  // BigInt number is accumulated in positive form
  if (negative) {
    let newvalue = BI.negate(valueBigInt)
    return Ok(WasmRef.toGrain(newvalue))
  }

  return Ok(WasmRef.toGrain(valueBigInt))
}
