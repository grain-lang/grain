import WasmI32 from "runtime/unsafe/wasmi32"
import Conv from "runtime/unsafe/conv"
import Memory from "runtime/unsafe/memory"
import GC from "runtime/gc"
import { coerceNumberToWasmI32 } from "runtime/numbers"
import { allocateString } from "runtime/dataStructures"
import NumberUtils from "runtime/numberUtils"
import Map from "map"
import Set from "set"
import Option from "option"
import Tags from "runtime/unsafe/tags"

@disableGC
let rec toHex = (n: Number) => {
  let x = coerceNumberToWasmI32(n)
  let result = NumberUtils.itoa32(x, 16n)

  Memory.decRef(WasmI32.fromGrain(n))
  Memory.decRef(WasmI32.fromGrain(toHex))

  result
}

export enum LeakDebugSummaryMode {
  AlwaysPrintSummary,
  PrintSummaryIfLeaksAreFound,
}

export record LeakDebugBlockOptions {
  printIncrefsAndDecRefs: Bool,
  printMallocAndFree: Bool,
  printObjectContents: Bool,
  summary: LeakDebugSummaryMode,
}

let incrementCountInMap = (key: k, map: Map.Map<k, Number>) => {
  match (Map.get(key, map)) {
    Some(cnt) => Map.set(key, cnt + 1, map),
    None => Map.set(key, 1, map),
  }
}

let keyUnionOfTwoMaps = (map1: Map.Map<k, v1>, map2: Map.Map<k, v2>) => {
  let keyUnion = Set.make(): (Set.Set<k>)

  Map.forEach(
    (k, v) => {
      Set.add(k, keyUnion)
    },
    map1,
  )

  Map.forEach(
    (k, v) => {
      Set.add(k, keyUnion)
    },
    map2,
  )

  keyUnion
}

@disableGC
let rec readTag = (userPtrAsNumber: Number) => {
  Memory.incRef(WasmI32.fromGrain(coerceNumberToWasmI32))
  Memory.incRef(WasmI32.fromGrain(userPtrAsNumber))
  let userPtr = coerceNumberToWasmI32(userPtrAsNumber)

  let tag = WasmI32.load(userPtr, 0n)
  Memory.incRef(WasmI32.fromGrain(Conv.wasmI32ToNumber))
  let tagAsNumber = Conv.wasmI32ToNumber(tag)

  Memory.decRef(WasmI32.fromGrain(userPtrAsNumber))
  Memory.decRef(WasmI32.fromGrain(readTag))

  tagAsNumber
}

@disableGC
let rec readRefCount = (userPtrAsNumber: Number) => {
  Memory.incRef(WasmI32.fromGrain(coerceNumberToWasmI32))
  Memory.incRef(WasmI32.fromGrain(userPtrAsNumber))
  let userPtr = coerceNumberToWasmI32(userPtrAsNumber)

  let _HEADER_SIZE = 8n
  let refCnt = WasmI32.load(WasmI32.sub(userPtr, _HEADER_SIZE), 0n)
  Memory.incRef(WasmI32.fromGrain(Conv.wasmI32ToNumber))
  let refCntAsNumber = Conv.wasmI32ToNumber(refCnt)

  Memory.decRef(WasmI32.fromGrain(userPtrAsNumber))
  Memory.decRef(WasmI32.fromGrain(readRefCount))

  refCntAsNumber
}

@disableGC
let rec readContentAsString = (userPtrAsNumber: Number) => {
  Memory.incRef(WasmI32.fromGrain(coerceNumberToWasmI32))
  Memory.incRef(WasmI32.fromGrain(userPtrAsNumber))
  let userPtr = coerceNumberToWasmI32(userPtrAsNumber)

  let _HEADER_SIZE = 8n
  let refCnt = WasmI32.load(WasmI32.sub(userPtr, _HEADER_SIZE), 0n)

  let tag = WasmI32.load(userPtr, 0n)

  let contentAsString = if (WasmI32.eq(tag, Tags._GRAIN_STRING_HEAP_TAG)) {
    // Special case for strings. We don't want to call toString because
    // it returns the same object. We want to keep the string contents
    // for printing without altering the refcount of the original string.
    // Se lets copy just it and while we're at it, add quotes to better
    // illustrate that the value is for a string.
    let originalSize = WasmI32.load(userPtr, 4n)
    let newSize = WasmI32.add(originalSize, 2n)
    let newString = allocateString(newSize)
    WasmI32.store8(newString, 0x22n, 8n)
    Memory.copy(
      WasmI32.add(newString, 9n),
      WasmI32.add(userPtr, 8n),
      originalSize,
    )
    WasmI32.store8(
      WasmI32.add(newString, WasmI32.add(originalSize, 1n)),
      0x22n,
      8n,
    )
    WasmI32.toGrain(newString): (String)
  } else if (WasmI32.eq(refCnt, 0n)) {
    // Special case when printing an object that has refCount of zero and
    // is going to be deallocated.
    // The ref count has already been decremented to zero, but is still in
    // memory so we can print it. For this to work, the refcount needs to be
    // incremented to 2 to avoid deallocating by decRef inside toString.
    Memory.incRef(WasmI32.fromGrain(userPtr))
    Memory.incRef(WasmI32.fromGrain(userPtr))
    Memory.incRef(WasmI32.fromGrain(toString))
    let s = toString(userPtr)
    // And then we can reset it to zero to avoid introducing issues.
    WasmI32.store(WasmI32.sub(userPtr, _HEADER_SIZE), 0n, 0n)
    s
  } else {
    // Otherwise just call toString with usual calling conventions.
    Memory.incRef(WasmI32.fromGrain(userPtr))
    Memory.incRef(WasmI32.fromGrain(toString))
    toString(userPtr)
  }

  Memory.decRef(WasmI32.fromGrain(userPtrAsNumber))
  Memory.decRef(WasmI32.fromGrain(readContentAsString))

  contentAsString
}

let tagToTypeName = (tag: Number) => {
  match (tag) {
    1 => "string",
    2 => "char",
    3 => "enum",
    4 => "record",
    5 => "array",
    6 => "number",
    7 => "lambda",
    8 => "tuple",
    9 => "bytes",
    _ => "unknown",
  }
}

let leakDebugBlockImpl = (options: LeakDebugBlockOptions, f: () -> Void) => {
  // The main objective is to find and print objects allocated
  // in the function, but not deallocated at the end.

  let allocations = Set.make(): (Set.Set<Number>)

  let mut totalMallocs = 0
  let mut totalFrees = 0
  let mut totalIncRefs = 0
  let mut totalDecRefs = 0

  let mut totalPreexistingObjectsDeallocated = 0

  let incRefsByTag = Map.make(): (Map.Map<Number, Number>)
  let decRefsByTag = Map.make(): (Map.Map<Number, Number>)

  let inintialRefCountsOnPreExistingObjects = Map.make(): (Map.Map<Number, Number>)
  let incRefsOnPreExistingObjects = Map.make(): (Map.Map<Number, Number>)
  let decRefsOnPreExistingObjects = Map.make(): (Map.Map<Number, Number>)

  // In order to correctly present the summary of incRefs/decRefs by tag, it's
  // not enough to just track incRefs/decRefs themselves because incRef doesn't
  // get called for newly allocated objects. They start with ref. count of 1
  // set directly by GC.malloc. So we want to include the allocated objects in
  // the summary, but it isn't as simple as adding some code in the hook for
  // GC.malloc because freshly allocated objects don't have a tag yet. The tag
  // is normally set later like in dataStructures.allocateString and similar
  // functions. So what we actually do is track the lifetime of individual
  // objects in the "allocations" map. Only when an object is freed we read its
  // tag and increment the corresponding count in the mallocPlusFreeByTag map.
  // If an object is not freed then it's left in the allocations map. So we
  // group these leaked objects by tag as well and present the totals in the
  // summary as "malloc without free".
  let mallocPlusFreeByTag = Map.make(): (Map.Map<Number, Number>)

  let maybeObjectContentsAppendix = if (options.printObjectContents) {
    (userPtrAsNumber: Number) => {
      ": " ++ readContentAsString(userPtrAsNumber)
    }
  } else {
    (userPtrAsNumber: Number) => {
      ""
    }
  }

  let onIncRef = (userPtr: Number) => {
    totalIncRefs += 1

    let oldRefCount = readRefCount(userPtr)
    let newRefCount = oldRefCount + 1
    let tag = readTag(userPtr)

    incrementCountInMap(tag, incRefsByTag)

    if (options.printIncrefsAndDecRefs) {

      if (Set.contains(userPtr, allocations)) {
        print(
          "incref for object at 0x" ++ toHex(userPtr) ++ " (prev count: " ++
          toString(oldRefCount) ++
          "; new count: " ++
          toString(newRefCount) ++
          "; tag: " ++
          toString(tag) ++
          " " ++
          tagToTypeName(tag) ++
          ") " ++
          maybeObjectContentsAppendix(userPtr),
        )
      } else {
        if (!Map.contains(userPtr, inintialRefCountsOnPreExistingObjects)) {
          Map.set(userPtr, oldRefCount, inintialRefCountsOnPreExistingObjects)
        }

        incrementCountInMap(userPtr, incRefsOnPreExistingObjects)

        print(
          "incref for pre-existing object at 0x" ++ toHex(userPtr) ++
          " (prev count: " ++
          toString(oldRefCount) ++
          "; new count: " ++
          toString(newRefCount) ++
          "; tag: " ++
          toString(tag) ++
          " " ++
          tagToTypeName(tag) ++
          ") " ++
          maybeObjectContentsAppendix(userPtr),
        )
      }
    }
  }

  let onDecRef = (userPtr: Number, ignoreZeros: Bool) => {
    totalDecRefs += 1

    let oldRefCount = readRefCount(userPtr)
    // It would be more accurate to actually receive the new ref count,
    // but it would complicate things unnecessarily. Instead I'm replicating
    // a piece of logic from GC.decRef regarding decrementing objects with
    // refcount of 0.
    let newRefCount = if (oldRefCount == 0 && ignoreZeros) {
      0
    } else {
      oldRefCount - 1
    }
    let tag = readTag(userPtr)

    incrementCountInMap(tag, decRefsByTag)

    if (options.printIncrefsAndDecRefs) {
      if (oldRefCount < 1 && !ignoreZeros) {
        print(
          "⚠ PROBLEM DETECTED: unexpected decRef at address 0x" ++
          " (tag: " ++
          toString(tag) ++
          " " ++
          tagToTypeName(tag) ++
          ")" ++
          maybeObjectContentsAppendix(userPtr),
        )

        if (tag == 7
        /* or Tags._GRAIN_LAMBDA_HEAP_TAG*/) {
          print(
            "The object is a function or lambda. You have to incRef a function before calling it from a @disableGC context.",
          )
        }
      } else {
        if (Set.contains(userPtr, allocations)) {
          print(
            "decref for object at 0x" ++ toHex(userPtr) ++ " (prev count: " ++
            toString(oldRefCount) ++
            "; new count: " ++
            toString(newRefCount) ++
            "; tag: " ++
            toString(tag) ++
            " " ++
            tagToTypeName(tag) ++
            ")" ++
            maybeObjectContentsAppendix(userPtr),
          )
        } else {
          if (!Map.contains(userPtr, inintialRefCountsOnPreExistingObjects)) {
            Map.set(userPtr, oldRefCount, inintialRefCountsOnPreExistingObjects)
          }

          incrementCountInMap(userPtr, decRefsOnPreExistingObjects)

          print(
            "decref for pre-existing object at 0x" ++ toHex(userPtr) ++
            " (prev count: " ++
            toString(oldRefCount) ++
            "; new count: " ++
            toString(newRefCount) ++
            "; tag: " ++
            toString(tag) ++
            " " ++
            tagToTypeName(tag) ++
            ")" ++
            maybeObjectContentsAppendix(userPtr),
          )
        }
      }
    }
  }

  let onMalloc = (userPtr: Number) => {
    totalMallocs += 1

    // Tracking objects allocated in the debug block.
    if (Set.contains(userPtr, allocations)) {
      // A new allocation, but for an object already allocated inside the debug block, but never removed.
      print(
        "⚠ PROBLEM DETECTED: unexpected malloc at address 0x" ++
        toHex(userPtr) ++
        " that hasn't been freed. This may be caused by direct calls to Malloc.free for objects created with GC.malloc.",
      )
    } else {
      // A new allocation made in the debug block.
      if (options.printMallocAndFree) {
        print("new object at 0x" ++ toHex(userPtr))
      }

      // Add the pointer to the new object to start tracking it until it's deallocated.
      Set.add(userPtr, allocations)
    }
  }

  let onFree = (userPtr: Number) => {
    totalFrees += 1

    let refCount = readRefCount(userPtr)
    let tag = readTag(userPtr)

    if (Set.contains(userPtr, allocations)) {
      if (options.printMallocAndFree) {
        print(
          "deallocating object at 0x" ++ toHex(userPtr) ++ " (ref. count: " ++
          toString(refCount) ++
          "; tag: " ++
          toString(tag) ++
          " " ++
          tagToTypeName(tag) ++
          ")" ++
          maybeObjectContentsAppendix(userPtr),
        )
      }

      Set.remove(userPtr, allocations)

      incrementCountInMap(tag, mallocPlusFreeByTag)
    } else {
      if (options.printMallocAndFree) {
        print(
          "deallocating pre-existing object at 0x" ++ toHex(userPtr) ++
          " (ref. count: " ++
          toString(refCount) ++
          "; tag: " ++
          toString(tag) ++
          " " ++
          tagToTypeName(tag) ++
          ")" ++
          maybeObjectContentsAppendix(userPtr),
        )
      }
    }

    if (Map.contains(userPtr, incRefsOnPreExistingObjects) ||
    Map.contains(userPtr, decRefsOnPreExistingObjects)) {
      // While this isn't guaranteed to be a real problem, it likely is.
      // So let's keep count of these cases in order to report it in
      // the summary and return failed result for test assertions.
      totalPreexistingObjectsDeallocated += 1

      // Must remove this pointer from the two maps, otherwise it would
      // lead to problems when trying to print the object info at the end.
      // Also once freed, this address can be reused, which would then
      // lead to wrong information being reported.
      Map.remove(userPtr, incRefsOnPreExistingObjects)
      Map.remove(userPtr, decRefsOnPreExistingObjects)
      Map.remove(userPtr, inintialRefCountsOnPreExistingObjects)

      print(
        "⚠ POSSIBLE PROBLEM DETECTED: pre-existing object at 0x" ++
        toHex(userPtr) ++
        " has been deallocated" ++
        " (ref. count: " ++
        toString(refCount) ++
        "; tag: " ++
        toString(tag) ++
        " " ++
        tagToTypeName(tag) ++
        "). Information about incRefs/decRefs won't be printed for this object." ++
        maybeObjectContentsAppendix(userPtr),
      )
    }
  }

  @disableGC
  let incRefHook = (userPtr: WasmI32) => {
    Memory.incRef(WasmI32.fromGrain(Conv.wasmI32ToNumber))
    let ptrAsNumber = Conv.wasmI32ToNumber(userPtr)

    // Skip the incRef made when calling the actual function to test.
    if (WasmI32.ne(userPtr, WasmI32.fromGrain(f)) &&
    WasmI32.ne(userPtr, WasmI32.fromGrain(GC.removeDebugHooks))) {
      Memory.incRef(WasmI32.fromGrain(onIncRef))
      onIncRef(ptrAsNumber)
    }
  }

  @disableGC
  let decRefHook = (userPtr: WasmI32, ignoreZeros: Bool) => {
    Memory.incRef(WasmI32.fromGrain(Conv.wasmI32ToNumber))
    let ptrAsNumber = Conv.wasmI32ToNumber(userPtr)

    // Skip the incRef made when calling the actual function to test.
    if (WasmI32.ne(userPtr, WasmI32.fromGrain(f))) {
      Memory.incRef(WasmI32.fromGrain(onDecRef))
      onDecRef(ptrAsNumber, ignoreZeros)
    }
  }

  @disableGC
  let mallocHook = (userPtr: WasmI32) => {
    Memory.incRef(WasmI32.fromGrain(Conv.wasmI32ToNumber))
    let ptrAsNumber = Conv.wasmI32ToNumber(userPtr)

    Memory.incRef(WasmI32.fromGrain(onMalloc))
    onMalloc(ptrAsNumber)
  }

  @disableGC
  let freeHook = (userPtr: WasmI32) => {
    Memory.incRef(WasmI32.fromGrain(Conv.wasmI32ToNumber))
    let ptrAsNumber = Conv.wasmI32ToNumber(userPtr)

    Memory.incRef(WasmI32.fromGrain(onFree))
    onFree(ptrAsNumber)
  }

  GC.setDebugHooks(incRefHook, decRefHook, mallocHook, freeHook)

  f()

  GC.removeDebugHooks()

  // Determine objects that existed before executing the function that have been
  // messed up with unmaching incRefs/decRefs.
  // Note that the inintialRefCountsOnPreExistingObjects map is guaranteed to
  // have entries for keys of both incRefsOnPreExistingObjects and decRefsOnPreExistingObjects.
  let preExistingObjectsWithRefCountMismatch = Map.make(): (Map.Map<Number, (Number,Number,Number,Number)>)

  Map.forEach(
    (userPtr, initialRefCount) => {
      let incRefCount = Option.unwrapWithDefault(
        0,
        Map.get(userPtr, incRefsOnPreExistingObjects),
      )

      let decRefCount = Option.unwrapWithDefault(
        0,
        Map.get(userPtr, decRefsOnPreExistingObjects),
      )

      let finalRefCount = readRefCount(userPtr)

      if (incRefCount != decRefCount) {
        Map.set(
          userPtr,
          (incRefCount, decRefCount, initialRefCount, finalRefCount),
          preExistingObjectsWithRefCountMismatch,
        )
      }
    },
    inintialRefCountsOnPreExistingObjects,
  )

  let preExistingObjectsWithRefCountMismatches = Map.size(
    preExistingObjectsWithRefCountMismatch,
  )

  let numAllocLeaks = Set.size(allocations)

  let noLeaksFound = numAllocLeaks == 0 && totalPreexistingObjectsDeallocated == 0 &&
  preExistingObjectsWithRefCountMismatches == 0

  let printSummary = match (options.summary) {
    PrintSummaryIfLeaksAreFound => !noLeaksFound,
    AlwaysPrintSummary => true
  }

  if (printSummary) {
    if (noLeaksFound) {
      print("")
      print("no leaks found")
    }

    if (preExistingObjectsWithRefCountMismatches == 0) {
      print("")
      print("✔ no ref. count issues caused on pre-existing objects")
    } else {
      print("")
      print(
        "⚠ " ++ toString(preExistingObjectsWithRefCountMismatches) ++
        " ref. count issues caused on pre-existing objects: ",
      )
      Map.forEach(
        (userPtr, (incRefs, decRefs, initialRefCount, finalRefCount)) => {
          let tag = readTag(userPtr)
          print(
            "- 0x" ++ toHex(userPtr) ++ " (incRefs: " ++ toString(incRefs) ++
            "; decRefs: " ++
            toString(decRefs) ++
            "; initial ref. count: " ++
            toString(initialRefCount) ++
            "; final ref. count: " ++
            toString(finalRefCount) ++
            "; tag " ++
            toString(tag) ++
            " " ++
            tagToTypeName(tag) ++
            ")" ++
            maybeObjectContentsAppendix(userPtr),
          )
        },
        preExistingObjectsWithRefCountMismatch,
      )
    }
    
    if (totalPreexistingObjectsDeallocated > 0) {
      print("")
      print(
        "⚠ " ++ toString(totalPreexistingObjectsDeallocated) ++
        " pre-existing objects has been deallocated",
      )
    }

    let leakedByTag = Map.make(): (Map.Map<Number, Number>)

    if (numAllocLeaks == 0) {
      print("")
      print("✔ no malloc/free leaks detected")
    } else {
      print("")
      print("⚠ " ++ toString(numAllocLeaks) ++ " malloc/free leaks detected:")

      Set.forEach(
        userPtr => {
          let refCount = readRefCount(userPtr)
          let tag = readTag(userPtr)
          print(
            "- 0x" ++ toHex(userPtr) ++ " (ref. count: " ++ toString(refCount) ++
            "; tag " ++
            toString(tag) ++
            " " ++
            tagToTypeName(tag) ++
            ")" ++
            maybeObjectContentsAppendix(userPtr),
          )

          incrementCountInMap(tag, leakedByTag)
        },
        allocations,
      )
    }
    
    print("")
    print("totalMallocs: " ++ toString(totalMallocs))
    print("totalFrees: " ++ toString(totalFrees))
    print("totalIncRefs: " ++ toString(totalIncRefs))
    print("totalDecRefs: " ++ toString(totalDecRefs))
    print("")
    print("incRef/decRefs by tag:")

    let allTags = keyUnionOfTwoMaps(incRefsByTag, decRefsByTag)

    // TODO sort the tags once we have sorting in stdlib
    //let allTagsSorted = Array.sort((...) => {...}, Set.toArray(allTags))

    Set.forEach(
      tag => {
        let incRefCount = Option.unwrapWithDefault(0, Map.get(tag, incRefsByTag))
        let decRefCount = Option.unwrapWithDefault(0, Map.get(tag, decRefsByTag))
        let mallocPlusFreeCount = Option.unwrapWithDefault(
          0,
          Map.get(tag, mallocPlusFreeByTag),
        )

        // This may sound counter intuitive, but leaked objects need to be counted
        // as proper incRefs because GC.malloc creates them with ref count of 1.
        // Not doing so would actually conceal problems in total incRef/decRef
        // deltas.
        let mallocButNotFreedCount = Option.unwrapWithDefault(
          0,
          Map.get(tag, leakedByTag),
        )

        let delta = incRefCount - decRefCount + mallocPlusFreeCount +
        mallocButNotFreedCount

        let icon = if (delta == 0) {
          "✔️"
        } else {
          "⚠"
        }
        print(
          icon ++ " " ++ toString(tag) ++ " " ++ tagToTypeName(tag) ++ ": \t" ++
          toString(incRefCount) ++
          " incRefs, \t" ++
          toString(decRefCount) ++
          " decrefs, \t" ++
          toString(mallocPlusFreeCount) ++
          " malloc+free, \t" ++
          toString(mallocButNotFreedCount) ++
          " malloc without free",
        )
      },
      allTags,
    )
  }

  noLeaksFound
}

/**
 * Executes the provided function and tries to detect memory leaks and
 * reference counting issues. It's assumed that the function is meant to have
 * no side effects on memory referenced by global variables or captured
 * variables.
 *
 * @param name: Arbitrary name printed in the output
 * @param options: The options controlling logging detail
 * @param f: The function to execute and check
 * @return True if no leaks where detected.
 */
export let leakDebugBlock =
  (
    name: String,
    options: Option<LeakDebugBlockOptions>,
    f: () -> Void,
  ) => {
  print("start of GC debug block \"" ++ name ++ "\"")
  print("")

  let options = match (options) {
    Some(opts) => opts,
    None =>
      {
        printIncrefsAndDecRefs: true,
        printMallocAndFree: true,
        printObjectContents: false,
        summary: AlwaysPrintSummary,
      },
  }

  let noLeaks = leakDebugBlockImpl(options, f)

  print("")
  print("end of GC debug block \"" ++ name ++ "\"")
  print("")

  noLeaks
}

/**
 * Executes the provided function and tries to detect memory leaks and
 * reference counting issues. It's assumed that the function is meant to have
 * no side effects on memory referenced by global variables or captured
 * variables.
 *
 * @param name: Arbitrary name printed in the output
 * @param options: The options controlling logging detail
 * @param f: The function to execute and check
 * @return True if no leaks where detected.
 */
export let ensureNoLeaks = (f: () -> Void) => {
  leakDebugBlockImpl(
    {
      printIncrefsAndDecRefs: false,
      printMallocAndFree: false,
      printObjectContents: true,
      summary: PrintSummaryIfLeaksAreFound,
    },
    f,
  )
}
