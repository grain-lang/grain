/* grainc-flags --no-pervasives */

import Memory from "runtime/unsafe/memory"
import Tags from "runtime/unsafe/tags"
import Exception from "runtime/exception"
import BI from "runtime/bigint"

import {
  _SMAX32_I64 as _I32_MAX,
  _SMIN32_I64 as _I32_MIN,
} from "runtime/unsafe/constants"
import WasmI32 from "runtime/unsafe/wasmi32"
import WasmI64 from "runtime/unsafe/wasmi64"
import WasmF32 from "runtime/unsafe/wasmf32"
import WasmF64 from "runtime/unsafe/wasmf64"

primitive (!): Bool -> Bool = "@not"
primitive (&&): (Bool, Bool) -> Bool = "@and"
primitive (||): (Bool, Bool) -> Bool = "@or"
primitive throw: Exception -> a = "@throw"

exception UnknownNumberTag
exception InvariantViolation

import {
  newRational,
  newInt32,
  newInt64,
  newFloat32,
  newFloat64,
} from "runtime/dataStructures"

@unsafe
let _F32_MAX = 3.40282347e+38W
@unsafe
let _F32_MIN = 1.401298464324817e-45W
@unsafe
let _F32_MAX_SAFE_INTEGER = 16777215.w
@unsafe
let _F64_MAX_SAFE_INTEGER = 9007199254740991.W

let (==) = WasmI32.eq
let (!=) = WasmI32.ne

@unsafe
let tagSimple = x => {
  WasmI32.xor(WasmI32.shl(x, 1n), 1n)
}

@unsafe
let untagSimple = x => {
  WasmI32.shrS(x, 1n)
}

@unsafe
let isSimpleNumber = x => {
  WasmI32.eq(
    WasmI32.and(x, Tags._GRAIN_NUMBER_TAG_MASK),
    Tags._GRAIN_NUMBER_TAG_TYPE
  )
}

@unsafe
export let isBoxedNumber = x => {
  if (
    WasmI32.eq(
      WasmI32.and(x, Tags._GRAIN_GENERIC_TAG_MASK),
      Tags._GRAIN_GENERIC_HEAP_TAG_TYPE
    )
  ) {
    WasmI32.eq(WasmI32.load(x, 0n), Tags._GRAIN_BOXED_NUM_HEAP_TAG)
  } else {
    false
  }
}

@unsafe
export let isFloat = x => {
  if (isBoxedNumber(x)) {
    let tag = WasmI32.load(x, 4n)
    WasmI32.eq(tag, Tags._GRAIN_FLOAT32_BOXED_NUM_TAG) ||
    WasmI32.eq(tag, Tags._GRAIN_FLOAT64_BOXED_NUM_TAG)
  } else {
    false
  }
}

@unsafe
export let isInteger = x => {
  if (isBoxedNumber(x)) {
    let tag = WasmI32.load(x, 4n)
    WasmI32.eq(tag, Tags._GRAIN_INT32_BOXED_NUM_TAG) ||
    WasmI32.eq(tag, Tags._GRAIN_INT64_BOXED_NUM_TAG) ||
    WasmI32.eq(tag, Tags._GRAIN_BIGINT_BOXED_NUM_TAG)
  } else {
    true
  }
}

@unsafe
export let isRational = x => {
  if (isBoxedNumber(x)) {
    let tag = WasmI32.load(x, 4n)
    WasmI32.eq(tag, Tags._GRAIN_RATIONAL_BOXED_NUM_TAG)
  } else {
    false
  }
}

@unsafe
let isBigInt = x => {
  if (isBoxedNumber(x)) {
    let tag = WasmI32.load(x, 4n)
    WasmI32.eq(tag, Tags._GRAIN_BIGINT_BOXED_NUM_TAG)
  } else {
    false
  }
}

@unsafe
export let isNumber = x => {
  // x is a number if it is a literal number or a boxed_num heap value
  isSimpleNumber(x) || isBoxedNumber(x)
}

@unsafe
let safeI64toI32 = x => {
  if (WasmI64.gtS(x, _I32_MAX) || WasmI64.ltS(x, _I32_MIN)) {
    throw Exception.Overflow
  } else {
    WasmI32.wrapI64(x)
  }
}

@unsafe
let i32neg = x => WasmI32.sub(0n, x)

@unsafe
let i64not = x => WasmI64.xor(x, 0xffffffffffffffffN)
@unsafe
let i64neg = x => WasmI64.sub(0N, x)

// https://en.wikipedia.org/wiki/Binary_GCD_algorithm
@unsafe
let rec gcdHelp = (x, y) => {
  if (WasmI64.eq(x, y) || WasmI64.eqz(x)) {
    y
  } else if (WasmI64.eqz(y)) {
    x
  } else if (WasmI64.ne(WasmI64.and(i64not(x), 1N), 0N)) {
    // x is even
    if (WasmI64.ne(WasmI64.and(y, 1N), 0N)) {
      // y is odd
      gcdHelp(WasmI64.shrS(x, 1N), y)
    } else {
      WasmI64.shl(gcdHelp(WasmI64.shrS(x, 1N), WasmI64.shrS(y, 1N)), 1N)
    }
  } else if (WasmI64.ne(WasmI64.and(i64not(y), 1N), 0N)) {
    // y is even and x is odd
    gcdHelp(x, WasmI64.shrS(y, 1N))
  } else if (WasmI64.gtS(x, y)) {
    gcdHelp(WasmI64.sub(x, y), y)
  } else {
    gcdHelp(WasmI64.sub(y, x), x)
  }
}

@unsafe
let gcd = (x, y) => {
  // Algorithm above breaks on negatives, so
  // we make sure that they are positive at the beginning
  let x = if (WasmI64.ltS(x, 0N)) {
    i64neg(x)
  } else {
    x
  }
  let y = if (WasmI64.ltS(y, 0N)) {
    i64neg(y)
  } else {
    y
  }
  gcdHelp(x, y)
}

@unsafe
let gcd32 = (x, y) => {
  WasmI32.wrapI64(gcd(WasmI64.extendI32S(x), WasmI64.extendI32S(y)))
}

@unsafe
export let reducedInteger = x => {
  if (WasmI64.gtS(x, _I32_MAX) || WasmI64.ltS(x, _I32_MIN)) {
    newInt64(x)
  } else if (
    WasmI64.gtS(x, WasmI64.shrS(_I32_MAX, 1N)) ||
    WasmI64.ltS(x, WasmI64.shrS(_I32_MIN, 1N))
  ) {
    newInt32(WasmI32.wrapI64(x))
  } else {
    tagSimple(WasmI32.wrapI64(x))
  }
}

@unsafe
let reducedBigInteger = x => {
  if (BI.canConvertToInt64(x)) {
    // CONVENTION: We assume that this function is called in
    //             some sort of tail position, meaning that
    //             the original input is no longer used after
    //             this function returns.
    let ret = reducedInteger(BI.toInt64(x))
    Memory.decRef(x)
    ret
  } else {
    x
  }
}

@unsafe
let reducedFractionBigInt = (x, y) => {
  let mut x = x
  let mut y = y
  let mut needsDecref = false

  if (BI.isNegative(y)) {
    // Normalization 1: Never do negative/negative
    // Normalization 2: Never allow a negative denominator
    needsDecref = true
    x = BI.negate(x)
    y = BI.negate(y)
  }
  if (BI.eqz(y)) {
    throw Exception.DivisionByZero
  }
  let quotremResult = Memory.malloc(8n)
  BI.quotRem(x, y, quotremResult)
  // Note that the contents of quotRem are malloc'ed
  // inside of quotRem and need to be manually freed.
  let q = WasmI32.load(quotremResult, 0n)
  let r = WasmI32.load(quotremResult, 4n)
  // free container used to store quotrem result
  Memory.free(quotremResult)
  let ret = if (BI.eqz(r)) {
    // if remainder is zero, then return the quotient.
    // We decRef the remainder, since we no longer need it
    Memory.decRef(r)
    reducedBigInteger(q)
  } else {
    // remainder is nonzero. we don't need the quotient and
    // remainder anymore, so we discard them.
    Memory.decRef(q)
    Memory.decRef(r)
    let factor = BI.gcd(x, y)
    let xdiv = BI.div(x, factor)
    let ydiv = BI.div(y, factor)
    let ret = newRational(xdiv, ydiv)
    Memory.decRef(factor)
    ret
  }
  if (needsDecref) {
    Memory.decRef(x)
    Memory.decRef(y)
    void
  }
  ret
}

@unsafe
let reducedFraction64 = (x, y) => {
  let mut x = x
  let mut y = y

  if (WasmI64.ltS(y, 0N)) {
    // Normalization 1: Never do negative/negative
    // Normalization 2: Never allow a negative denominator
    x = i64neg(x)
    y = i64neg(y)
  }
  if (WasmI64.eqz(y)) {
    throw Exception.DivisionByZero
  }
  if (WasmI64.eqz(WasmI64.remS(x, y))) {
    reducedInteger(WasmI64.divS(x, y))
  } else {
    let factor = gcd(x, y)
    let xdiv = WasmI64.divS(x, factor)
    let ydiv = WasmI64.divS(y, factor)
    newRational(BI.makeWrappedInt64(xdiv), BI.makeWrappedInt64(ydiv))
  }
}

// Accessor functions

/* Memory Layout:
 * [GRAIN_BOXED_NUM_HEAP_TAG , <boxed_num tag> , <number-specific payload>...]
 * (payload depends on boxed_num tag...see below)
 *
 * Payloads:
 * For Int32:
 * [number]
 *
 * For Int64:
 * [number: i64]
 *
 * For Float32:
 * [number: f32]
 *
 * For Float64:
 * [number: f64]
 *
 * For Rational:
 * [numerator, denominator]
 */

@unsafe
export let boxedNumberTag = xptr => {
  WasmI32.load(xptr, 4n)
}

@unsafe
export let boxedInt32Number = xptr => {
  WasmI32.load(xptr, 8n)
}

@unsafe
export let boxedInt64Number = xptr => {
  WasmI64.load(xptr, 8n)
}

@unsafe
export let boxedFloat32Number = xptr => {
  WasmF32.load(xptr, 8n)
}

@unsafe
export let boxedFloat64Number = xptr => {
  WasmF64.load(xptr, 8n)
}

@unsafe
export let boxedRationalNumerator = xptr => {
  WasmI32.load(xptr, 8n)
}

@unsafe
export let boxedRationalDenominator = xptr => {
  WasmI32.load(xptr, 12n)
}

@unsafe
export let coerceNumberToWasmF32 = (x: Number) => {
  let x = WasmI32.fromGrain(x)
  if (isSimpleNumber(x)) {
    WasmF32.convertI32S(untagSimple(x))
  } else {
    let xtag = boxedNumberTag(x)
    match (xtag) {
      t when WasmI32.eq(t, Tags._GRAIN_INT32_BOXED_NUM_TAG) => {
        WasmF32.convertI32S(boxedInt32Number(x))
      },
      t when WasmI32.eq(t, Tags._GRAIN_INT64_BOXED_NUM_TAG) => {
        WasmF32.convertI64S(boxedInt64Number(x))
      },
      t when WasmI32.eq(t, Tags._GRAIN_BIGINT_BOXED_NUM_TAG) => {
        BI.toFloat32(x)
      },
      t when WasmI32.eq(t, Tags._GRAIN_RATIONAL_BOXED_NUM_TAG) => {
        WasmF32.div(
          BI.toFloat32(boxedRationalNumerator(x)),
          BI.toFloat32(boxedRationalDenominator(x))
        )
      },
      t when WasmI32.eq(t, Tags._GRAIN_FLOAT32_BOXED_NUM_TAG) => {
        boxedFloat32Number(x)
      },
      t when WasmI32.eq(t, Tags._GRAIN_FLOAT64_BOXED_NUM_TAG) => {
        let xval = boxedFloat64Number(x)
        if (WasmF64.gt(xval, _F32_MAX) || WasmF64.lt(xval, _F32_MIN)) {
          // Not an actual return value
          throw Exception.Overflow
        } else {
          WasmF32.demoteF64(xval)
        }
      },
      _ => {
        throw UnknownNumberTag
      },
    }
  }
}

@unsafe
export let coerceNumberToWasmF64 = (x: Number) => {
  let x = WasmI32.fromGrain(x)
  if (isSimpleNumber(x)) {
    WasmF64.convertI32S(untagSimple(x))
  } else {
    let xtag = boxedNumberTag(x)
    match (xtag) {
      t when WasmI32.eq(t, Tags._GRAIN_INT32_BOXED_NUM_TAG) => {
        WasmF64.convertI32S(boxedInt32Number(x))
      },
      t when WasmI32.eq(t, Tags._GRAIN_INT64_BOXED_NUM_TAG) => {
        WasmF64.convertI64S(boxedInt64Number(x))
      },
      t when WasmI32.eq(t, Tags._GRAIN_BIGINT_BOXED_NUM_TAG) => {
        BI.toFloat64(x)
      },
      t when WasmI32.eq(t, Tags._GRAIN_RATIONAL_BOXED_NUM_TAG) => {
        WasmF64.div(
          BI.toFloat64(boxedRationalNumerator(x)),
          BI.toFloat64(boxedRationalDenominator(x))
        )
      },
      t when WasmI32.eq(t, Tags._GRAIN_FLOAT32_BOXED_NUM_TAG) => {
        WasmF64.promoteF32(boxedFloat32Number(x))
      },
      t when WasmI32.eq(t, Tags._GRAIN_FLOAT64_BOXED_NUM_TAG) => {
        boxedFloat64Number(x)
      },
      _ => {
        throw UnknownNumberTag
      },
    }
  }
}

@unsafe
export let coerceNumberToWasmI64 = (x: Number) => {
  let x = WasmI32.fromGrain(x)
  if (isSimpleNumber(x)) {
    WasmI64.extendI32S(untagSimple(x))
  } else {
    let xtag = boxedNumberTag(x)
    match (xtag) {
      t when WasmI32.eq(t, Tags._GRAIN_INT32_BOXED_NUM_TAG) => {
        WasmI64.extendI32S(boxedInt32Number(x))
      },
      t when WasmI32.eq(t, Tags._GRAIN_INT64_BOXED_NUM_TAG) => {
        boxedInt64Number(x)
      },
      t when WasmI32.eq(t, Tags._GRAIN_BIGINT_BOXED_NUM_TAG) => {
        BI.toInt64(x)
      },
      _ => {
        // rationals are never integral, and we refuse to coerce floats to ints
        throw Exception.NumberNotIntlike
      },
    }
  }
}

@unsafe
export let coerceNumberToWasmI32 = (x: Number) => {
  let x = WasmI32.fromGrain(x)
  if (isSimpleNumber(x)) {
    untagSimple(x)
  } else {
    let xtag = boxedNumberTag(x)
    match (xtag) {
      t when WasmI32.eq(t, Tags._GRAIN_INT32_BOXED_NUM_TAG) => {
        boxedInt32Number(x)
      },
      t when WasmI32.eq(t, Tags._GRAIN_INT64_BOXED_NUM_TAG) => {
        let int64 = boxedInt64Number(x)
        if (WasmI64.gtS(int64, _I32_MAX) || WasmI64.ltS(int64, _I32_MIN)) {
          throw Exception.Overflow
        }
        WasmI32.wrapI64(int64)
      },
      t when WasmI32.eq(t, Tags._GRAIN_BIGINT_BOXED_NUM_TAG) => {
        BI.toInt32(x)
      },
      _ => {
        // rationals are never integral, and we refuse to coerce floats to ints
        throw Exception.NumberNotIntlike
      },
    }
  }
}

@unsafe
export let coerceNumberToBigInt = (x: Number) => {
  let x = WasmI32.fromGrain(x)
  if (isSimpleNumber(x)) {
    BI.makeWrappedInt32(untagSimple(x))
  } else {
    let xtag = boxedNumberTag(x)
    match (xtag) {
      t when WasmI32.eq(t, Tags._GRAIN_INT32_BOXED_NUM_TAG) => {
        BI.makeWrappedInt32(boxedInt32Number(x))
      },
      t when WasmI32.eq(t, Tags._GRAIN_INT64_BOXED_NUM_TAG) => {
        BI.makeWrappedInt64(boxedInt64Number(x))
      },
      t when WasmI32.eq(t, Tags._GRAIN_BIGINT_BOXED_NUM_TAG) => {
        Memory.incRef(x)
        x
      },
      _ => {
        // rationals are never integral, and we refuse to coerce floats to ints
        throw Exception.NumberNotIntlike
      },
    }
  }
}

@unsafe
let isIntegerF32 = value => {
  WasmF32.eq(value, WasmF32.trunc(value))
}

@unsafe
let isIntegerF64 = value => {
  WasmF64.eq(value, WasmF64.trunc(value))
}

@unsafe
let isSafeIntegerF32 = value => {
  WasmF32.le(WasmF32.abs(value), _F32_MAX_SAFE_INTEGER) &&
  WasmF32.eq(WasmF32.trunc(value), value)
}

@unsafe
let isSafeIntegerF64 = value => {
  WasmF64.le(WasmF64.abs(value), _F64_MAX_SAFE_INTEGER) &&
  WasmF64.eq(WasmF64.trunc(value), value)
}

/** Number-aware equality checking
  * The basic idea is that we first figure out the type of the
  * number on the LHS, and then figure out if the RHS number is equal
  * to that number
  *
  * NOTE: The preconditions in these functions are important, so do NOT
  *       export them!
  */

@unsafe
let numberEqualSimpleHelp = (x, y) => {
  // PRECONDITION: x is a "simple" number (value tag is 0) and x !== y and isNumber(y)
  if (isSimpleNumber(y)) {
    // x !== y, so they must be different
    false
  } else {
    let xval = untagSimple(x) // <- actual int value of x
    let yBoxedNumberTag = boxedNumberTag(y)
    match (yBoxedNumberTag) {
      t when WasmI32.eq(t, Tags._GRAIN_INT32_BOXED_NUM_TAG) => {
        let yBoxedVal = boxedInt32Number(y)
        WasmI32.eq(xval, yBoxedVal)
      },
      t when WasmI32.eq(t, Tags._GRAIN_INT64_BOXED_NUM_TAG) => {
        let yBoxedVal = boxedInt64Number(y)
        WasmI64.eq(WasmI64.extendI32S(xval), yBoxedVal)
      },
      t when WasmI32.eq(t, Tags._GRAIN_BIGINT_BOXED_NUM_TAG) => {
        WasmI32.eqz(BI.cmpI64(y, WasmI64.extendI32S(xval)))
      },
      t when WasmI32.eq(t, Tags._GRAIN_RATIONAL_BOXED_NUM_TAG) => {
        // NOTE: we always store in most reduced form, so a rational and an int are never equal
        false
      },
      t when WasmI32.eq(t, Tags._GRAIN_FLOAT32_BOXED_NUM_TAG) => {
        let yBoxedVal = boxedFloat32Number(y)
        isSafeIntegerF32(yBoxedVal) &&
        WasmF32.eq(WasmF32.convertI32S(xval), yBoxedVal)
      },
      t when WasmI32.eq(t, Tags._GRAIN_FLOAT64_BOXED_NUM_TAG) => {
        let yBoxedVal = boxedFloat64Number(y)
        isSafeIntegerF64(yBoxedVal) &&
        WasmF64.eq(WasmF64.convertI32S(xval), yBoxedVal)
      },
      _ => {
        throw UnknownNumberTag
      },
    }
  }
}

@unsafe
let numberEqualInt64Help = (xBoxedVal, y) => {
  // PRECONDITION: x !== y and isNumber(y)
  // Basic number:
  if (isSimpleNumber(y)) {
    WasmI64.eq(xBoxedVal, WasmI64.extendI32S(untagSimple(y)))
  } else {
    // Boxed number:
    let yBoxedNumberTag = boxedNumberTag(y)
    match (yBoxedNumberTag) {
      t when WasmI32.eq(t, Tags._GRAIN_INT32_BOXED_NUM_TAG) => {
        let yBoxedVal = boxedInt32Number(y)
        WasmI64.eq(xBoxedVal, WasmI64.extendI32S(yBoxedVal))
      },
      t when WasmI32.eq(t, Tags._GRAIN_INT64_BOXED_NUM_TAG) => {
        let yBoxedVal = boxedInt64Number(y)
        WasmI64.eq(xBoxedVal, yBoxedVal)
      },
      t when WasmI32.eq(t, Tags._GRAIN_BIGINT_BOXED_NUM_TAG) => {
        WasmI32.eqz(BI.cmpI64(y, xBoxedVal))
      },
      t when WasmI32.eq(t, Tags._GRAIN_RATIONAL_BOXED_NUM_TAG) => {
        // NOTE: we always store in most reduced form, so a rational and an int are never equal
        false
      },
      t when WasmI32.eq(t, Tags._GRAIN_FLOAT32_BOXED_NUM_TAG) => {
        let yBoxedVal = boxedFloat32Number(y)
        isSafeIntegerF32(yBoxedVal) &&
        WasmI64.eq(xBoxedVal, WasmI64.truncF32S(yBoxedVal))
      },
      t when WasmI32.eq(t, Tags._GRAIN_FLOAT64_BOXED_NUM_TAG) => {
        let yBoxedVal = boxedFloat64Number(y)
        isSafeIntegerF64(yBoxedVal) &&
        WasmI64.eq(xBoxedVal, WasmI64.truncF64S(yBoxedVal))
      },
      _ => {
        throw UnknownNumberTag
      },
    }
  }
}

@unsafe
let numberEqualInt32Help = (xBoxedVal, y) => {
  // We can just pretend it's 64-bit for the equality check
  numberEqualInt64Help(WasmI64.extendI32S(xBoxedVal), y)
}

@unsafe
let numberEqualRationalHelp = (xptr, y) => {
  // PRECONDITION: x is rational and x !== y and isNumber(y)
  // Basic number: (we know it's not equal, since we never store ints as rationals)
  if (isSimpleNumber(y)) {
    false
  } else {
    let xNumerator = boxedRationalNumerator(xptr)
    let xDenominator = boxedRationalDenominator(xptr)
    // Boxed number:
    let yBoxedNumberTag = boxedNumberTag(y)
    match (yBoxedNumberTag) {
      t when WasmI32.eq(t, Tags._GRAIN_INT32_BOXED_NUM_TAG) => {
        false
      },
      t when WasmI32.eq(t, Tags._GRAIN_INT64_BOXED_NUM_TAG) => {
        false
      },
      t when WasmI32.eq(t, Tags._GRAIN_BIGINT_BOXED_NUM_TAG) => {
        false
      },
      t when WasmI32.eq(t, Tags._GRAIN_RATIONAL_BOXED_NUM_TAG) => {
        let yNumerator = boxedRationalNumerator(y)
        let yDenominator = boxedRationalDenominator(y)
        BI.eq(xNumerator, yNumerator) && BI.eq(xDenominator, yDenominator)
      },
      t when WasmI32.eq(t, Tags._GRAIN_FLOAT32_BOXED_NUM_TAG) => {
        let yBoxedVal = boxedFloat32Number(y)
        let xAsFloat = WasmF32.div(
          BI.toFloat32(xNumerator),
          BI.toFloat32(xDenominator)
        )
        // TODO(#303): maybe we should have some sort of tolerance?
        WasmF32.eq(xAsFloat, yBoxedVal)
      },
      t when WasmI32.eq(t, Tags._GRAIN_FLOAT64_BOXED_NUM_TAG) => {
        let yBoxedVal = boxedFloat64Number(y)
        let xAsFloat = WasmF64.div(
          BI.toFloat64(xNumerator),
          BI.toFloat64(xDenominator)
        )
        // TODO(#303): maybe we should have some sort of tolerance?
        WasmF64.eq(xAsFloat, yBoxedVal)
      },
      _ => {
        throw UnknownNumberTag
      },
    }
  }
}

@unsafe
let numberEqualFloat64Help = (x, y) => {
  let xIsInteger = isIntegerF64(x)
  // Basic number:
  if (isSimpleNumber(y)) {
    xIsInteger && WasmF64.eq(x, WasmF64.convertI32S(untagSimple(y)))
  } else {
    // Boxed number
    let yBoxedNumberTag = boxedNumberTag(y)
    match (yBoxedNumberTag) {
      t when WasmI32.eq(t, Tags._GRAIN_INT32_BOXED_NUM_TAG) => {
        let yBoxedVal = boxedInt32Number(y)
        isSafeIntegerF64(x) && WasmF64.eq(x, WasmF64.convertI32S(yBoxedVal))
      },
      t when WasmI32.eq(t, Tags._GRAIN_INT64_BOXED_NUM_TAG) => {
        let yBoxedVal = boxedInt64Number(y)
        isSafeIntegerF64(x) && WasmF64.eq(x, WasmF64.convertI64S(yBoxedVal))
      },
      t when WasmI32.eq(t, Tags._GRAIN_BIGINT_BOXED_NUM_TAG) => {
        WasmI32.eqz(BI.cmpF64(y, x))
      },
      t when WasmI32.eq(t, Tags._GRAIN_RATIONAL_BOXED_NUM_TAG) => {
        let yNumerator = boxedRationalNumerator(y)
        let yDenominator = boxedRationalDenominator(y)
        let yAsFloat = WasmF64.div(
          BI.toFloat64(yNumerator),
          BI.toFloat64(yDenominator)
        )
        WasmF64.eq(x, yAsFloat)
      },
      t when WasmI32.eq(t, Tags._GRAIN_FLOAT32_BOXED_NUM_TAG) => {
        let yBoxedVal = boxedFloat32Number(y)
        // TODO(#303): maybe we should have some sort of tolerance?
        WasmF64.eq(x, WasmF64.promoteF32(yBoxedVal))
      },
      t when WasmI32.eq(t, Tags._GRAIN_FLOAT64_BOXED_NUM_TAG) => {
        let yBoxedVal = boxedFloat64Number(y)
        // TODO(#303): maybe we should have some sort of tolerance?
        WasmF64.eq(x, yBoxedVal)
      },
      _ => {
        throw UnknownNumberTag
      },
    }
  }
}

@unsafe
let numberEqualFloat32Help = (x, y) => {
  let xIsInteger = isIntegerF32(x)
  // Basic number:
  if (isSimpleNumber(y)) {
    xIsInteger && WasmF32.eq(x, WasmF32.convertI32S(untagSimple(y)))
  } else {
    // Boxed number
    let yBoxedNumberTag = boxedNumberTag(y)
    match (yBoxedNumberTag) {
      t when WasmI32.eq(t, Tags._GRAIN_FLOAT32_BOXED_NUM_TAG) => {
        // Special case: f32/f32 equality (need to handle here without promotion)
        WasmF32.eq(x, boxedFloat32Number(y))
      },
      _ => {
        numberEqualFloat64Help(WasmF64.promoteF32(x), y)
      },
    }
  }
}

@unsafe
let numberEqualBigIntHelp = (x, y) => {
  if (isSimpleNumber(y)) {
    WasmI32.eqz(BI.cmpI64(x, WasmI64.extendI32S(untagSimple(y))))
  } else {
    // Boxed number
    let yBoxedNumberTag = boxedNumberTag(y)
    match (yBoxedNumberTag) {
      t when WasmI32.eq(t, Tags._GRAIN_INT32_BOXED_NUM_TAG) => {
        let yBoxedVal = boxedInt32Number(y)
        WasmI32.eqz(BI.cmpI64(x, WasmI64.extendI32S(yBoxedVal)))
      },
      t when WasmI32.eq(t, Tags._GRAIN_INT64_BOXED_NUM_TAG) => {
        let yBoxedVal = boxedInt64Number(y)
        WasmI32.eqz(BI.cmpI64(x, yBoxedVal))
      },
      t when WasmI32.eq(t, Tags._GRAIN_BIGINT_BOXED_NUM_TAG) => {
        BI.eq(x, y)
      },
      t when WasmI32.eq(t, Tags._GRAIN_RATIONAL_BOXED_NUM_TAG) => {
        // Rationals are reduced, so it must be unequal
        false
      },
      t when WasmI32.eq(t, Tags._GRAIN_FLOAT32_BOXED_NUM_TAG) => {
        let yBoxedVal = boxedFloat32Number(y)
        WasmI32.eqz(BI.cmpF32(x, yBoxedVal))
      },
      t when WasmI32.eq(t, Tags._GRAIN_FLOAT64_BOXED_NUM_TAG) => {
        let yBoxedVal = boxedFloat64Number(y)
        WasmI32.eqz(BI.cmpF64(x, yBoxedVal))
      },
      _ => {
        throw UnknownNumberTag
      },
    }
  }
}

@unsafe
export let numberEqual = (x, y) => {
  if (isSimpleNumber(x)) {
    // Short circuit if non-pointer value is the same
    WasmI32.eq(x, y) || numberEqualSimpleHelp(x, y)
  } else {
    // Boxed number
    let xBoxedNumberTag = boxedNumberTag(x)
    match (xBoxedNumberTag) {
      t when WasmI32.eq(t, Tags._GRAIN_INT32_BOXED_NUM_TAG) => {
        let xBoxedVal = boxedInt32Number(x)
        numberEqualInt32Help(xBoxedVal, y)
      },
      t when WasmI32.eq(t, Tags._GRAIN_INT64_BOXED_NUM_TAG) => {
        let xBoxedVal = boxedInt64Number(x)
        numberEqualInt64Help(xBoxedVal, y)
      },
      t when WasmI32.eq(t, Tags._GRAIN_RATIONAL_BOXED_NUM_TAG) => {
        numberEqualRationalHelp(x, y)
      },
      t when WasmI32.eq(t, Tags._GRAIN_FLOAT32_BOXED_NUM_TAG) => {
        numberEqualFloat32Help(boxedFloat32Number(x), y)
      },
      t when WasmI32.eq(t, Tags._GRAIN_FLOAT64_BOXED_NUM_TAG) => {
        numberEqualFloat64Help(boxedFloat64Number(x), y)
      },
      t when WasmI32.eq(t, Tags._GRAIN_BIGINT_BOXED_NUM_TAG) => {
        numberEqualBigIntHelp(x, y)
      },
      _ => {
        throw UnknownNumberTag
      },
    }
  }
}

/*
 * ===== PLUS & MINUS =====
 * (same schema as equal())
 */

@unsafe
let numberAddSubSimpleHelp = (x, y, isSub) => {
  // PRECONDITION: x is a "simple" number (value tag is 0) and isNumber(y)
  if (isSimpleNumber(y)) {
    let x = WasmI64.extendI32S(untagSimple(x))
    let y = WasmI64.extendI32S(untagSimple(y))
    let result = if (isSub) {
      WasmI64.sub(x, y)
    } else {
      WasmI64.add(x, y)
    }
    reducedInteger(result)
  } else {
    let xval = untagSimple(x) // <- actual int value of x
    let yBoxedNumberTag = boxedNumberTag(y)
    match (yBoxedNumberTag) {
      t when WasmI32.eq(t, Tags._GRAIN_INT32_BOXED_NUM_TAG) => {
        let xval = WasmI64.extendI32S(xval)
        let yBoxedVal = WasmI64.extendI32S(boxedInt32Number(y))
        let result = if (isSub) WasmI64.sub(xval, yBoxedVal)
          else WasmI64.add(xval, yBoxedVal)
        reducedInteger(result)
      },
      t when WasmI32.eq(t, Tags._GRAIN_INT64_BOXED_NUM_TAG) => {
        let yBoxedVal = boxedInt64Number(y)
        let xval64 = WasmI64.extendI32S(xval)
        let result = if (isSub) WasmI64.sub(xval64, yBoxedVal)
          else WasmI64.add(xval64, yBoxedVal)
        if (
          WasmI64.geS(yBoxedVal, 0N) && WasmI64.ltS(result, xval64) ||
          WasmI64.ltS(yBoxedVal, 0N) && WasmI64.gtS(result, xval64)
        ) {
          // Overflow. Promote to BigInt
          let xBig = BI.makeWrappedInt32(xval)
          let yBig = BI.makeWrappedInt64(yBoxedVal)
          let res = if (isSub) {
            BI.sub(xBig, yBig)
          } else {
            BI.add(xBig, yBig)
          }
          Memory.decRef(xBig)
          Memory.decRef(yBig)
          reducedBigInteger(res)
        } else {
          reducedInteger(result)
        }
      },
      t when WasmI32.eq(t, Tags._GRAIN_BIGINT_BOXED_NUM_TAG) => {
        // Promote x to bigint and do operation
        let xBig = BI.makeWrappedInt32(xval)
        let result = if (isSub) BI.sub(xBig, y) else BI.add(xBig, y)
        Memory.decRef(xBig)
        reducedBigInteger(result)
      },
      t when WasmI32.eq(t, Tags._GRAIN_RATIONAL_BOXED_NUM_TAG) => {
        let xBig = BI.makeWrappedInt32(xval)
        let yNumerator = boxedRationalNumerator(y)
        let yDenominator = boxedRationalDenominator(y)
        let expandedXNumerator = BI.mul(xBig, yDenominator)
        Memory.decRef(xBig)
        let result = if (isSub) BI.sub(expandedXNumerator, yNumerator)
          else BI.add(expandedXNumerator, yNumerator)
        let ret = reducedFractionBigInt(result, yDenominator)
        Memory.decRef(expandedXNumerator)
        Memory.decRef(result)
        ret
      },
      t when WasmI32.eq(t, Tags._GRAIN_FLOAT32_BOXED_NUM_TAG) => {
        let yBoxedVal = boxedFloat32Number(y)
        let xval = WasmF32.convertI32S(xval)
        let result = if (isSub) WasmF32.sub(xval, yBoxedVal)
          else WasmF32.add(xval, yBoxedVal)
        // TODO(#304): is this safe?
        newFloat32(result)
      },
      t when WasmI32.eq(t, Tags._GRAIN_FLOAT64_BOXED_NUM_TAG) => {
        let yBoxedVal = boxedFloat64Number(y)
        let xval = WasmF64.convertI32S(xval)
        let result = if (isSub) WasmF64.sub(xval, yBoxedVal)
          else WasmF64.add(xval, yBoxedVal)
        newFloat64(result)
      },
      _ => {
        throw UnknownNumberTag
      },
    }
  }
}

@unsafe
let numberAddSubInt64Help = (xval, y, isSub) => {
  if (isSimpleNumber(y)) {
    let yval = WasmI64.extendI32S(untagSimple(y))
    let result = if (isSub) WasmI64.sub(xval, yval) else WasmI64.add(xval, yval)
    if (
      WasmI64.geS(yval, 0N) && WasmI64.ltS(result, xval) ||
      WasmI64.ltS(yval, 0N) && WasmI64.gtS(result, xval)
    ) {
      // Overflow. Promote to BigInt
      let xBig = BI.makeWrappedInt64(xval)
      let yBig = BI.makeWrappedInt64(yval)
      let res = if (isSub) {
        BI.sub(xBig, yBig)
      } else {
        BI.add(xBig, yBig)
      }
      Memory.decRef(xBig)
      Memory.decRef(yBig)
      reducedBigInteger(res)
    } else {
      reducedInteger(result)
    }
  } else {
    let yBoxedNumberTag = boxedNumberTag(y)
    match (yBoxedNumberTag) {
      t when WasmI32.eq(t, Tags._GRAIN_INT32_BOXED_NUM_TAG) => {
        let yBoxedVal = WasmI64.extendI32S(boxedInt32Number(y))
        let result = if (isSub) WasmI64.sub(xval, yBoxedVal)
          else WasmI64.add(xval, yBoxedVal)
        reducedInteger(result)
      },
      t when WasmI32.eq(t, Tags._GRAIN_INT64_BOXED_NUM_TAG) => {
        let yBoxedVal = boxedInt64Number(y)
        let xval64 = xval
        let result = if (isSub) WasmI64.sub(xval64, yBoxedVal)
          else WasmI64.add(xval64, yBoxedVal)
        if (
          WasmI64.geS(yBoxedVal, 0N) && WasmI64.ltS(result, xval64) ||
          WasmI64.ltS(yBoxedVal, 0N) && WasmI64.gtS(result, xval64)
        ) {
          // Overflow. Promote to BigInt
          let xBig = BI.makeWrappedInt64(xval64)
          let yBig = BI.makeWrappedInt64(yBoxedVal)
          let res = if (isSub) {
            BI.sub(xBig, yBig)
          } else {
            BI.add(xBig, yBig)
          }
          Memory.decRef(xBig)
          Memory.decRef(yBig)
          reducedBigInteger(res)
        } else {
          reducedInteger(result)
        }
      },
      t when WasmI32.eq(t, Tags._GRAIN_BIGINT_BOXED_NUM_TAG) => {
        // Promote x to bigint and do operation
        let xBig = BI.makeWrappedInt64(xval)
        let result = if (isSub) BI.sub(xBig, y) else BI.add(xBig, y)
        Memory.decRef(xBig)
        reducedBigInteger(result)
      },
      t when WasmI32.eq(t, Tags._GRAIN_RATIONAL_BOXED_NUM_TAG) => {
        let xBig = BI.makeWrappedInt64(xval)
        let yNumerator = boxedRationalNumerator(y)
        let yDenominator = boxedRationalDenominator(y)
        let expandedXNumerator = BI.mul(xBig, yDenominator)
        Memory.decRef(xBig)
        let result = if (isSub) BI.sub(expandedXNumerator, yNumerator)
          else BI.add(expandedXNumerator, yNumerator)
        let ret = reducedFractionBigInt(result, yDenominator)
        Memory.decRef(expandedXNumerator)
        Memory.decRef(result)
        ret
      },
      t when WasmI32.eq(t, Tags._GRAIN_FLOAT32_BOXED_NUM_TAG) => {
        let xval = WasmF32.convertI64S(xval)
        let yBoxedVal = boxedFloat32Number(y)
        let result = if (isSub) WasmF32.sub(xval, yBoxedVal)
          else WasmF32.add(xval, yBoxedVal)
        // TODO(#304): this isn't safe enough
        newFloat32(result)
      },
      t when WasmI32.eq(t, Tags._GRAIN_FLOAT64_BOXED_NUM_TAG) => {
        let xval = WasmF64.convertI64S(xval)
        let yBoxedVal = boxedFloat64Number(y)
        let result = if (isSub) WasmF64.sub(xval, yBoxedVal)
          else WasmF64.add(xval, yBoxedVal)
        newFloat64(result)
      },
      _ => {
        throw UnknownNumberTag
      },
    }
  }
}

@unsafe
let numberAddSubFloat32Help = (xval, y, isSub) => {
  if (
    !isSimpleNumber(y) &&
    WasmI32.eq(boxedNumberTag(y), Tags._GRAIN_FLOAT64_BOXED_NUM_TAG)
  ) {
    // Special case: promote to f64 if RHS is f64
    let xval = WasmF64.promoteF32(xval)
    let yval = boxedFloat64Number(y)
    let result = if (isSub) WasmF64.sub(xval, yval) else WasmF64.add(xval, yval)
    newFloat64(result)
  } else {
    // incRef y to reuse it via WasmI32.toGrain
    Memory.incRef(y)
    let yval = coerceNumberToWasmF32(WasmI32.toGrain(y): Number)
    let result = if (isSub) WasmF32.sub(xval, yval) else WasmF32.add(xval, yval)
    newFloat32(result)
  }
}

@unsafe
let numberAddSubFloat64Help = (xval, y, isSub) => {
  // incRef y to reuse it via WasmI32.toGrain
  Memory.incRef(y)
  let yval = coerceNumberToWasmF64(WasmI32.toGrain(y): Number)
  let result = if (isSub) WasmF64.sub(xval, yval) else WasmF64.add(xval, yval)
  newFloat64(result)
}

@unsafe
let numberAddSubInt32Help = (xval, y, isSub) => {
  numberAddSubInt64Help(WasmI64.extendI32S(xval), y, isSub)
}

@unsafe
let numberAddSubBigIntHelp = (x, y, isSub) => {
  if (isSimpleNumber(y)) {
    let yval = WasmI64.extendI32S(untagSimple(y))
    let yBig = BI.makeWrappedInt64(yval)
    let res = if (isSub) {
      BI.sub(x, yBig)
    } else {
      BI.add(x, yBig)
    }
    Memory.decRef(yBig)
    reducedBigInteger(res)
  } else {
    let yBoxedNumberTag = boxedNumberTag(y)
    match (yBoxedNumberTag) {
      t when WasmI32.eq(t, Tags._GRAIN_INT32_BOXED_NUM_TAG) => {
        let yBoxedVal = WasmI64.extendI32S(boxedInt32Number(y))
        let yBig = BI.makeWrappedInt64(yBoxedVal)
        let res = if (isSub) {
          BI.sub(x, yBig)
        } else {
          BI.add(x, yBig)
        }
        Memory.decRef(yBig)
        reducedBigInteger(res)
      },
      t when WasmI32.eq(t, Tags._GRAIN_INT64_BOXED_NUM_TAG) => {
        let yBoxedVal = boxedInt64Number(y)
        let yBig = BI.makeWrappedInt64(yBoxedVal)
        let res = if (isSub) {
          BI.sub(x, yBig)
        } else {
          BI.add(x, yBig)
        }
        Memory.decRef(yBig)
        reducedBigInteger(res)
      },
      t when WasmI32.eq(t, Tags._GRAIN_BIGINT_BOXED_NUM_TAG) => {
        let res = if (isSub) {
          BI.sub(x, y)
        } else {
          BI.add(x, y)
        }
        reducedBigInteger(res)
      },
      t when WasmI32.eq(t, Tags._GRAIN_RATIONAL_BOXED_NUM_TAG) => {
        let yNumerator = boxedRationalNumerator(y)
        let yDenominator = boxedRationalDenominator(y)
        let expandedXNumerator = BI.mul(x, yDenominator)
        let result = if (isSub) BI.sub(expandedXNumerator, yNumerator)
          else BI.add(expandedXNumerator, yNumerator)
        Memory.decRef(expandedXNumerator)
        let ret = reducedFractionBigInt(result, yDenominator)
        Memory.decRef(result)
        ret
      },
      t when WasmI32.eq(t, Tags._GRAIN_FLOAT32_BOXED_NUM_TAG) => {
        let xval = BI.toFloat32(x)
        let yBoxedVal = boxedFloat32Number(y)
        let result = if (isSub) WasmF32.sub(xval, yBoxedVal)
          else WasmF32.add(xval, yBoxedVal)
        // TODO(#304): this isn't safe enough
        newFloat32(result)
      },
      t when WasmI32.eq(t, Tags._GRAIN_FLOAT64_BOXED_NUM_TAG) => {
        let xval = BI.toFloat64(x)
        let yBoxedVal = boxedFloat64Number(y)
        let result = if (isSub) WasmF64.sub(xval, yBoxedVal)
          else WasmF64.add(xval, yBoxedVal)
        newFloat64(result)
      },
      _ => {
        throw UnknownNumberTag
      },
    }
  }
}

@unsafe
let numberAddSubRationalHelp = (x, y, isSub) => {
  let xNumerator = boxedRationalNumerator(x)
  let xDenominator = boxedRationalDenominator(x)
  if (isSimpleNumber(y)) {
    let yval = untagSimple(y)
    let yBig = BI.makeWrappedInt32(yval)
    let expandedYNumerator = BI.mul(xDenominator, yBig)
    let result = if (isSub) BI.sub(xNumerator, expandedYNumerator)
      else BI.add(xNumerator, expandedYNumerator)
    Memory.decRef(expandedYNumerator)
    Memory.decRef(yBig)
    let ret = reducedFractionBigInt(result, xDenominator)
    Memory.decRef(result)
    ret
  } else {
    let ytag = boxedNumberTag(y)
    match (ytag) {
      t when WasmI32.eq(t, Tags._GRAIN_RATIONAL_BOXED_NUM_TAG) => {
        // The one case we don't delegate is rational +/- rational
        let xNumerator = boxedRationalNumerator(x)
        let xDenominator = boxedRationalDenominator(x)
        let yNumerator = boxedRationalNumerator(y)
        let yDenominator = boxedRationalDenominator(y)
        if (BI.eq(xDenominator, yDenominator)) {
          let newNumerator = if (isSub) BI.sub(xNumerator, yNumerator)
            else BI.add(xNumerator, yNumerator)
          let ret = reducedFractionBigInt(newNumerator, xDenominator)
          Memory.decRef(newNumerator)
          ret
        } else {
          let numerator1 = BI.mul(xNumerator, yDenominator)
          let numerator2 = BI.mul(yNumerator, xDenominator)
          let numerator = if (isSub) BI.sub(numerator1, numerator2)
            else BI.add(numerator1, numerator2)
          let denominator = BI.mul(xDenominator, yDenominator)
          let ret = reducedFractionBigInt(numerator, denominator)
          Memory.decRef(numerator1)
          Memory.decRef(numerator2)
          Memory.decRef(numerator)
          ret
        }
      },
      t when WasmI32.eq(t, Tags._GRAIN_INT32_BOXED_NUM_TAG) => {
        let yBig = BI.makeWrappedInt32(boxedInt32Number(y))
        let expandedYNumerator = BI.mul(yBig, xDenominator)
        Memory.decRef(yBig)
        let result = if (isSub) BI.sub(xNumerator, expandedYNumerator)
          else BI.add(xNumerator, expandedYNumerator)
        let ret = reducedFractionBigInt(result, xDenominator)
        Memory.decRef(expandedYNumerator)
        Memory.decRef(result)
        ret
      },
      t when WasmI32.eq(t, Tags._GRAIN_INT64_BOXED_NUM_TAG) => {
        let yBig = BI.makeWrappedInt64(boxedInt64Number(y))
        let expandedYNumerator = BI.mul(yBig, xDenominator)
        Memory.decRef(yBig)
        let result = if (isSub) BI.sub(xNumerator, expandedYNumerator)
          else BI.add(xNumerator, expandedYNumerator)
        let ret = reducedFractionBigInt(result, xDenominator)
        Memory.decRef(expandedYNumerator)
        Memory.decRef(result)
        ret
      },
      t when WasmI32.eq(t, Tags._GRAIN_BIGINT_BOXED_NUM_TAG) => {
        let expandedYNumerator = BI.mul(xDenominator, y)
        let result = if (isSub) BI.sub(xNumerator, expandedYNumerator)
          else BI.add(xNumerator, expandedYNumerator)
        Memory.decRef(expandedYNumerator)
        let ret = reducedFractionBigInt(result, xDenominator)
        Memory.decRef(result)
        ret
      },
      t when WasmI32.eq(t, Tags._GRAIN_FLOAT32_BOXED_NUM_TAG) => {
        let xval = WasmF32.div(
          BI.toFloat32(xNumerator),
          BI.toFloat32(xDenominator)
        )
        let result = if (isSub) WasmF32.sub(xval, boxedFloat32Number(y))
          else WasmF32.add(xval, boxedFloat32Number(y))
        newFloat32(result)
      },
      t when WasmI32.eq(t, Tags._GRAIN_FLOAT64_BOXED_NUM_TAG) => {
        let xnumfloat = BI.toFloat64(xNumerator)
        let xdenfloat = BI.toFloat64(xDenominator)
        let xval = WasmF64.div(xnumfloat, xdenfloat)
        let yval = boxedFloat64Number(y)
        let result = if (isSub) WasmF64.sub(xval, yval)
          else WasmF64.add(xval, yval)
        let ret = newFloat64(result)
        ret
      },
      _ => {
        throw UnknownNumberTag
      },
    }
  }
}

@unsafe
let numberAddSubHelp = (x, y, isSub) => {
  if (isSimpleNumber(x)) {
    numberAddSubSimpleHelp(x, y, isSub)
  } else {
    let xtag = boxedNumberTag(x)
    match (xtag) {
      t when WasmI32.eq(t, Tags._GRAIN_INT32_BOXED_NUM_TAG) => {
        numberAddSubInt32Help(boxedInt32Number(x), y, isSub)
      },
      t when WasmI32.eq(t, Tags._GRAIN_INT64_BOXED_NUM_TAG) => {
        numberAddSubInt64Help(boxedInt64Number(x), y, isSub)
      },
      t when WasmI32.eq(t, Tags._GRAIN_BIGINT_BOXED_NUM_TAG) => {
        numberAddSubBigIntHelp(x, y, isSub)
      },
      t when WasmI32.eq(t, Tags._GRAIN_RATIONAL_BOXED_NUM_TAG) => {
        numberAddSubRationalHelp(x, y, isSub)
      },
      t when WasmI32.eq(t, Tags._GRAIN_FLOAT32_BOXED_NUM_TAG) => {
        numberAddSubFloat32Help(boxedFloat32Number(x), y, isSub)
      },
      t when WasmI32.eq(t, Tags._GRAIN_FLOAT64_BOXED_NUM_TAG) => {
        numberAddSubFloat64Help(boxedFloat64Number(x), y, isSub)
      },
      _ => {
        throw UnknownNumberTag
      },
    }
  }
}

@unsafe
let numberAdd = (x, y) => {
  WasmI32.toGrain(numberAddSubHelp(x, y, false)): Number
}

@unsafe
let numberSub = (x, y) => {
  WasmI32.toGrain(numberAddSubHelp(x, y, true)): Number
}

/*
 * ===== TIMES & DIVIDE =====
 * (same schema as equal())
 */

@unsafe
let safeI64Multiply = (x, y) => {
  let prod = WasmI64.mul(x, y)
  if (WasmI64.ne(x, 0N)) {
    if (WasmI64.ne(WasmI64.divS(prod, x), y)) {
      let xBig = BI.makeWrappedInt64(x)
      let yBig = BI.makeWrappedInt64(y)
      let result = BI.mul(xBig, yBig)
      Memory.decRef(xBig)
      Memory.decRef(yBig)
      result
    } else {
      reducedInteger(prod)
    }
  } else {
    reducedInteger(prod)
  }
}

@unsafe
let numberTimesDivideInt64Help = (xval, y, isDivide) => {
  if (isSimpleNumber(y)) {
    if (isDivide) {
      reducedFraction64(xval, WasmI64.extendI32S(untagSimple(y)))
    } else {
      safeI64Multiply(xval, WasmI64.extendI32S(untagSimple(y)))
    }
  } else {
    let yBoxedNumberTag = boxedNumberTag(y)
    match (yBoxedNumberTag) {
      t when WasmI32.eq(t, Tags._GRAIN_INT32_BOXED_NUM_TAG) => {
        let yBoxedVal = WasmI64.extendI32S(boxedInt32Number(y))
        if (isDivide) {
          reducedFraction64(xval, yBoxedVal)
        } else {
          safeI64Multiply(xval, yBoxedVal)
        }
      },
      t when WasmI32.eq(t, Tags._GRAIN_INT64_BOXED_NUM_TAG) => {
        let yBoxedVal = boxedInt64Number(y)
        if (isDivide) {
          reducedFraction64(xval, yBoxedVal)
        } else {
          safeI64Multiply(xval, yBoxedVal)
        }
      },
      t when WasmI32.eq(t, Tags._GRAIN_BIGINT_BOXED_NUM_TAG) => {
        let xBig = BI.makeWrappedInt64(xval)
        let ret = if (isDivide) {
          reducedFractionBigInt(xBig, y)
        } else {
          reducedBigInteger(BI.mul(xBig, y))
        }
        Memory.decRef(xBig)
        ret
      },
      t when WasmI32.eq(t, Tags._GRAIN_RATIONAL_BOXED_NUM_TAG) => {
        let yNumerator = boxedRationalNumerator(y)
        let yDenominator = boxedRationalDenominator(y)
        let xBig = BI.makeWrappedInt64(xval)
        let ret = if (isDivide) {
          // x / (a / b) == (x * b) / a
          let numerator = BI.mul(xBig, yDenominator)
          let ret = reducedFractionBigInt(numerator, yNumerator)
          Memory.decRef(numerator)
          ret
        } else {
          // x * (a / b) == (x * a) / b
          let numerator = BI.mul(xBig, yNumerator)
          let ret = reducedFractionBigInt(numerator, yDenominator)
          Memory.decRef(numerator)
          ret
        }
        Memory.decRef(xBig)
        ret
      },
      t when WasmI32.eq(t, Tags._GRAIN_FLOAT32_BOXED_NUM_TAG) => {
        let xval = WasmF32.convertI64S(xval)
        let yBoxedVal = boxedFloat32Number(y)
        // TODO(#304): is this safe?
        if (isDivide) {
          newFloat32(WasmF32.div(xval, yBoxedVal))
        } else {
          newFloat32(WasmF32.mul(xval, yBoxedVal))
        }
      },
      t when WasmI32.eq(t, Tags._GRAIN_FLOAT64_BOXED_NUM_TAG) => {
        let xval = WasmF64.convertI64S(xval)
        let yBoxedVal = boxedFloat64Number(y)
        if (isDivide) {
          newFloat64(WasmF64.div(xval, yBoxedVal))
        } else {
          newFloat64(WasmF64.mul(xval, yBoxedVal))
        }
      },
      _ => {
        throw UnknownNumberTag
      },
    }
  }
}

@unsafe
let numberTimesDivideBigIntHelp = (x, y, isDivide) => {
  if (isSimpleNumber(y)) {
    let yBig = BI.makeWrappedInt32(untagSimple(y))
    let ret = if (isDivide) {
      reducedFractionBigInt(x, yBig)
    } else {
      reducedBigInteger(BI.mul(x, yBig))
    }
    Memory.decRef(yBig)
    ret
  } else {
    let yBoxedNumberTag = boxedNumberTag(y)
    match (yBoxedNumberTag) {
      t when WasmI32.eq(t, Tags._GRAIN_INT32_BOXED_NUM_TAG) => {
        let yBoxedVal = WasmI64.extendI32S(boxedInt32Number(y))
        let yBig = BI.makeWrappedInt64(yBoxedVal)
        let ret = if (isDivide) {
          reducedFractionBigInt(x, yBig)
        } else {
          reducedBigInteger(BI.mul(x, yBig))
        }
        Memory.decRef(yBig)
        ret
      },
      t when WasmI32.eq(t, Tags._GRAIN_INT64_BOXED_NUM_TAG) => {
        let yBoxedVal = boxedInt64Number(y)
        let yBig = BI.makeWrappedInt64(yBoxedVal)
        let ret = if (isDivide) {
          reducedFractionBigInt(x, yBig)
        } else {
          reducedBigInteger(BI.mul(x, yBig))
        }
        Memory.decRef(yBig)
        ret
      },
      t when WasmI32.eq(t, Tags._GRAIN_RATIONAL_BOXED_NUM_TAG) => {
        let yNumerator = boxedRationalNumerator(y)
        let yDenominator = boxedRationalDenominator(y)
        if (isDivide) {
          // x / (a / b) == (x * b) / a
          let numerator = BI.mul(x, yDenominator)
          let ret = reducedFractionBigInt(numerator, yNumerator)
          Memory.decRef(numerator)
          ret
        } else {
          // x * (a / b) == (x * a) / b
          let numerator = BI.mul(x, yNumerator)
          let ret = reducedFractionBigInt(numerator, yDenominator)
          Memory.decRef(numerator)
          ret
        }
      },
      t when WasmI32.eq(t, Tags._GRAIN_FLOAT32_BOXED_NUM_TAG) => {
        // We make the decision to always promote to f64 here, since
        // we can only fit rather small bigints (<4 limbs) into an F32
        let xval = BI.toFloat64(x)
        let yBoxedVal = WasmF64.promoteF32(boxedFloat32Number(y))
        // TODO(#304): is this safe?
        if (isDivide) {
          newFloat64(WasmF64.div(xval, yBoxedVal))
        } else {
          newFloat64(WasmF64.mul(xval, yBoxedVal))
        }
      },
      t when WasmI32.eq(t, Tags._GRAIN_FLOAT64_BOXED_NUM_TAG) => {
        let xval = BI.toFloat64(x)
        let yBoxedVal = boxedFloat64Number(y)
        if (isDivide) {
          newFloat64(WasmF64.div(xval, yBoxedVal))
        } else {
          newFloat64(WasmF64.mul(xval, yBoxedVal))
        }
      },
      _ => {
        throw UnknownNumberTag
      },
    }
  }
}

@unsafe
let numberTimesDivideSimpleHelp = (x, y, isDivide) => {
  // PRECONDITION: x is a "simple" number (value tag is 0) and isNumber(y)
  let xval = untagSimple(x) // <- actual int value of x
  numberTimesDivideInt64Help(WasmI64.extendI32S(xval), y, isDivide)
}

@unsafe
let numberTimesDivideInt32Help = (xval, y, isDivide) => {
  numberTimesDivideInt64Help(WasmI64.extendI32S(xval), y, isDivide)
}

@unsafe
let numberTimesDivideRationalHelp = (x, y, isDivide) => {
  // Division isn't commutative, so we actually need to do the work
  let xNumerator = boxedRationalNumerator(x)
  let xDenominator = boxedRationalDenominator(x)
  if (isSimpleNumber(y)) {
    let yBig = BI.makeWrappedInt32(untagSimple(y))
    let ret = if (isDivide) {
      // (a / b) / y == a / (b * y)
      let denominator = BI.mul(xDenominator, yBig)
      let ret = reducedFractionBigInt(xNumerator, denominator)
      Memory.decRef(denominator)
      ret
    } else {
      // (a / b) * y == (a * y) / b
      let numerator = BI.mul(xNumerator, yBig)
      let ret = reducedFractionBigInt(numerator, xDenominator)
      Memory.decRef(numerator)
      ret
    }
    if (WasmI32.ne(yBig, ret)) {
      Memory.decRef(yBig)
      void
    }
    ret
  } else {
    let ytag = boxedNumberTag(y)
    match (ytag) {
      t when WasmI32.eq(t, Tags._GRAIN_INT32_BOXED_NUM_TAG) => {
        // Same idea as above
        let yBig = BI.makeWrappedInt32(boxedInt32Number(y))
        let ret = if (isDivide) {
          // (a / b) / y == a / (b * y)
          let denominator = BI.mul(xDenominator, yBig)
          let ret = reducedFractionBigInt(xNumerator, denominator)
          Memory.decRef(denominator)
          ret
        } else {
          // (a / b) * y == (a * y) / b
          let numerator = BI.mul(xNumerator, yBig)
          let ret = reducedFractionBigInt(numerator, xDenominator)
          Memory.decRef(numerator)
          ret
        }
        Memory.decRef(yBig)
        ret
      },
      t when WasmI32.eq(t, Tags._GRAIN_INT64_BOXED_NUM_TAG) => {
        // Same idea as above
        let yBig = BI.makeWrappedInt64(boxedInt64Number(y))
        let ret = if (isDivide) {
          // (a / b) / y == a / (b * y)
          let denominator = BI.mul(xDenominator, yBig)
          let ret = reducedFractionBigInt(xNumerator, denominator)
          Memory.decRef(denominator)
          ret
        } else {
          // (a / b) * y == (a * y) / b
          let numerator = BI.mul(xNumerator, yBig)
          let ret = reducedFractionBigInt(numerator, xDenominator)
          Memory.decRef(numerator)
          ret
        }
        Memory.decRef(yBig)
        ret
      },
      t when WasmI32.eq(t, Tags._GRAIN_BIGINT_BOXED_NUM_TAG) => {
        if (isDivide) {
          // (a / b) / y == a / (b * y)
          let denominator = BI.mul(xDenominator, y)
          let ret = reducedFractionBigInt(xNumerator, denominator)
          Memory.decRef(denominator)
          ret
        } else {
          // (a / b) * y == (a * y) / b
          let numerator = BI.mul(xNumerator, y)
          let ret = reducedFractionBigInt(numerator, xDenominator)
          Memory.decRef(numerator)
          ret
        }
      },
      t when WasmI32.eq(t, Tags._GRAIN_RATIONAL_BOXED_NUM_TAG) => {
        let xNumerator = boxedRationalNumerator(x)
        let xDenominator = boxedRationalDenominator(x)
        let yNumerator = boxedRationalNumerator(y)
        let yDenominator = boxedRationalDenominator(y)
        // (a / b) * (c / d) == (a * c) / (b * d)
        // (a / b) / (c / d) == (a * d) / (b * c)
        // TODO(#304): this could maybe be written in a more overflow-proof way
        let numerator = if (isDivide) BI.mul(xNumerator, yDenominator)
          else BI.mul(xNumerator, yNumerator)
        let denominator = if (isDivide) BI.mul(xDenominator, yNumerator)
          else BI.mul(xDenominator, yDenominator)
        reducedFractionBigInt(numerator, denominator)
      },
      t when WasmI32.eq(t, Tags._GRAIN_FLOAT32_BOXED_NUM_TAG) => {
        // TODO(#1190): We should probably use something more accurate if possible here
        let asFloat = WasmF32.demoteF64(
          WasmF64.div(BI.toFloat64(xNumerator), BI.toFloat64(xDenominator))
        )
        if (isDivide) {
          newFloat32(WasmF32.div(asFloat, boxedFloat32Number(y)))
        } else {
          newFloat32(WasmF32.mul(asFloat, boxedFloat32Number(y)))
        }
      },
      t when WasmI32.eq(t, Tags._GRAIN_FLOAT64_BOXED_NUM_TAG) => {
        // TODO(#1190): We should probably use something more accurate if possible here
        let asFloat = WasmF64.div(
          BI.toFloat64(xNumerator),
          BI.toFloat64(xDenominator)
        )
        if (isDivide) {
          newFloat64(WasmF64.div(asFloat, boxedFloat64Number(y)))
        } else {
          newFloat64(WasmF64.mul(asFloat, boxedFloat64Number(y)))
        }
      },
      _ => {
        throw UnknownNumberTag
      },
    }
  }
}

@unsafe
let numberTimesDivideFloat64Help = (x, y, isDivide) => {
  // incRef y to reuse it via WasmI32.toGrain
  Memory.incRef(y)
  let yAsFloat = coerceNumberToWasmF64(WasmI32.toGrain(y): Number)
  if (isDivide) {
    newFloat64(WasmF64.div(x, yAsFloat))
  } else {
    newFloat64(WasmF64.mul(x, yAsFloat))
  }
}

@unsafe
let numberTimesDivideFloat32Help = (x, y, isDivide) => {
  if (
    isBoxedNumber(y) &&
    WasmI32.eq(boxedNumberTag(y), Tags._GRAIN_INT64_BOXED_NUM_TAG)
  ) {
    // Special case: f32->f64 promotion
    if (isDivide) {
      newFloat64(WasmF64.div(WasmF64.promoteF32(x), boxedFloat64Number(y)))
    } else {
      newFloat64(WasmF64.mul(WasmF64.promoteF32(x), boxedFloat64Number(y)))
    }
  } else {
    // incRef y to reuse it via WasmI32.toGrain
    Memory.incRef(y)
    let yAsFloat = coerceNumberToWasmF32(WasmI32.toGrain(y): Number)
    if (isDivide) {
      newFloat32(WasmF32.div(x, yAsFloat))
    } else {
      newFloat32(WasmF32.mul(x, yAsFloat))
    }
  }
}

@unsafe
let numberTimesDivideHelp = (x, y, isDivide) => {
  if (isSimpleNumber(x)) {
    numberTimesDivideSimpleHelp(x, y, isDivide)
  } else {
    let xtag = boxedNumberTag(x)
    match (xtag) {
      t when WasmI32.eq(t, Tags._GRAIN_INT32_BOXED_NUM_TAG) => {
        numberTimesDivideInt32Help(boxedInt32Number(x), y, isDivide)
      },
      t when WasmI32.eq(t, Tags._GRAIN_INT64_BOXED_NUM_TAG) => {
        numberTimesDivideInt64Help(boxedInt64Number(x), y, isDivide)
      },
      t when WasmI32.eq(t, Tags._GRAIN_BIGINT_BOXED_NUM_TAG) => {
        numberTimesDivideBigIntHelp(x, y, isDivide)
      },
      t when WasmI32.eq(t, Tags._GRAIN_RATIONAL_BOXED_NUM_TAG) => {
        numberTimesDivideRationalHelp(x, y, isDivide)
      },
      t when WasmI32.eq(t, Tags._GRAIN_FLOAT32_BOXED_NUM_TAG) => {
        numberTimesDivideFloat32Help(boxedFloat32Number(x), y, isDivide)
      },
      t when WasmI32.eq(t, Tags._GRAIN_FLOAT64_BOXED_NUM_TAG) => {
        numberTimesDivideFloat64Help(boxedFloat64Number(x), y, isDivide)
      },
      _ => {
        throw UnknownNumberTag
      },
    }
  }
}

@unsafe
let numberTimes = (x, y) => {
  WasmI32.toGrain(numberTimesDivideHelp(x, y, false)): Number
}

@unsafe
let numberDivide = (x, y) => {
  WasmI32.toGrain(numberTimesDivideHelp(x, y, true)): Number
}

/*
 * ===== MODULO =====
 * (same schema as equal())
 */

@unsafe
let i64abs = x => if (WasmI64.geS(x, 0N)) x else WasmI64.sub(0N, x)

@unsafe
let numberMod = (x, y) => {
  // incRef x and y to reuse them via WasmI32.toGrain
  Memory.incRef(x)
  Memory.incRef(y)
  let xval = coerceNumberToWasmI64(WasmI32.toGrain(x): Number)
  let yval = coerceNumberToWasmI64(WasmI32.toGrain(y): Number)
  if (WasmI64.eqz(yval)) {
    throw Exception.ModuloByZero
  }
  // We implement true modulo
  if (
    WasmI64.ltS(xval, 0N) && WasmI64.gtS(yval, 0N) ||
    WasmI64.gtS(xval, 0N) && WasmI64.ltS(yval, 0N)
  ) {
    let modval = WasmI64.remS(i64abs(xval), i64abs(yval))
    let result = if (WasmI64.ne(modval, 0N))
        WasmI64.mul(
          WasmI64.sub(i64abs(yval), modval),
          if (WasmI64.ltS(yval, 0N)) -1N else 1N
        ) else modval
    reducedInteger(result)
  } else {
    reducedInteger(WasmI64.remS(xval, yval))
  }
}

/*
 * ===== COMPARISONS =====
 * Int/int and float/float comparisons are always accurate.
 * Rational/rational comparisons are approximations with the exception of
 * equality, which is always accurate.
 * 
 * Values compared to floats or rationals are first converted to floats.
 * 
 * All comparison operators consider NaN not equal to, less than, or greater
 * than NaN, with the exception of `compare`, which considers NaN equal to
 * itself and otherwise smaller than any other float value. This provides a
 * total order (https://en.wikipedia.org/wiki/Total_order) over all numerical
 * values, making `compare` suitable for sorting or ordering.
 */

@unsafe
let cmpBigInt = (x: WasmI32, y: WasmI32) => {
  if (isSimpleNumber(y)) {
    BI.cmpI64(x, WasmI64.extendI32S(untagSimple(y)))
  } else {
    let yBoxedNumberTag = boxedNumberTag(y)
    match (yBoxedNumberTag) {
      t when WasmI32.eq(t, Tags._GRAIN_INT32_BOXED_NUM_TAG) => {
        BI.cmpI64(x, WasmI64.extendI32S(boxedInt32Number(y)))
      },
      t when WasmI32.eq(t, Tags._GRAIN_INT64_BOXED_NUM_TAG) => {
        BI.cmpI64(x, boxedInt64Number(y))
      },
      t when WasmI32.eq(t, Tags._GRAIN_BIGINT_BOXED_NUM_TAG) => {
        BI.cmp(x, y)
      },
      t when WasmI32.eq(t, Tags._GRAIN_RATIONAL_BOXED_NUM_TAG) => {
        let tmp = BI.mul(x, boxedRationalDenominator(y))
        let ret = BI.cmp(tmp, boxedRationalNumerator(y))
        Memory.decRef(tmp)
        ret
      },
      t when WasmI32.eq(t, Tags._GRAIN_FLOAT32_BOXED_NUM_TAG) => {
        BI.cmpF32(x, boxedFloat32Number(y))
      },
      t when WasmI32.eq(t, Tags._GRAIN_FLOAT64_BOXED_NUM_TAG) => {
        BI.cmpF64(x, boxedFloat64Number(y))
      },
      _ => {
        throw UnknownNumberTag
      },
    }
  }
}

@unsafe
let cmpFloat = (x: WasmI32, y: WasmI32, is64: Bool, totalOrdering: Bool) => {
  let xf = if (is64) {
    boxedFloat64Number(x)
  } else {
    WasmF64.promoteF32(boxedFloat32Number(x))
  }
  if (isSimpleNumber(y)) {
    let yf = WasmF64.convertI32S(untagSimple(y))
    // special NaN cases
    if (totalOrdering && WasmF64.ne(xf, xf)) {
      if (WasmF64.ne(yf, yf)) {
        0n
      } else {
        -1n
      }
    } else if (totalOrdering && WasmF64.ne(yf, yf)) {
      if (WasmF64.ne(xf, xf)) {
        0n
      } else {
        1n
      }
    } else {
      if (WasmF64.lt(xf, yf)) -1n else if (WasmF64.gt(xf, yf)) 1n else 0n
    }
  } else {
    let yBoxedNumberTag = boxedNumberTag(y)
    if (yBoxedNumberTag == Tags._GRAIN_BIGINT_BOXED_NUM_TAG) {
      WasmI32.sub(0n, cmpBigInt(y, x))
    } else {
      let yf = match (yBoxedNumberTag) {
        t when WasmI32.eq(t, Tags._GRAIN_INT32_BOXED_NUM_TAG) => {
          WasmF64.convertI32S(boxedInt32Number(y))
        },
        t when WasmI32.eq(t, Tags._GRAIN_INT64_BOXED_NUM_TAG) => {
          WasmF64.convertI64S(boxedInt64Number(y))
        },
        t when WasmI32.eq(t, Tags._GRAIN_BIGINT_BOXED_NUM_TAG) => {
          throw InvariantViolation
        },
        t when WasmI32.eq(t, Tags._GRAIN_RATIONAL_BOXED_NUM_TAG) => {
          WasmF64.div(
            BI.toFloat64(boxedRationalNumerator(y)),
            BI.toFloat64(boxedRationalDenominator(y))
          )
        },
        t when WasmI32.eq(t, Tags._GRAIN_FLOAT32_BOXED_NUM_TAG) => {
          WasmF64.promoteF32(boxedFloat32Number(y))
        },
        t when WasmI32.eq(t, Tags._GRAIN_FLOAT64_BOXED_NUM_TAG) => {
          boxedFloat64Number(y)
        },
        _ => {
          throw UnknownNumberTag
        },
      }
      // special NaN cases
      if (totalOrdering && WasmF64.ne(xf, xf)) {
        if (WasmF64.ne(yf, yf)) {
          0n
        } else {
          -1n
        }
      } else if (totalOrdering && WasmF64.ne(yf, yf)) {
        if (WasmF64.ne(xf, xf)) {
          0n
        } else {
          1n
        }
      } else {
        if (WasmF64.lt(xf, yf)) -1n else if (WasmF64.gt(xf, yf)) 1n else 0n
      }
    }
  }
}

@unsafe
let cmpSmallInt = (x: WasmI32, y: WasmI32, is64: Bool, totalOrdering: Bool) => {
  let xi = if (is64) {
    boxedInt64Number(x)
  } else {
    WasmI64.extendI32S(boxedInt32Number(x))
  }
  if (isSimpleNumber(y)) {
    let yi = WasmI64.extendI32S(untagSimple(y))
    if (WasmI64.ltS(xi, yi)) -1n else if (WasmI64.gtS(xi, yi)) 1n else 0n
  } else {
    let yBoxedNumberTag = boxedNumberTag(y)
    match (yBoxedNumberTag) {
      t when WasmI32.eq(t, Tags._GRAIN_INT32_BOXED_NUM_TAG) => {
        let yi = WasmI64.extendI32S(boxedInt32Number(y))
        if (WasmI64.ltS(xi, yi)) -1n else if (WasmI64.gtS(xi, yi)) 1n else 0n
      },
      t when WasmI32.eq(t, Tags._GRAIN_INT64_BOXED_NUM_TAG) => {
        let yi = boxedInt64Number(y)
        if (WasmI64.ltS(xi, yi)) -1n else if (WasmI64.gtS(xi, yi)) 1n else 0n
      },
      t when WasmI32.eq(t, Tags._GRAIN_BIGINT_BOXED_NUM_TAG) => {
        WasmI32.sub(0n, cmpBigInt(y, x))
      },
      t when WasmI32.eq(t, Tags._GRAIN_RATIONAL_BOXED_NUM_TAG) => {
        // Rationals and ints are never considered equal
        if (
          WasmF64.lt(
            WasmF64.convertI64S(xi),
            WasmF64.div(
              BI.toFloat64(boxedRationalNumerator(y)),
              BI.toFloat64(boxedRationalDenominator(y))
            )
          )
        ) -1n else 1n
      },
      t when WasmI32.eq(t, Tags._GRAIN_FLOAT32_BOXED_NUM_TAG) => {
        WasmI32.sub(0n, cmpFloat(y, x, false, totalOrdering))
      },
      t when WasmI32.eq(t, Tags._GRAIN_FLOAT64_BOXED_NUM_TAG) => {
        WasmI32.sub(0n, cmpFloat(y, x, true, totalOrdering))
      },
      _ => {
        throw UnknownNumberTag
      },
    }
  }
}

@unsafe
let cmpRational = (x: WasmI32, y: WasmI32, totalOrdering: Bool) => {
  if (isSimpleNumber(y)) {
    let xf = WasmF64.div(
      BI.toFloat64(boxedRationalNumerator(x)),
      BI.toFloat64(boxedRationalDenominator(x))
    )
    // Rationals and ints are never considered equal
    if (WasmF64.lt(xf, WasmF64.convertI32S(untagSimple(y)))) -1n else 1n
  } else {
    let yBoxedNumberTag = boxedNumberTag(y)
    match (yBoxedNumberTag) {
      t when WasmI32.eq(t, Tags._GRAIN_INT32_BOXED_NUM_TAG) => {
        WasmI32.sub(0n, cmpSmallInt(y, x, false, totalOrdering))
      },
      t when WasmI32.eq(t, Tags._GRAIN_INT64_BOXED_NUM_TAG) => {
        WasmI32.sub(0n, cmpSmallInt(y, x, true, totalOrdering))
      },
      t when WasmI32.eq(t, Tags._GRAIN_BIGINT_BOXED_NUM_TAG) => {
        WasmI32.sub(0n, cmpBigInt(y, x))
      },
      t when WasmI32.eq(t, Tags._GRAIN_RATIONAL_BOXED_NUM_TAG) => {
        // Comparing rationals efficiently is an open problem
        // Producing a definitive answer is quite expensive, so if the two
        // values are not strictly equal we approximate an answer

        let xNumerator = boxedRationalNumerator(x)
        let xDenominator = boxedRationalDenominator(x)
        let yNumerator = boxedRationalNumerator(y)
        let yDenominator = boxedRationalDenominator(y)

        if (
          BI.cmp(xNumerator, yNumerator) == 0n &&
          BI.cmp(xDenominator, yDenominator) == 0n
        ) {
          0n
        } else {
          let xf = WasmF64.div(
            BI.toFloat64(xNumerator),
            BI.toFloat64(xDenominator)
          )
          let yf = WasmF64.div(
            BI.toFloat64(yNumerator),
            BI.toFloat64(yDenominator)
          )
          if (WasmF64.lt(xf, yf)) -1n else 1n
        }
      },
      t when WasmI32.eq(t, Tags._GRAIN_FLOAT32_BOXED_NUM_TAG) => {
        WasmI32.sub(0n, cmpFloat(y, x, false, totalOrdering))
      },
      t when WasmI32.eq(t, Tags._GRAIN_FLOAT64_BOXED_NUM_TAG) => {
        WasmI32.sub(0n, cmpFloat(y, x, true, totalOrdering))
      },
      _ => {
        throw UnknownNumberTag
      },
    }
  }
}

@unsafe
export let cmp = (x: WasmI32, y: WasmI32, totalOrdering: Bool) => {
  if (isSimpleNumber(x)) {
    if (isSimpleNumber(y)) {
      if (WasmI32.ltS(x, y)) -1n else if (WasmI32.gtS(x, y)) 1n else 0n
    } else {
      let yBoxedNumberTag = boxedNumberTag(y)
      match (yBoxedNumberTag) {
        t when WasmI32.eq(t, Tags._GRAIN_INT32_BOXED_NUM_TAG) => {
          WasmI32.sub(0n, cmpSmallInt(y, x, false, totalOrdering))
        },
        t when WasmI32.eq(t, Tags._GRAIN_INT64_BOXED_NUM_TAG) => {
          WasmI32.sub(0n, cmpSmallInt(y, x, true, totalOrdering))
        },
        t when WasmI32.eq(t, Tags._GRAIN_BIGINT_BOXED_NUM_TAG) => {
          WasmI32.sub(0n, cmpBigInt(y, x))
        },
        t when WasmI32.eq(t, Tags._GRAIN_RATIONAL_BOXED_NUM_TAG) => {
          WasmI32.sub(0n, cmpRational(y, x, totalOrdering))
        },
        t when WasmI32.eq(t, Tags._GRAIN_FLOAT32_BOXED_NUM_TAG) => {
          WasmI32.sub(0n, cmpFloat(y, x, false, totalOrdering))
        },
        t when WasmI32.eq(t, Tags._GRAIN_FLOAT64_BOXED_NUM_TAG) => {
          WasmI32.sub(0n, cmpFloat(y, x, true, totalOrdering))
        },
        _ => {
          throw UnknownNumberTag
        },
      }
    }
  } else {
    let xBoxedNumberTag = boxedNumberTag(x)
    match (xBoxedNumberTag) {
      t when WasmI32.eq(t, Tags._GRAIN_INT32_BOXED_NUM_TAG) => {
        cmpSmallInt(x, y, false, totalOrdering)
      },
      t when WasmI32.eq(t, Tags._GRAIN_INT64_BOXED_NUM_TAG) => {
        cmpSmallInt(x, y, true, totalOrdering)
      },
      t when WasmI32.eq(t, Tags._GRAIN_BIGINT_BOXED_NUM_TAG) => {
        cmpBigInt(x, y)
      },
      t when WasmI32.eq(t, Tags._GRAIN_RATIONAL_BOXED_NUM_TAG) => {
        cmpRational(x, y, totalOrdering)
      },
      t when WasmI32.eq(t, Tags._GRAIN_FLOAT32_BOXED_NUM_TAG) => {
        cmpFloat(x, y, false, totalOrdering)
      },
      t when WasmI32.eq(t, Tags._GRAIN_FLOAT64_BOXED_NUM_TAG) => {
        cmpFloat(x, y, true, totalOrdering)
      },
      _ => {
        throw UnknownNumberTag
      },
    }
  }
}

@unsafe
export let (<) = (x: Number, y: Number) => {
  let x = WasmI32.fromGrain(x)
  let y = WasmI32.fromGrain(y)
  WasmI32.ltS(cmp(x, y, false), 0n)
}

@unsafe
export let (>) = (x: Number, y: Number) => {
  let x = WasmI32.fromGrain(x)
  let y = WasmI32.fromGrain(y)
  WasmI32.gtS(cmp(x, y, false), 0n)
}

@unsafe
export let (<=) = (x: Number, y: Number) => {
  let x = WasmI32.fromGrain(x)
  let y = WasmI32.fromGrain(y)
  WasmI32.leS(cmp(x, y, false), 0n)
}

@unsafe
export let (>=) = (x: Number, y: Number) => {
  let x = WasmI32.fromGrain(x)
  let y = WasmI32.fromGrain(y)
  WasmI32.geS(cmp(x, y, false), 0n)
}

@unsafe
export let compare = (x: Number, y: Number) => {
  let x = WasmI32.fromGrain(x)
  let y = WasmI32.fromGrain(y)
  WasmI32.toGrain(tagSimple(cmp(x, y, true))): Number
}

/*
 * ===== EQUAL =====
 */

@unsafe
export let numberEq = (x: Number, y: Number) => {
  let x = WasmI32.fromGrain(x)
  let y = WasmI32.fromGrain(y)
  numberEqual(x, y)
}

/*
 * ===== LOGICAL OPERATIONS =====
 * Only valid for int-like numbers. Coerce to i64/bigInt and do operations
 */
// TODO(#306): Semantics around when things should stay i32/i64

@unsafe
export let lnot = (x: Number) => {
  let xw32 = WasmI32.fromGrain(x)
  if (isBigInt(xw32)) {
    WasmI32.toGrain(reducedBigInteger(BI.bitwiseNot(xw32))): Number
  } else {
    let xval = coerceNumberToWasmI64(x)
    WasmI32.toGrain(reducedInteger(i64not(xval))): Number
  }
}

@unsafe
export let (<<) = (x: Number, y: Number) => {
  let xw32 = WasmI32.fromGrain(x)
  if (isBigInt(xw32)) {
    let yval = coerceNumberToWasmI32(y)
    WasmI32.toGrain(reducedBigInteger(BI.shl(xw32, yval))): Number
  } else {
    let xval = coerceNumberToWasmI64(x)
    let yval = coerceNumberToWasmI64(y)
    // if the number will be shifted beyond the end of the i64 range, promote to BigInt
    // (note that we subtract one leading zero, since the leading bit is the sign bit)
    if (WasmI64.leU(WasmI64.sub(WasmI64.clz(i64abs(xval)), 1N), yval)) {
      let xbi = coerceNumberToBigInt(x)
      let yval = coerceNumberToWasmI32(y)
      WasmI32.toGrain(reducedBigInteger(BI.shl(xbi, yval))): Number
    } else {
      WasmI32.toGrain(reducedInteger(WasmI64.shl(xval, yval))): Number
    }
  }
}

@unsafe
export let (>>>) = (x: Number, y: Number) => {
  let xw32 = WasmI32.fromGrain(x)
  if (isBigInt(xw32)) {
    let yval = coerceNumberToWasmI32(y)
    // [NOTE]: For BigInts, shrU is the same as shrS because there
    //         are an *infinite* number of leading ones
    WasmI32.toGrain(reducedBigInteger(BI.shrS(xw32, yval))): Number
  } else {
    let xval = coerceNumberToWasmI64(x)
    let yval = coerceNumberToWasmI64(y)
    WasmI32.toGrain(reducedInteger(WasmI64.shrU(xval, yval))): Number
  }
}

@unsafe
export let (&) = (x: Number, y: Number) => {
  let xw32 = WasmI32.fromGrain(x)
  let yw32 = WasmI32.fromGrain(y)
  if (isBigInt(xw32) || isBigInt(yw32)) {
    let xval = coerceNumberToBigInt(x)
    let yval = coerceNumberToBigInt(y)
    let ret = WasmI32.toGrain(
      reducedBigInteger(BI.bitwiseAnd(xval, yval))
    ): Number
    if (!WasmI32.eq(xw32, xval)) {
      Memory.decRef(xval)
      void
    }
    if (!WasmI32.eq(yw32, yval)) {
      Memory.decRef(yval)
      void
    }
    ret
  } else {
    let xval = coerceNumberToWasmI64(x)
    let yval = coerceNumberToWasmI64(y)
    WasmI32.toGrain(reducedInteger(WasmI64.and(xval, yval))): Number
  }
}

@unsafe
export let (|) = (x: Number, y: Number) => {
  let xw32 = WasmI32.fromGrain(x)
  let yw32 = WasmI32.fromGrain(y)
  if (isBigInt(xw32) || isBigInt(yw32)) {
    let xval = coerceNumberToBigInt(x)
    let yval = coerceNumberToBigInt(y)
    let ret = WasmI32.toGrain(
      reducedBigInteger(BI.bitwiseOr(xval, yval))
    ): Number
    if (!WasmI32.eq(xw32, xval)) {
      Memory.decRef(xval)
      void
    }
    if (!WasmI32.eq(yw32, yval)) {
      Memory.decRef(yval)
      void
    }
    ret
  } else {
    let xval = coerceNumberToWasmI64(x)
    let yval = coerceNumberToWasmI64(y)
    WasmI32.toGrain(reducedInteger(WasmI64.or(xval, yval))): Number
  }
}

@unsafe
export let (^) = (x: Number, y: Number) => {
  let xw32 = WasmI32.fromGrain(x)
  let yw32 = WasmI32.fromGrain(y)
  if (isBigInt(xw32) || isBigInt(yw32)) {
    let xval = coerceNumberToBigInt(x)
    let yval = coerceNumberToBigInt(y)
    let ret = WasmI32.toGrain(
      reducedBigInteger(BI.bitwiseXor(xval, yval))
    ): Number
    if (!WasmI32.eq(xw32, xval)) {
      Memory.decRef(xval)
      void
    }
    if (!WasmI32.eq(yw32, yval)) {
      Memory.decRef(yval)
      void
    }
    ret
  } else {
    let xval = coerceNumberToWasmI64(x)
    let yval = coerceNumberToWasmI64(y)
    WasmI32.toGrain(reducedInteger(WasmI64.xor(xval, yval))): Number
  }
}

@unsafe
export let (>>) = (x: Number, y: Number) => {
  let xw32 = WasmI32.fromGrain(x)
  if (isBigInt(xw32)) {
    let yval = coerceNumberToWasmI32(y)
    // [NOTE]: For BigInts, shrU is the same as shrS because there
    //         are an *infinite* number of leading ones
    WasmI32.toGrain(reducedBigInteger(BI.shrS(xw32, yval))): Number
  } else {
    let xval = coerceNumberToWasmI64(x)
    let yval = coerceNumberToWasmI64(y)
    WasmI32.toGrain(reducedInteger(WasmI64.shrS(xval, yval))): Number
  }
}

/// USER-EXPOSED COERCION FUNCTIONS
//
// [NOTE]: Coercion is a *conservative* process! For example, even if a float is 1.0,
//         we will fail if attempting to coerce to an int!

@unsafe
export let rec coerceNumberToInt32 = (x: Number) => {
  let x = WasmI32.fromGrain(x)
  let result = if (
    !isSimpleNumber(x) &&
    WasmI32.eq(boxedNumberTag(x), Tags._GRAIN_INT32_BOXED_NUM_TAG)
  ) {
    // avoid extra malloc and prevent x from being freed
    Memory.incRef(x)
    x
  } else {
    // incRef x to reuse it via WasmI32.toGrain
    Memory.incRef(x)
    // can possibly fail
    newInt32(coerceNumberToWasmI32(WasmI32.toGrain(x): Number))
  }
  WasmI32.toGrain(result): Int32
}

@unsafe
export let rec coerceNumberToInt64 = (x: Number) => {
  let x = WasmI32.fromGrain(x)
  let result = if (
    !isSimpleNumber(x) &&
    WasmI32.eq(boxedNumberTag(x), Tags._GRAIN_INT64_BOXED_NUM_TAG)
  ) {
    // avoid extra malloc and prevent x from being freed
    Memory.incRef(x)
    x
  } else {
    // incRef x to reuse it via WasmI32.toGrain
    Memory.incRef(x)
    newInt64(coerceNumberToWasmI64(WasmI32.toGrain(x): Number))
  }
  WasmI32.toGrain(result): Int64
}

@unsafe
export let rec coerceNumberToBigInt = (x: Number) => {
  let x = WasmI32.fromGrain(x)
  let result = if (isBigInt(x)) {
    // avoid extra malloc and prevent x from being freed
    Memory.incRef(x)
    x
  } else {
    // incRef x to reuse it via WasmI32.toGrain
    Memory.incRef(x)
    BI.makeWrappedInt64(coerceNumberToWasmI64(WasmI32.toGrain(x): Number))
  }
  WasmI32.toGrain(result): BigInt
}

@unsafe
export let coerceNumberToRational = (x: Number) => {
  let x = WasmI32.fromGrain(x)
  let result = if (isSimpleNumber(x)) {
    newRational(BI.makeWrappedInt32(untagSimple(x)), BI.makeWrappedInt32(1n))
  } else {
    let tag = boxedNumberTag(x)
    if (WasmI32.eq(tag, Tags._GRAIN_RATIONAL_BOXED_NUM_TAG)) {
      // avoid extra malloc and prevent x from being freed
      Memory.incRef(x)
      x
    } else if (WasmI32.eq(tag, Tags._GRAIN_INT32_BOXED_NUM_TAG)) {
      newRational(
        BI.makeWrappedInt32(boxedInt32Number(x)),
        BI.makeWrappedInt32(1n)
      )
    } else if (WasmI32.eq(tag, Tags._GRAIN_INT64_BOXED_NUM_TAG)) {
      // incRef x to reuse it via WasmI32.toGrain
      Memory.incRef(x)
      newRational(
        BI.makeWrappedInt32(coerceNumberToWasmI32(WasmI32.toGrain(x): Number)),
        BI.makeWrappedInt32(1n)
      )
    } else {
      throw Exception.NumberNotRational
    }
  }
  WasmI32.toGrain(result): Rational
}

@unsafe
export let coerceNumberToFloat32 = (x: Number) => {
  let x = WasmI32.fromGrain(x)
  let result = if (
    !isSimpleNumber(x) &&
    WasmI32.eq(boxedNumberTag(x), Tags._GRAIN_FLOAT32_BOXED_NUM_TAG)
  ) {
    // avoid extra malloc and prevent x from being freed
    Memory.incRef(x)
    x
  } else {
    // incRef x to reuse it via WasmI32.toGrain
    Memory.incRef(x)
    newFloat32(coerceNumberToWasmF32(WasmI32.toGrain(x): Number))
  }
  WasmI32.toGrain(result): Float32
}

@unsafe
export let coerceNumberToFloat64 = (x: Number) => {
  let x = WasmI32.fromGrain(x)
  let result = if (
    !isSimpleNumber(x) &&
    WasmI32.eq(boxedNumberTag(x), Tags._GRAIN_FLOAT64_BOXED_NUM_TAG)
  ) {
    // avoid extra malloc and prevent x from being freed
    Memory.incRef(x)
    x
  } else {
    // incRef x to reuse it via WasmI32.toGrain
    Memory.incRef(x)
    newFloat64(coerceNumberToWasmF64(WasmI32.toGrain(x): Number))
  }
  WasmI32.toGrain(result): Float64
}

@unsafe
export let coerceInt32ToNumber = (x: Int32) => {
  WasmI32.toGrain(
    reducedInteger(WasmI64.extendI32S(boxedInt32Number(WasmI32.fromGrain(x))))
  ): Number
}

@unsafe
export let coerceInt64ToNumber = (x: Int64) => {
  WasmI32.toGrain(
    reducedInteger(boxedInt64Number(WasmI32.fromGrain(x)))
  ): Number
}

@unsafe
export let coerceBigIntToNumber = (x: BigInt) => {
  let x = WasmI32.fromGrain(x)
  // reducedBigInteger assumes that the bigint is dead,
  // but in our case, it is not
  Memory.incRef(x)
  WasmI32.toGrain(reducedBigInteger(x)): Number
}

@unsafe
export let coerceRationalToNumber = (x: Rational) => {
  if (WasmI32.eq(boxedRationalDenominator(WasmI32.fromGrain(x)), 1n)) {
    WasmI32.toGrain(
      reducedInteger(
        WasmI64.extendI32S(boxedRationalNumerator(WasmI32.fromGrain(x)))
      )
    ): Number
  } else {
    let x = WasmI32.fromGrain(x)
    // incRef x to reuse it via WasmI32.toGrain
    Memory.incRef(x)
    WasmI32.toGrain(x): Number
  }
}

@unsafe
export let coerceFloat32ToNumber = (x: Float32) => {
  WasmI32.toGrain(
    newFloat64(WasmF64.promoteF32(boxedFloat32Number(WasmI32.fromGrain(x))))
  ): Number
}

@unsafe
export let coerceFloat64ToNumber = (x: Float64) => {
  let x = WasmI32.fromGrain(x)
  // incRef x to reuse it via WasmI32.toGrain
  Memory.incRef(x)
  WasmI32.toGrain(x): Number
}

/// USER-EXPOSED CONVERSION FUNCTIONS

@unsafe
export let convertExactToInexact = (x: Number) => {
  x
}

@unsafe
let convertInexactToExactHelp = x => {
  if (isSimpleNumber(x)) {
    x
  } else {
    let tag = boxedNumberTag(x)
    if (
      WasmI32.eq(tag, Tags._GRAIN_INT32_BOXED_NUM_TAG) ||
      WasmI32.eq(tag, Tags._GRAIN_INT64_BOXED_NUM_TAG) ||
      WasmI32.eq(tag, Tags._GRAIN_BIGINT_BOXED_NUM_TAG) ||
      WasmI32.eq(tag, Tags._GRAIN_RATIONAL_BOXED_NUM_TAG)
    ) {
      Memory.incRef(x)
      x
    } else {
      match (tag) {
        t when WasmI32.eq(t, Tags._GRAIN_FLOAT32_BOXED_NUM_TAG) => {
          // TODO(#1191): Investigate if BigInt is more accurate
          reducedInteger(
            WasmI64.truncF32S(WasmF32.nearest(boxedFloat32Number(x)))
          )
        },
        t when WasmI32.eq(t, Tags._GRAIN_FLOAT64_BOXED_NUM_TAG) => {
          // TODO(#1191): Investigate if BigInt is more accurate
          reducedInteger(
            WasmI64.truncF64S(WasmF64.nearest(boxedFloat64Number(x)))
          )
        },
        _ => {
          throw UnknownNumberTag
        },
      }
    }
  }
}

@unsafe
export let convertInexactToExact = (x: Number) => {
  WasmI32.toGrain(convertInexactToExactHelp(WasmI32.fromGrain(x))): Number
}

@unsafe
export let (+) = (x: Number, y: Number) => {
  let x = WasmI32.fromGrain(x)
  let y = WasmI32.fromGrain(y)
  numberAdd(x, y)
}

@unsafe
export let (-) = (x: Number, y: Number) => {
  let x = WasmI32.fromGrain(x)
  let y = WasmI32.fromGrain(y)
  numberSub(x, y)
}

@unsafe
export let (*) = (x: Number, y: Number) => {
  let x = WasmI32.fromGrain(x)
  let y = WasmI32.fromGrain(y)
  numberTimes(x, y)
}

@unsafe
export let (/) = (x: Number, y: Number) => {
  let x = WasmI32.fromGrain(x)
  let y = WasmI32.fromGrain(y)
  numberDivide(x, y)
}

@unsafe
export let (%) = (x: Number, y: Number) => {
  let x = WasmI32.fromGrain(x)
  let y = WasmI32.fromGrain(y)
  WasmI32.toGrain(numberMod(x, y)): Number
}

// inc/dec

export let incr = x => {
  x + 1
}

export let decr = x => {
  x - 1
}

@unsafe
export let isBigInt = x => {
  let x = WasmI32.fromGrain(x)
  isBigInt(x)
}
