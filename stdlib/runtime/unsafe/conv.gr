module Conv

from "runtime/unsafe/wasmi32" include WasmI32
from "runtime/unsafe/wasmi64" include WasmI64
from "runtime/unsafe/wasmf32" include WasmF32
from "runtime/unsafe/wasmf64" include WasmF64
from "runtime/unsafe/wasmref" include WasmRef
from "runtime/dataStructures" include DataStructures
use DataStructures.{
  newInt32,
  newUint32,
  newInt64,
  newUint64,
  newFloat32,
  newFloat64,
  getInt32Value,
  getInt64Value,
  getUint32Value,
  getUint64Value,
  getFloat32Value,
  getFloat64Value,
  tagSimpleNumber,
  untagSimpleNumber,
}

primitive (is) = "@is"

@unsafe
provide let toInt32 = n => {
  WasmRef.toGrain(newInt32(n)): Int32
}

@unsafe
provide let toUint32 = n => {
  WasmRef.toGrain(newUint32(n)): Uint32
}

@unsafe
provide let fromInt32 = (n: Int32) => {
  let ptr = WasmRef.fromGrain(n)
  DataStructures.getInt32Value(ptr)
}

@unsafe
provide let fromUint32 = (n: Uint32) => {
  let ptr = WasmRef.fromGrain(n)
  DataStructures.getUint32Value(ptr)
}

@unsafe
provide let toInt64 = n => {
  WasmRef.toGrain(newInt64(n)): Int64
}

@unsafe
provide let toUint64 = n => {
  WasmRef.toGrain(newUint64(n)): Uint64
}

@unsafe
provide let fromInt64 = (n: Int64) => {
  let ptr = WasmRef.fromGrain(n)
  getInt64Value(ptr)
}

@unsafe
provide let fromUint64 = (n: Uint64) => {
  let ptr = WasmRef.fromGrain(n)
  getUint64Value(ptr)
}

@unsafe
provide let toFloat32 = n => {
  WasmRef.toGrain(newFloat32(n)): Float32
}

@unsafe
provide let fromFloat32 = (n: Float32) => {
  let ptr = WasmRef.fromGrain(n)
  getFloat32Value(ptr)
}

@unsafe
provide let toFloat64 = n => {
  WasmRef.toGrain(newFloat64(n)): Float64
}

@unsafe
provide let fromFloat64 = (n: Float64) => {
  let ptr = WasmRef.fromGrain(n)
  getFloat64Value(ptr)
}

/**
 * Converts a WasmI32 value to Number.
 *
 * @param n: The WasmI32 to convert
 * @returns The value converted to either a simple or a 32 bit heap allocated number.
 */
@unsafe
provide let wasmI32ToNumber = (n: WasmI32) => {
  use WasmI32.{ (^), (<<), (>>), (==) }
  // Follows a little optimization. Instead of testing if n is range of allowed
  // non heap allocated simple numbers (-1073741824n..1073741823n), actually
  // make a simple number, convert it back to WasmI32, and test if it stayed
  // the same. This may sound counter intuitive, but for numbers that fit into
  // the range it is faster than performing the check with WasmI32.geS and
  // WasmI32.leS by about 20%. An additional ~33% is gained by avoiding a
  // call to tagSimpleNumber and instead doing it inline. For the case of
  // numbers not fitting into the range, the cost of these simple ALU
  // instructions are negligible compared to heap allocations.

  let simple = tagSimpleNumber(n)

  if (untagSimpleNumber(simple) is n) {
    // Just test if the untagged number is the same. If it didn't overflow, then
    // we're good. We just need to cast the raw value into a Number at the type
    // system level.
    return simple
  }

  // If it did overflow, then the value differs and we need to discard it and
  // allocate the number on the heap. We can do this by extending the 32 bit
  // number to an Int64.
  return WasmRef.toGrain(newInt64(WasmI64.extendI32S(n))): Number
}
