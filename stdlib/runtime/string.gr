@noPervasives
module String

from "runtime/unsafe/panic" include Panic

from "runtime/unsafe/wasmi32" include WasmI32
use WasmI32.{
  (+),
  (-),
  (*),
  (/),
  remS as (%),
  (<<),
  (>>),
  (&),
  (>>>),
  (|),
  (==),
  (!=),
  (>=),
  (>),
  (<=),
  (<),
}
from "runtime/unsafe/wasmi64" include WasmI64
from "runtime/unsafe/wasmf32" include WasmF32
from "runtime/unsafe/wasmf64" include WasmF64
from "runtime/unsafe/wasmref" include WasmRef
from "runtime/bigint" include Bigint as BI
from "runtime/unsafe/memory" include Memory
from "runtime/malloc" include Malloc
from "runtime/unsafe/tags" include Tags
from "runtime/numberUtils" include NumberUtils
from "runtime/utf8" include Utf8
use Utf8.{ usvEncodeLength, writeUtf8CodePoint }
from "runtime/dataStructures" include DataStructures
use DataStructures.{
  allocateString,
  allocateArray,
  tagSimpleNumber,
  untagSimpleNumber,
  getCompoundValueArrayRef,
  getStringArrayRef,
  loadCycleMarker,
  storeCycleMarker,
  loadAdtVariant,
}

foreign wasm fd_write:
  (WasmI32, WasmI32, WasmI32, WasmI32) => WasmI32 from "wasi_snapshot_preview1"

primitive (!) = "@not"
primitive (&&) = "@and"
primitive (||) = "@or"
primitive (is) = "@is"
primitive builtinId = "@builtin.id"
primitive ignore = "@ignore"

@unsafe
primitive typeMetadata = "@heap.type_metadata"

@unsafe
let findTypeMetadata = typeHash => {
  let typeMetadata = typeMetadata()
  let numBuckets = WasmI32.load(typeMetadata, 0n)
  let hashHash = typeHash % numBuckets
  // First 8 bytes of metadata are for table size
  let bucketPtr = typeMetadata + 8n + (hashHash << 3n) // 8 bytes/bucket
  let bucketDataOffset = WasmI32.load(bucketPtr, 0n)
  let bucketSize = WasmI32.load(bucketPtr, 4n)
  let beginDataPtr = typeMetadata + bucketDataOffset
  let endDataPtr = beginDataPtr + (bucketSize << 3n)
  for (let mut ptr = beginDataPtr; ptr < endDataPtr; ptr += 8n) {
    if (WasmI32.load(ptr, 0n) == typeHash) {
      return typeMetadata + WasmI32.load(ptr, 4n)
    }
  }
  return -1n
}

@unsafe
let _LIST_ID = WasmRef.fromGrain(builtinId("List"))
@unsafe
let _OPTION_ID = WasmRef.fromGrain(builtinId("Option"))
@unsafe
let _RESULT_ID = WasmRef.fromGrain(builtinId("Result"))
@unsafe
let _RANGE_ID = WasmRef.fromGrain(builtinId("Range"))

let _SOME = "Some"
let _NONE = "None"
let _OK = "Ok"
let _ERR = "Err"

let _RANGE_FIELDS = [> "rangeStart", "rangeEnd"]

@unsafe
let _VISITED_BIT = 0x1n

// Resizable array
record Vec {
  mut size: Number,
  mut capacity: Number,
  mut data: WasmRef,
}

@unsafe
let makeVec = () => {
  { size: 0, capacity: 4, data: getCompoundValueArrayRef(allocateArray(4n)) }
}

@unsafe
let vecPush = (vec, val) => {
  if (vec.size is vec.capacity) {
    let newCapacity = untagSimpleNumber(vec.capacity) * 2n
    let newArray = getCompoundValueArrayRef(allocateArray(newCapacity))
    Memory.copyRefArrayAny(
      newArray,
      0n,
      vec.data,
      0n,
      untagSimpleNumber(vec.capacity)
    )
    vec.data = newArray
    vec.capacity = tagSimpleNumber(newCapacity)
  }
  let size = untagSimpleNumber(vec.size)
  WasmRef.arrayAnySet(vec.data, size, val)
  vec.size = tagSimpleNumber(size + 1n)
}

@unsafe
let vecLen = vec => {
  untagSimpleNumber(vec.size)
}

@unsafe
let vecFindIndex = (vec, val) => {
  let len = vecLen(vec)
  for (let mut i = 0n; i < len; i += 1n) {
    if (WasmRef.arrayAnyGet(vec.data, i) is val) {
      return i
    }
  }
  return -1n
}

@unsafe
let isListVariant = variant => {
  let typeId = DataStructures.loadVariantTypeId(variant)
  typeId is _LIST_ID
}

@unsafe
let isRangeRecord = record_ => {
  let typeId = DataStructures.loadRecordTypeId(record_)
  typeId is _RANGE_ID
}

@unsafe
let getBuiltinVariantName = variant => {
  let typeId = DataStructures.loadVariantTypeId(variant)
  let variantId = loadAdtVariant(variant)

  match (typeId) {
    id when id is _OPTION_ID => {
      if (variantId is WasmRef.fromGrain(0)) {
        Some(WasmRef.fromGrain(_SOME))
      } else {
        Some(WasmRef.fromGrain(_NONE))
      }
    },
    id when id is _RESULT_ID => {
      if (variantId is WasmRef.fromGrain(0)) {
        Some(WasmRef.fromGrain(_OK))
      } else {
        Some(WasmRef.fromGrain(_ERR))
      }
    },
    _ => None,
  }
}

@unsafe
let getFieldArray = (fields, arity) => {
  let fieldArray = getCompoundValueArrayRef(allocateArray(arity))

  let mut fieldOffset = 0n
  for (let mut i = 0n; i < arity; i += 1n) {
    let fieldLength = WasmI32.load(fields + fieldOffset, 4n)
    let fieldName = allocateString(fieldLength)
    Memory.copyLinearMemoryToRefArray(
      getStringArrayRef(fieldName),
      fields + fieldOffset + 8n,
      fieldLength
    )
    WasmRef.arrayAnySet(fieldArray, i, fieldName)

    fieldOffset += WasmI32.load(fields + fieldOffset, 0n)
  }

  fieldArray
}

@unsafe
let getVariantMetadata = variant => {
  let typeHash = untagSimpleNumber(
    WasmRef.toGrain(DataStructures.loadVariantTypeHash(variant))
  )
  let variantId = untagSimpleNumber(WasmRef.toGrain(loadAdtVariant(variant)))

  let mut block = findTypeMetadata(typeHash)

  if (block == -1n) return -1n

  let sectionLength = WasmI32.load(block, 0n)
  block += 4n

  let end = block + sectionLength
  while (block < end) {
    if (WasmI32.load(block, 8n) == variantId) {
      return block
    }
    block += WasmI32.load(block, 0n)
  }

  return -1n
}

@unsafe
let getRecordFieldNames = record_ => {
  let typeHash = untagSimpleNumber(
    WasmRef.toGrain(DataStructures.loadRecordTypeHash(record_))
  )
  if (isRangeRecord(record_)) {
    return Some(getCompoundValueArrayRef(WasmRef.fromGrain(_RANGE_FIELDS)))
  } else {
    let arity = WasmRef.arrayLen(getCompoundValueArrayRef(record_))

    let mut fields = findTypeMetadata(typeHash)

    if (fields == -1n) return None

    fields += 4n
    return Some(getFieldArray(fields, arity))
  }
}

@unsafe
let rec totalBytes = (acc, list) => {
  match (list) {
    [hd, ...tl] =>
      totalBytes(acc + DataStructures.stringSize(WasmRef.fromGrain(hd)), tl),
    [] => acc,
  }
}

@unsafe
let rec writeStrings = (buf, offset, list) => {
  match (list) {
    [hd, ...tl] => {
      let hd = getStringArrayRef(WasmRef.fromGrain(hd))
      let hdSize = WasmRef.arrayLen(hd)
      Memory.copyRefArrayI8(buf, offset, hd, 0n, hdSize)
      writeStrings(buf, offset + hdSize, tl)
    },
    [] => void,
  }
}

@unsafe
let join = list => {
  let len = totalBytes(0n, list)
  let str = allocateString(len)
  writeStrings(getStringArrayRef(str), 0n, list)
  WasmRef.toGrain(str): String
}

@unsafe
let reverse = list => {
  @unsafe
  let rec iter = (list, acc) => {
    match (list) {
      [] => acc,
      [first, ...rest] => iter(rest, [first, ...acc]),
    }
  }
  iter(list, [])
}

/**
 * Concatenate two strings.
 *
 * @param str1: The beginning string
 * @param str2: The ending string
 * @returns The combined string
 *
 * @example "Foo" ++ "Bar" == "FooBar"
 *
 * @since v0.2.0
 */
@unsafe
provide let concat = (str1: String, str2: String) => {
  let ptr1 = WasmRef.fromGrain(str1)
  let ptr2 = WasmRef.fromGrain(str2)

  let size1 = DataStructures.stringSize(ptr1)
  let size2 = DataStructures.stringSize(ptr2)

  let newString = allocateString(size1 + size2)

  Memory.copyRefArrayI8(
    getStringArrayRef(newString),
    0n,
    getStringArrayRef(ptr1),
    0n,
    size1
  )
  Memory.copyRefArrayI8(
    getStringArrayRef(newString),
    0n,
    getStringArrayRef(ptr2),
    0n,
    size2
  )

  WasmRef.toGrain(newString): String
}

@unsafe
let escape = (ptr, isString) => {
  let _SEQ_B = 0x08n
  let _SEQ_F = 0x0Cn
  let _SEQ_N = 0x0An
  let _SEQ_R = 0x0Dn
  let _SEQ_T = 0x09n
  let _SEQ_V = 0x0Bn
  let _SEQ_SLASH = 0x5Cn
  let _SEQ_DQUOTE = 0x22n
  let _SEQ_SQUOTE = 0x27n

  let _SEQ_QUOTE = if (isString) _SEQ_DQUOTE else _SEQ_SQUOTE

  let ptr = getStringArrayRef(ptr)
  let size = WasmRef.arrayLen(ptr)

  let mut newSize = 2n // extra space for quote characters
  for (let mut i = 0n; i < size; i += 1n) {
    let byte = WasmRef.arrayI8GetU(ptr, i)
    if (
      byte >= _SEQ_B && byte <= _SEQ_R
      || /* b, f, n, r, t, v */
      byte == _SEQ_SLASH
      || byte == _SEQ_QUOTE
    ) {
      newSize += 2n
    } else {
      newSize += 1n
    }
  }

  let escapedString = allocateString(newSize)
  let escapedStringArray = getStringArrayRef(escapedString)

  // one extra byte for leading quote character
  let mut j = 1n

  for (let mut i = 0n; i < size; i += 1n) {
    let byte = WasmRef.arrayI8GetU(ptr, i)
    if (
      byte >= _SEQ_B && byte <= _SEQ_R
      || /* b, f, n, r, t, v */
      byte == _SEQ_SLASH
      || byte == _SEQ_QUOTE
    ) {
      WasmRef.arrayI8Set(escapedStringArray, j, _SEQ_SLASH)
      j += 1n
      let seq = match (byte) {
        b when b == _SEQ_B => 0x62n,
        f when f == _SEQ_F => 0x66n,
        n when n == _SEQ_N => 0x6en,
        r when r == _SEQ_R => 0x72n,
        t when t == _SEQ_T => 0x74n,
        v when v == _SEQ_V => 0x76n,
        _ => byte,
      }
      WasmRef.arrayI8Set(escapedStringArray, j, seq)
      j += 1n
    } else {
      WasmRef.arrayI8Set(escapedStringArray, j, byte)
      j += 1n
    }
  }

  WasmRef.arrayI8Set(escapedStringArray, 0n, _SEQ_QUOTE)
  WasmRef.arrayI8Set(escapedStringArray, j, _SEQ_QUOTE)

  WasmRef.toGrain(escapedString): String
}

@unsafe
let escapeString = (s: String) => {
  escape(WasmRef.fromGrain(s), true)
}

@unsafe
let escapeChar = (s: String) => {
  escape(WasmRef.fromGrain(s), false)
}

@unsafe
let reportCycle = (ptr, cycles) => {
  let mut cycleNum = vecFindIndex(cycles, ptr)
  if (cycleNum == -1n) {
    cycleNum = vecLen(cycles)
    vecPush(cycles, ptr)
  }
  let numStr = NumberUtils.itoa32(cycleNum + 1n, 10n)
  join(["<cycle to <", numStr, ">>"])
}

@unsafe
let cyclePrefix = (ptr, cycles) => {
  let cycleNum = vecFindIndex(cycles, ptr)
  if (cycleNum != -1n) {
    join(["<", NumberUtils.itoa32(cycleNum + 1n, 10n), "> "])
  } else {
    ""
  }
}

@unsafe
let rec heapValueToString = (ptr, extraIndents, toplevel, cycles) => {
  let tag = DataStructures.loadValueTag(ptr)
  match (tag) {
    t when t == Tags._GRAIN_STRING_HEAP_TAG => {
      if (toplevel) {
        WasmRef.toGrain(ptr): String
      } else {
        escapeString(WasmRef.toGrain(ptr))
      }
    },
    t when t == Tags._GRAIN_BYTES_HEAP_TAG => {
      let ptrArray = DataStructures.getBytesArrayRef(ptr)
      let mut numBytes = WasmRef.arrayLen(ptrArray)
      let mut needsEllipsis = false
      if (numBytes > 32n) {
        numBytes = 32n
        needsEllipsis = true
      }
      let headBytes = 8n // <bytes:
      // This is two digits and a space for each byte, minus one space for the last byte
      let hexBytes = numBytes * 3n - 1n
      let tailBytes = if (needsEllipsis) {
        4n // ...>
      } else {
        1n // >
      }
      let strLen = headBytes + hexBytes + tailBytes
      let str = allocateString(strLen)
      let strArray = getStringArrayRef(str)
      let hex = NumberUtils.get_HEX_DIGITS()

      // <bytes:
      WasmRef.arrayI8Set(strArray, 0n, 0x3cn)
      WasmRef.arrayI8Set(strArray, 1n, 0x62n)
      WasmRef.arrayI8Set(strArray, 2n, 0x79n)
      WasmRef.arrayI8Set(strArray, 3n, 0x74n)
      WasmRef.arrayI8Set(strArray, 4n, 0x65n)
      WasmRef.arrayI8Set(strArray, 5n, 0x73n)
      WasmRef.arrayI8Set(strArray, 6n, 0x3an)
      WasmRef.arrayI8Set(strArray, 7n, 0x20n)

      for (let mut i = 0n; i < numBytes; i += 1n) {
        let n = WasmRef.arrayI8GetU(ptrArray, i)
        let j = i * 3n
        let k = n * 2n
        let hex = WasmI32.load16U(hex, k)
        WasmRef.arrayI8Set(strArray, j, hex)
        WasmRef.arrayI8Set(strArray, j + 1n, hex >> 8n)
        WasmRef.arrayI8Set(strArray, j + 2n, 0x20n)
      }

      if (needsEllipsis) {
        // ...>
        WasmRef.arrayI8Set(strArray, hexBytes, 0x2en)
        WasmRef.arrayI8Set(strArray, hexBytes + 1n, 0x2en)
        WasmRef.arrayI8Set(strArray, hexBytes + 2n, 0x2en)
        WasmRef.arrayI8Set(strArray, hexBytes + 3n, 0x3en)
      } else {
        // >
        WasmRef.arrayI8Set(strArray, hexBytes, 0x3en)
      }

      WasmRef.toGrain(str): String
    },
    t when t == Tags._GRAIN_ADT_HEAP_TAG => {
      // [ <value type tag>, <module_tag>, <type_tag>, <variant_tag>, <arity>, elts ... ]
      let builtinVariantName = getBuiltinVariantName(ptr)
      match (builtinVariantName) {
        Some(builtinVariantName) => {
          // Assumes that all builtin variants do not have inline record
          // constructors; if this changes this should be changed as well
          tupleVariantToString(
            ptr,
            WasmRef.toGrain(builtinVariantName),
            extraIndents,
            cycles
          )
        },
        None => {
          if (isListVariant(ptr)) {
            listToString(ptr, extraIndents, cycles)
          } else {
            let variantPtr = getVariantMetadata(ptr)
            if (variantPtr == -1n) {
              "<enum value>"
            } else {
              let length = WasmI32.load(variantPtr, 12n)
              let variantName = allocateString(length)
              Memory.copyLinearMemoryToRefArray(
                getStringArrayRef(variantName),
                variantPtr + 16n,
                length
              )
              let variantName = WasmRef.toGrain(variantName): String
              let distToRecordFields = WasmI32.load(variantPtr, 4n)
              let isRecordVariant = distToRecordFields != 0n
              if (isRecordVariant) {
                let fields = variantPtr + distToRecordFields
                let recordArity = WasmRef.arrayLen(
                  getCompoundValueArrayRef(ptr)
                )
                let recordVariantFields = getFieldArray(fields, recordArity)
                let recordString = recordToString(
                  ptr,
                  recordArity,
                  recordVariantFields,
                  extraIndents,
                  cycles
                )
                let strings = [variantName, recordString]

                join(strings)
              } else {
                tupleVariantToString(ptr, variantName, extraIndents, cycles)
              }
            }
          }
        },
      }
    },
    t when t == Tags._GRAIN_RECORD_HEAP_TAG => {
      let recordArity = WasmRef.arrayLen(getCompoundValueArrayRef(ptr))
      let fields = getRecordFieldNames(ptr)
      match (fields) {
        Some(fields) => {
          if (loadCycleMarker(ptr) != 0n) {
            reportCycle(ptr, cycles)
          } else {
            storeCycleMarker(ptr, _VISITED_BIT)
            let result = recordToString(
              ptr,
              recordArity,
              fields,
              extraIndents,
              cycles
            )
            storeCycleMarker(ptr, 0n)
            join([cyclePrefix(ptr, cycles), result])
          }
        },
        None => "<record value>",
      }
    },
    t when t == Tags._GRAIN_ARRAY_HEAP_TAG => {
      let arity = WasmRef.arrayLen(getCompoundValueArrayRef(ptr))
      if (loadCycleMarker(ptr) != 0n) {
        reportCycle(ptr, cycles)
      } else {
        storeCycleMarker(ptr, _VISITED_BIT)
        let rbrack = "]"
        let mut strings = [rbrack]
        let comspace = ", "
        let ptrArray = getCompoundValueArrayRef(ptr)
        for (let mut i = arity - 1n; i >= 0n; i -= 1n) {
          let item = toStringHelp(
            WasmRef.arrayAnyGet(ptrArray, i),
            extraIndents,
            false,
            cycles
          )
          strings = [item, ...strings]
          if (i > 0n) {
            strings = [comspace, ...strings]
          }
        }
        storeCycleMarker(ptr, 0n)
        let lbrack = "[> "
        strings = [lbrack, ...strings]

        join([cyclePrefix(ptr, cycles), ...strings])
      }
    },
    t when t == Tags._GRAIN_BOXED_NUM_HEAP_TAG => {
      let numberTag = DataStructures.getNumberTag(ptr)
      match (numberTag) {
        t when t == Tags._GRAIN_INT64_BOXED_NUM_TAG => {
          NumberUtils.itoa64(DataStructures.getInt64Value(ptr), 10n)
        },
        t when t == Tags._GRAIN_BIGINT_BOXED_NUM_TAG => {
          BI.bigIntToString10(ptr)
        },
        t when t == Tags._GRAIN_RATIONAL_BOXED_NUM_TAG => {
          let numerator = BI.bigIntToString10(
            DataStructures.getRationalNumerator(ptr)
          )
          let denominator = BI.bigIntToString10(
            DataStructures.getRationalDenominator(ptr)
          )
          let slash = "/"
          let strings = [numerator, slash, denominator]
          join(strings)
        },
        t when t == Tags._GRAIN_FLOAT64_BOXED_NUM_TAG => {
          NumberUtils.dtoa(DataStructures.getFloat64Value(ptr))
        },
        _ => {
          "<unknown boxed number>"
        },
      }
    },
    t when t == Tags._GRAIN_INT32_HEAP_TAG => {
      NumberUtils.itoa32(DataStructures.getInt32Value(ptr), 10n)
    },
    t when t == Tags._GRAIN_FLOAT32_HEAP_TAG => {
      NumberUtils.dtoa(WasmF64.promoteF32(DataStructures.getFloat32Value(ptr)))
    },
    t when t == Tags._GRAIN_UINT32_HEAP_TAG => {
      NumberUtils.utoa32(DataStructures.getUint32Value(ptr), 10n)
    },
    t when t == Tags._GRAIN_UINT64_HEAP_TAG => {
      NumberUtils.utoa64(DataStructures.getUint64Value(ptr), 10n)
    },
    t when t == Tags._GRAIN_TUPLE_HEAP_TAG => {
      let tupleLength = WasmRef.arrayLen(getCompoundValueArrayRef(ptr))
      if (loadCycleMarker(ptr) != 0n) {
        reportCycle(ptr, cycles)
      } else {
        storeCycleMarker(ptr, _VISITED_BIT)
        let comspace = ", "
        let rparen = ")"
        let mut lparen = "("
        let mut strings = [rparen]
        let ptrArray = getCompoundValueArrayRef(ptr)
        for (let mut i = tupleLength - 1n; i >= 0n; i -= 1n) {
          let item = toStringHelp(
            WasmRef.arrayAnyGet(ptrArray, i),
            extraIndents,
            false,
            cycles
          )
          strings = [item, ...strings]
          if (i > 0n) {
            strings = [comspace, ...strings]
          }
        }
        storeCycleMarker(ptr, 0n)

        strings = [lparen, ...strings]
        if (tupleLength <= 1n) {
          // Special case: unary tuple, which is not valid Grain syntax; however, boxed values
          // are stored as a unary tuple, so we keep this in case one gets printed
          strings = ["box", ...strings]
        }
        join([cyclePrefix(ptr, cycles), ...strings])
      }
    },
    t when t == Tags._GRAIN_LAMBDA_HEAP_TAG => {
      "<lambda>"
    },
    _ => {
      let strings = [
        "<unknown heap tag type: 0x",
        NumberUtils.itoa32(tag, 16n),
        ">",
      ]
      join(strings)
    },
  }
}
and toStringHelp = (grainValue, extraIndents, toplevel, cycles) => {
  if (WasmRef.isRefI31(grainValue)) {
    if (grainValue is WasmRef.fromGrain(true)) {
      return "true"
    } else if (grainValue is WasmRef.fromGrain(false)) {
      return "false"
    } else if (grainValue is WasmRef.fromGrain(void)) {
      return "void"
    }

    let grainValue = WasmRef.i31GetS(grainValue)
    if ((grainValue & 1n) != 0n) {
      // Simple (unboxed) numbers
      return NumberUtils.itoa32(grainValue >> 1n, 10n)
    } else {
      let tag = grainValue & 7n
      if (tag == Tags._GRAIN_SHORTVAL_TAG_TYPE) {
        let shortVal = grainValue >> 8n
        let shortValTag = (grainValue & 0xF8n) >> 3n
        if (shortValTag == Tags._GRAIN_CHAR_SHORTVAL_TAG) {
          let byteCount = usvEncodeLength(shortVal)
          let string = allocateString(byteCount)
          writeUtf8CodePoint(getStringArrayRef(string), 0n, shortVal)
          let string = WasmRef.toGrain(string): String
          if (toplevel) {
            return string
          } else {
            return escapeChar(string)
          }
        } else if (
          shortValTag == Tags._GRAIN_INT8_SHORTVAL_TAG
          || shortValTag == Tags._GRAIN_INT16_SHORTVAL_TAG
        ) {
          return NumberUtils.itoa32(shortVal, 10n)
        } else if (
          shortValTag == Tags._GRAIN_UINT8_SHORTVAL_TAG
          || shortValTag == Tags._GRAIN_UINT16_SHORTVAL_TAG
        ) {
          return NumberUtils.utoa32(shortVal, 10n)
        } else {
          return "<unknown small value>"
        }
      } else {
        return "<unknown value>"
      }
    }
  } else {
    return heapValueToString(grainValue, extraIndents, toplevel, cycles)
  }
}
and listToString = (ptr, extraIndents, cycles) => {
  let mut cur = ptr
  let mut isFirst = true

  let lbrack = "["
  let commaspace = ", "
  let mut strings = [lbrack]

  while (true) {
    let variantId = untagSimpleNumber(WasmRef.toGrain(loadAdtVariant(cur)))
    if (variantId == 1n) {
      break
    } else {
      if (!isFirst) {
        strings = [commaspace, ...strings]
      }
      isFirst = false
      let ptrArray = getCompoundValueArrayRef(cur)
      let item = toStringHelp(
        WasmRef.arrayAnyGet(ptrArray, 0n),
        extraIndents,
        false,
        cycles
      )
      strings = [item, ...strings]
      cur = WasmRef.arrayAnyGet(ptrArray, 1n)
    }
  }
  let rbrack = "]"
  strings = [rbrack, ...strings]
  let reversed = reverse(strings)
  join(reversed)
}
and tupleVariantToString = (ptr, variantName, extraIndents, cycles) => {
  let ptrArray = getCompoundValueArrayRef(ptr)
  let variantArity = WasmRef.arrayLen(ptrArray)
  if (variantArity == 0n) {
    variantName
  } else {
    let comspace = ", "
    let rparen = ")"
    let mut strings = [rparen]
    for (let mut i = variantArity - 1n; i >= 0n; i -= 1n) {
      let tmp = toStringHelp(
        WasmRef.arrayAnyGet(ptrArray, i),
        extraIndents,
        false,
        cycles
      )
      strings = [tmp, ...strings]
      if (i > 0n) {
        strings = [comspace, ...strings]
      }
    }
    let lparen = "("
    strings = [variantName, lparen, ...strings]

    join(strings)
  }
}
and recordToString = (ptr, recordArity, fields, extraIndents, cycles) => {
  let prevPadAmount = extraIndents * 2n
  let prevSpacePadding = if (prevPadAmount == 0n) {
    ""
  } else {
    let v = allocateString(prevPadAmount)
    Memory.fillArrayI8(getStringArrayRef(v), 0n, 0x20n, prevPadAmount) // create indentation for closing brace
    WasmRef.toGrain(v): String
  }
  let padAmount = (extraIndents + 1n) * 2n
  let spacePadding = allocateString(padAmount)
  Memory.fillArrayI8(getStringArrayRef(spacePadding), 0n, 0x20n, padAmount) // create indentation
  let spacePadding = WasmRef.toGrain(spacePadding): String
  let newline = "\n"
  let rbrace = "}"
  let mut strings = [newline, prevSpacePadding, rbrace]
  let colspace = ": "
  let comlf = ",\n"
  for (let mut i = recordArity - 1n; i >= 0n; i -= 1n) {
    let fieldName = WasmRef.toGrain(WasmRef.arrayAnyGet(fields, i)): String
    let fieldValue = toStringHelp(
      WasmRef.arrayAnyGet(ptr, i),
      extraIndents + 1n,
      false,
      cycles
    )
    strings = [spacePadding, fieldName, colspace, fieldValue, ...strings]
    if (i > 0n) {
      strings = [comlf, ...strings]
    }
  }
  let lbrace = "{\n"
  strings = [lbrace, ...strings]

  join(strings)
}

/**
 * Converts the given operand to a string.
 * Provides a better representation of data types if those types are provided from the module.
 *
 * @param value: The operand
 * @returns The operand, as a string
 *
 * @since v0.1.0
 */
@unsafe
provide let toString = value => {
  let ptr = WasmRef.fromGrain(value)
  let cycles = makeVec()
  toStringHelp(ptr, 0n, true, cycles)
}

/**
 * Prints the given operand to the console. Works for any type. Internally, calls `toString`
 * on the operand, so a better representation of data type will be printed if those types
 * are provided from the module.
 *
 * @param value: The operand
 * @param suffix: The string to print after the argument
 *
 * @since v0.1.0
 * @history v0.6.0: Added support for custom suffixes
 */
@unsafe
provide let print = (value, suffix="\n") => {
  // First convert the value to string, if it isn't one already.
  let valueRef = getStringArrayRef(WasmRef.fromGrain(toString(value)))
  let suffixRef = getStringArrayRef(WasmRef.fromGrain(suffix))
  let valueLength = WasmRef.arrayLen(valueRef)
  let suffixLength = WasmRef.arrayLen(suffixRef)
  let length = valueLength + suffixLength
  let ptr = Malloc.malloc(length)
  Memory.copyRefArrayToLinearMemory(ptr, valueRef, valueLength)
  Memory.copyRefArrayToLinearMemory(ptr + valueLength, suffixRef, suffixLength)

  // iov: [<ptr to string> <nbytes of string>]
  // buf: <iov> <written>
  // fd_write(STDOUT (1), iov, len(iov), written)
  let buf = Malloc.malloc(12n)
  let iov = buf
  let written = buf + 8n
  WasmI32.store(iov, ptr, 0n)
  WasmI32.store(iov, length, 4n)

  fd_write(1n, iov, 1n, written)

  Malloc.free(buf)
  Malloc.free(ptr)

  void
}
