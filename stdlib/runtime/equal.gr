@noPervasives
module Equal

from "runtime/unsafe/memory" include Memory
from "runtime/unsafe/wasmi32" include WasmI32
use WasmI32.{
  (==),
  (!=),
  (&),
  (^),
  (+),
  (-),
  (*),
  (<),
  remS as (%),
  (<<),
  (>>),
}
from "runtime/unsafe/wasmi64" include WasmI64
from "runtime/unsafe/wasmf32" include WasmF32
from "runtime/unsafe/wasmref" include WasmRef
from "runtime/unsafe/tags" include Tags
from "runtime/dataStructures" include DataStructures
use DataStructures.{ tagSimpleNumber, untagSimpleNumber }
from "runtime/numbers" include Numbers
use Numbers.{ isNumber, numberEqual }

primitive (!) = "@not"
primitive (||) = "@or"
primitive (&&) = "@and"
primitive (is) = "@is"
primitive ignore = "@ignore"
primitive builtinId = "@builtin.id"

@unsafe
let _LIST_ID = WasmRef.fromGrain(builtinId("List"))

@unsafe
let cycleMarker = 0x1n

@unsafe
let rec heapEqualHelp = (heapTag, xptr, yptr) => {
  match (heapTag) {
    t when t == Tags._GRAIN_ADT_HEAP_TAG => {
      // Check if the same constructor variant
      let mut xVariantTag = untagSimpleNumber(
        WasmRef.toGrain(DataStructures.loadAdtVariant(xptr))
      )
      let mut yVariantTag = untagSimpleNumber(
        WasmRef.toGrain(DataStructures.loadAdtVariant(yptr))
      )
      if (xVariantTag != yVariantTag) {
        return false
      }

      let xarray = DataStructures.getCompoundValueArrayRef(xptr)
      let yarray = DataStructures.getCompoundValueArrayRef(yptr)

      // Handle lists separately to avoid stack overflow
      if (DataStructures.loadVariantTypeId(xptr) is _LIST_ID) {
        if (xVariantTag >> 1n == 1n) return true // End of list

        if (
          !equalHelp(
            WasmRef.arrayAnyGet(xptr, 0n),
            WasmRef.arrayAnyGet(yptr, 0n)
          )
        ) {
          return false
        }

        return equalHelp(
          WasmRef.arrayAnyGet(xptr, 1n),
          WasmRef.arrayAnyGet(yptr, 1n)
        )
      } else {
        let xarity = WasmRef.arrayLen(xarray)
        let yarity = WasmRef.arrayLen(yarray)

        // Cycle check
        if (DataStructures.loadCycleMarker(xptr) == cycleMarker) {
          return true
        }

        DataStructures.storeCycleMarker(xptr, cycleMarker)
        DataStructures.storeCycleMarker(yptr, cycleMarker)

        for (let mut i = 0n; i < xarity; i += 1n) {
          if (
            !equalHelp(
              WasmRef.arrayAnyGet(xptr, i),
              WasmRef.arrayAnyGet(yptr, i)
            )
          ) {
            DataStructures.storeCycleMarker(xptr, 0n)
            DataStructures.storeCycleMarker(yptr, 0n)
            return false
          }
        }

        DataStructures.storeCycleMarker(xptr, 0n)
        DataStructures.storeCycleMarker(yptr, 0n)

        return true
      }
    },
    t when t == Tags._GRAIN_RECORD_HEAP_TAG => {
      let xarray = DataStructures.getCompoundValueArrayRef(xptr)
      let yarray = DataStructures.getCompoundValueArrayRef(yptr)

      let xlength = WasmRef.arrayLen(xarray)
      let ylength = WasmRef.arrayLen(yarray)

      // Cycle check
      if (DataStructures.loadCycleMarker(xptr) == cycleMarker) {
        return true
      }

      DataStructures.storeCycleMarker(xptr, cycleMarker)
      DataStructures.storeCycleMarker(yptr, cycleMarker)

      for (let mut i = 0n; i < xlength; i += 1n) {
        if (
          !equalHelp(WasmRef.arrayAnyGet(xptr, i), WasmRef.arrayAnyGet(yptr, i))
        ) {
          DataStructures.storeCycleMarker(xptr, 0n)
          DataStructures.storeCycleMarker(yptr, 0n)
          return false
        }
      }

      DataStructures.storeCycleMarker(xptr, 0n)
      DataStructures.storeCycleMarker(yptr, 0n)

      return true
    },
    t when t == Tags._GRAIN_ARRAY_HEAP_TAG => {
      let xarray = DataStructures.getCompoundValueArrayRef(xptr)
      let yarray = DataStructures.getCompoundValueArrayRef(yptr)

      let xlength = WasmRef.arrayLen(xarray)
      let ylength = WasmRef.arrayLen(yarray)

      // Check if the same length
      if (xlength != ylength) {
        return false
      }

      // Cycle check
      if (DataStructures.loadCycleMarker(xptr) == cycleMarker) {
        return true
      }

      DataStructures.storeCycleMarker(xptr, cycleMarker)
      DataStructures.storeCycleMarker(yptr, cycleMarker)

      for (let mut i = 0n; i < xlength; i += 1n) {
        if (
          !equalHelp(WasmRef.arrayAnyGet(xptr, i), WasmRef.arrayAnyGet(yptr, i))
        ) {
          DataStructures.storeCycleMarker(xptr, 0n)
          DataStructures.storeCycleMarker(yptr, 0n)
          return false
        }
      }

      DataStructures.storeCycleMarker(xptr, 0n)
      DataStructures.storeCycleMarker(yptr, 0n)

      return true
    },
    t when t == Tags._GRAIN_STRING_HEAP_TAG => {
      let xarray = DataStructures.getStringArrayRef(xptr)
      let yarray = DataStructures.getStringArrayRef(yptr)

      let xlength = WasmRef.arrayLen(xarray)
      let ylength = WasmRef.arrayLen(yarray)

      // Check if the same length
      return if (xlength != ylength) {
        false
      } else {
        Memory.compareArrayI8(xarray, yarray, xlength) == 0n
      }
    },
    t when t == Tags._GRAIN_BYTES_HEAP_TAG => {
      let xarray = DataStructures.getBytesArrayRef(xptr)
      let yarray = DataStructures.getBytesArrayRef(yptr)

      let xlength = WasmRef.arrayLen(xarray)
      let ylength = WasmRef.arrayLen(yarray)

      // Check if the same length
      return if (xlength != ylength) {
        false
      } else {
        Memory.compareArrayI8(xarray, yarray, xlength) == 0n
      }
    },
    t when t == Tags._GRAIN_TUPLE_HEAP_TAG => {
      let xarray = DataStructures.getCompoundValueArrayRef(xptr)
      let yarray = DataStructures.getCompoundValueArrayRef(yptr)

      let xsize = WasmRef.arrayLen(xarray)
      let ysize = WasmRef.arrayLen(yarray)

      // Cycle check
      if (DataStructures.loadCycleMarker(xptr) == cycleMarker) {
        return true
      }

      DataStructures.storeCycleMarker(xptr, cycleMarker)
      DataStructures.storeCycleMarker(yptr, cycleMarker)

      for (let mut i = 0n; i < xsize; i += 1n) {
        if (
          !equalHelp(WasmRef.arrayAnyGet(xptr, i), WasmRef.arrayAnyGet(yptr, i))
        ) {
          DataStructures.storeCycleMarker(xptr, 0n)
          DataStructures.storeCycleMarker(yptr, 0n)
          return false
        }
      }

      DataStructures.storeCycleMarker(xptr, 0n)
      DataStructures.storeCycleMarker(yptr, 0n)

      return true
    },
    t when t == Tags._GRAIN_INT32_HEAP_TAG => {
      let xval = DataStructures.getInt32Value(xptr)
      let yval = DataStructures.getInt32Value(yptr)
      return xval == yval
    },
    t when t == Tags._GRAIN_UINT32_HEAP_TAG => {
      let xval = DataStructures.getUint32Value(xptr)
      let yval = DataStructures.getUint32Value(yptr)
      return xval == yval
    },
    // Float32 is handled by equalHelp directly
    t when t == Tags._GRAIN_UINT64_HEAP_TAG => {
      use WasmI64.{ (==) }
      let xval = DataStructures.getUint64Value(xptr)
      let yval = DataStructures.getUint64Value(yptr)
      return xval == yval
    },
    // No other implementation
    _ => return xptr is yptr,
  }
}
and equalHelp = (x, y) => {
  if (WasmRef.isRefI31(x) && WasmRef.isRefI31(y)) {
    // Short circuit for non-pointer values
    x is y
  } else if (isNumber(x)) {
    // Numbers have special equality rules, e.g. NaN != NaN
    numberEqual(x, y)
  } else if (DataStructures.loadValueTag(x) == Tags._GRAIN_FLOAT32_HEAP_TAG) {
    // Short circuit for Float32 to correctly handle NaN != NaN
    let xval = DataStructures.getFloat32Value(x)
    let yval = DataStructures.getFloat32Value(y)
    use WasmF32.{ (==) }
    xval == yval
  } else {
    // Handle all other heap allocated things
    // Can short circuit if pointers are the same
    x is y || heapEqualHelp(DataStructures.loadValueTag(x), x, y)
  }
}

/**
 * Check that two values are equal. This checks for structural equality,
 * so it also works for comparing things like tuples and lists.
 *
 * @param value1: The first operand
 * @param value2: The second operand
 * @returns `true` if the values are structurally equal or `false` otherwise
 *
 * @since v0.1.0
 */
@unsafe
provide let equal = (value1: a, value2: a) => {
  equalHelp(WasmRef.fromGrain(value1), WasmRef.fromGrain(value2))
}
