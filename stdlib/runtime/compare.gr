@noPervasives
module Compare

from "runtime/unsafe/wasmi32" include WasmI32
use WasmI32.{
  (==),
  (!=),
  (&),
  (^),
  (|),
  (+),
  (-),
  (*),
  (<),
  (>),
  remS as (%),
  (<<),
  (>>>),
}
from "runtime/unsafe/wasmi64" include WasmI64
from "runtime/unsafe/wasmf32" include WasmF32
from "runtime/unsafe/wasmref" include WasmRef
from "runtime/unsafe/memory" include Memory
from "runtime/unsafe/tags" include Tags
from "runtime/dataStructures" include DataStructures
use DataStructures.{ tagSimpleNumber, untagSimpleNumber }
from "runtime/numbers" include Numbers
use Numbers.{ isNumber, cmp as numberCompare }

primitive (!) = "@not"
primitive (||) = "@or"
primitive (&&) = "@and"
primitive (is) = "@is"
let (isnt) = (x, y) => !(x is y)

@unsafe
let rec heapCompareHelp = (heapTag, xptr: WasmRef, yptr: WasmRef) => {
  match (heapTag) {
    t when t == Tags._GRAIN_ADT_HEAP_TAG => {
      // Check if the same constructor variant
      let xvariant = untagSimpleNumber(
        WasmRef.toGrain(DataStructures.loadAdtVariant(xptr))
      )
      let yvariant = untagSimpleNumber(
        WasmRef.toGrain(DataStructures.loadAdtVariant(yptr))
      )
      if (xvariant != yvariant) {
        return tagSimpleNumber(xvariant - yvariant)
      }

      let xarray = DataStructures.getVariantArrayRef(xptr)
      let yarray = DataStructures.getVariantArrayRef(yptr)

      let xarity = WasmRef.arrayLen(xarray)
      let yarity = WasmRef.arrayLen(yarray)

      for (let mut i = 0n; i < xarity; i += 1n) {
        let sub = compareHelp(
          WasmRef.arrayAnyGet(xarray, i),
          WasmRef.arrayAnyGet(yarray, i)
        )
        if (WasmRef.i31GetS(WasmRef.fromGrain(sub)) != 0n) {
          return sub
        }
      }

      return 0
    },
    t when t == Tags._GRAIN_RECORD_HEAP_TAG => {
      let xarray = DataStructures.getRecordArrayRef(xptr)
      let yarray = DataStructures.getRecordArrayRef(yptr)

      let xlength = WasmRef.arrayLen(xarray)
      let ylength = WasmRef.arrayLen(yarray)

      for (let mut i = 0n; i < xlength; i += 1n) {
        let sub = compareHelp(
          WasmRef.arrayAnyGet(xarray, i),
          WasmRef.arrayAnyGet(yarray, i)
        )
        if (WasmRef.i31GetS(WasmRef.fromGrain(sub)) != 0n) {
          return sub
        }
      }

      return 0
    },
    t when t == Tags._GRAIN_ARRAY_HEAP_TAG => {
      let xarray = DataStructures.getArrayArrayRef(xptr)
      let yarray = DataStructures.getArrayArrayRef(yptr)

      let xlength = WasmRef.arrayLen(xarray)
      let ylength = WasmRef.arrayLen(yarray)

      // Check if the same length
      if (xlength != ylength) {
        return tagSimpleNumber(xlength - ylength)
      }
      for (let mut i = 0n; i < xlength; i += 1n) {
        let sub = compareHelp(
          WasmRef.arrayAnyGet(xarray, i),
          WasmRef.arrayAnyGet(yarray, i)
        )
        if (WasmRef.i31GetS(WasmRef.fromGrain(sub)) != 0n) {
          return sub
        }
      }

      return 0
    },
    t when t == Tags._GRAIN_STRING_HEAP_TAG => {
      let xarray = DataStructures.getStringArrayRef(xptr)
      let yarray = DataStructures.getStringArrayRef(yptr)

      let xlength = WasmRef.arrayLen(xarray)
      let ylength = WasmRef.arrayLen(yarray)

      if (xlength == ylength) {
        return tagSimpleNumber(Memory.compareArrayI8(xarray, yarray, xlength))
      }
      if (xlength < ylength) {
        let sub = Memory.compareArrayI8(xarray, yarray, xlength)
        // The shorter one comes first
        return if (sub == 0n) -1 else tagSimpleNumber(sub)
      } else {
        let sub = Memory.compareArrayI8(xarray, yarray, ylength)
        // The shorter one comes first
        return if (sub == 0n) 1 else tagSimpleNumber(sub)
      }
    },
    t when t == Tags._GRAIN_BYTES_HEAP_TAG => {
      let xarray = DataStructures.getStringArrayRef(xptr)
      let yarray = DataStructures.getStringArrayRef(yptr)

      let xlength = WasmRef.arrayLen(xarray)
      let ylength = WasmRef.arrayLen(yarray)

      if (xlength == ylength) {
        return tagSimpleNumber(Memory.compareArrayI8(xarray, yarray, xlength))
      }
      if (xlength < ylength) {
        let sub = Memory.compareArrayI8(xarray, yarray, xlength)
        // The shorter one comes first
        return if (sub == 0n) -1 else tagSimpleNumber(sub)
      } else {
        let sub = Memory.compareArrayI8(xarray, yarray, ylength)
        // The shorter one comes first
        return if (sub == 0n) 1 else tagSimpleNumber(sub)
      }
    },
    t when t == Tags._GRAIN_TUPLE_HEAP_TAG => {
      let xarray = DataStructures.getStringArrayRef(xptr)
      let yarray = DataStructures.getStringArrayRef(yptr)

      let xsize = WasmRef.arrayLen(xarray)
      let ysize = WasmRef.arrayLen(yarray)

      for (let mut i = 0n; i < xsize; i += 1n) {
        let sub = compareHelp(
          WasmRef.arrayAnyGet(xarray, i),
          WasmRef.arrayAnyGet(yarray, i)
        )
        if (WasmRef.i31GetS(WasmRef.fromGrain(sub)) != 0n) {
          return sub
        }
      }

      return 0
    },
    t when t == Tags._GRAIN_INT32_HEAP_TAG => {
      let xval = DataStructures.getInt32Value(xptr)
      let yval = DataStructures.getInt32Value(yptr)
      return if (xval < yval) {
        -1
      } else if (xval > yval) {
        1
      } else {
        0
      }
    },
    // Float32 is handled by compareHelp directly
    t when t == Tags._GRAIN_UINT32_HEAP_TAG => {
      let xval = DataStructures.getUint32Value(xptr)
      let yval = DataStructures.getUint32Value(yptr)
      return if (WasmI32.ltU(xval, yval)) {
        -1
      } else if (WasmI32.gtU(xval, yval)) {
        1
      } else {
        0
      }
    },
    t when t == Tags._GRAIN_UINT64_HEAP_TAG => {
      let xval = DataStructures.getUint64Value(xptr)
      let yval = DataStructures.getUint64Value(yptr)
      return if (WasmI64.ltU(xval, yval)) {
        -1
      } else if (WasmI64.gtU(xval, yval)) {
        1
      } else {
        0
      }
    },
    _ => {
      // No other implementation
      return -1
    },
  }
}
and compareHelp = (x, y) => {
  if (WasmRef.isRefI31(x) && WasmRef.isRefI31(y)) {
    let xi32 = WasmRef.i31GetS(x)
    let yi32 = WasmRef.i31GetS(y)
    let xtag = xi32 & Tags._GRAIN_GENERIC_TAG_MASK
    let ytag = yi32 & Tags._GRAIN_GENERIC_TAG_MASK
    // Short circuit for non-pointer values
    if ((xtag & Tags._GRAIN_NUMBER_TAG_MASK) == Tags._GRAIN_NUMBER_TAG_TYPE) {
      // Signed comparisons are necessary for numbers
      if (xi32 < yi32) {
        -1
      } else if (xi32 > yi32) {
        1
      } else {
        0
      }
    } else if (xtag == Tags._GRAIN_SHORTVAL_TAG_TYPE) {
      let shortValTag = xi32 & Tags._GRAIN_GENERIC_SHORTVAL_TAG_MASK
      if (
        shortValTag == Tags._GRAIN_INT8_TAG_MASK
        || shortValTag == Tags._GRAIN_INT16_TAG_MASK
      ) {
        tagSimpleNumber(xi32 - yi32)
      } else {
        if (WasmI32.ltU(xi32, yi32)) {
          -1
        } else if (WasmI32.gtU(xi32, yi32)) {
          1
        } else {
          0
        }
      }
    } else {
      // Unsigned comparisons are necessary for other stack-allocated values
      if (WasmI32.ltU(xi32, yi32)) {
        -1
      } else if (WasmI32.gtU(xi32, yi32)) {
        1
      } else {
        0
      }
    }
  } else if (isNumber(x)) {
    // Numbers have special comparison rules, e.g. NaN == NaN
    tagSimpleNumber(numberCompare(x, y))
  } else if (DataStructures.loadValueTag(x) == Tags._GRAIN_FLOAT32_HEAP_TAG) {
    // Short circuit for Float32 to correctly handle NaN comparisons
    let xval = DataStructures.getFloat32Value(x)
    let yval = DataStructures.getFloat32Value(y)
    use WasmF32.{ (!=) }
    let xIsNaN = xval != xval
    let yIsNaN = yval != yval
    if (xIsNaN) {
      if (yIsNaN) 0 else -1
    } else if (yIsNaN) {
      // x is confirmed to be not NaN at this point
      1
    } else {
      use WasmF32.{ (<), (>) }
      if (xval < yval) {
        -1
      } else if (xval > yval) {
        1
      } else {
        0
      }
    }
  } else {
    // Handle all other heap allocated things
    // Can short circuit if pointers are the same
    if (x is y) {
      0
    } else {
      heapCompareHelp(DataStructures.loadValueTag(x), x, y)
    }
  }
}

/**
 * Compares the first argument to the second argument and produces an integer result.
 * Provides a consistent ordering over all types and is suitable for sorting and other kinds of ordering.
 * `compare` treats `NaN` differently than the other comparison operators in that it considers `NaN` equal to itself and smaller than any other number.
 *
 * @param num1: The first operand
 * @param num2: The second operand
 * @returns A negative integer if the first operand is less than the second operand, `0` if they are equal, or a positive integer otherwise
 *
 * @since v0.5.3
 */
@unsafe
provide let compare = (num1: a, num2: a) => {
  compareHelp(WasmRef.fromGrain(num1), WasmRef.fromGrain(num2))
}
