@noPervasives
module Bigint

/**
 * Arbitary-precision integers.
 */

// Useful reading:
// Modern Computer Arithmetic, Richard Brent and Paul Zimmermann, Cambridge University Press, 2010.
// https://members.loria.fr/PZimmermann/mca/pub226.html

/*
This file is *not* a direct port of `nim-lang/bigints`, but pieces of it are, and it does draw substantial inspiration from it.
The following is the copyright notice from the `nim-lang/bigints` project (MIT License same as license for Grain standard library):

Copyright 2019 Dennis Felsing
*/
from "runtime/unsafe/memory" include Memory
from "runtime/unsafe/tags" include Tags
from "runtime/unsafe/constants" include Constants
use Constants.{ _UMAX_I64, _SMAX32_I64, _SMAX_I64, _SMAX_I32 }
from "runtime/unsafe/wasmi32" include WasmI32
from "runtime/unsafe/wasmi64" include WasmI64
from "runtime/unsafe/wasmf32" include WasmF32
from "runtime/unsafe/wasmf64" include WasmF64
from "runtime/exception" include Exception
from "runtime/dataStructures" include DataStructures as DS
from "runtime/utils/printing" include Printing as RPrint

// things we need which are missing due to --no-pervasives:
primitive (!) = "@not"
primitive (&&) = "@and"
primitive (||) = "@or"
primitive throw = "@throw"

// Layout:
// -------------------------------------------------------
// | numtag | tag | size | flags | <reserved> | limbs... |
// -------------------------------------------------------
//
// numtag  | i32    | always _GRAIN_BOXED_NUM_HEAP_TAG
// tag     | i32    | always _GRAIN_BIGINT_BOXED_NUM_TAG
// size    | i32    | the number of limbs. If negative, the bigint is negative
// flags   | i16    | bitflags used for algorithm implementations (see below)
// <res.>  | i16    | reserved for future use
// limbs   | i64... |

// NOTE: As this layout is similar to GMP's, we have the same type of limitation
//       on integer size (16 GiB, since we reject sizes with MSB of 1; see init())
//       (https://stackoverflow.com/a/62530477)

// Flags:
// 1 - NEGATIVE: set to 1 if the number is negative

// Outline of future strategy for fixints:
// - the <reserved> portion will become the number of limbs, and we'll have an _IS_FIXINT flag (so fixints can be 1-15 64-bit dwords)
// - fixints will always internally be positive numbers in the range [0, 2^{64*n})
//   - (this should make most operations' implementations work pretty seamlessly)
// - when printing, we check if the MSB is a 1, and, if so, allocate a new temporary non-fixint with the twos complement and print that

@unsafe
let _IS_NEGATIVE = 1n

@unsafe
let maxu32 = (a, b) => {
  use WasmI32.{ ltU as (<) }
  if (a < b) b else a
}

@unsafe
let minu32 = (a, b) => {
  use WasmI32.{ ltU as (<) }
  if (a < b) a else b
}

@unsafe
let minu64 = (a, b) => {
  use WasmI32.{ ltU as (<) }
  if (a < b) a else b
}

@unsafe
let absi32 = n => {
  use WasmI32.{ (>>), (^), (-) }
  let temp = n >> 31n
  let n = n ^ temp
  n - temp
}

@unsafe
let absi64 = n => {
  use WasmI64.{ (>>), (^), (-) }
  let temp = n >> 63N
  let n = n ^ temp
  n - temp
}

@unsafe
let lnot = n => {
  use WasmI32.{ (^) }
  n ^ -1n
}

@unsafe
let init = (limbs: WasmI32) => {
  use WasmI32.{ (+), (*), (<), (==), (&) }
  if (!WasmI32.eqz(limbs & 0x80000000n)) {
    // MSB is 1. We reject these sizes because they will cause overflows
    // in our multiplication/division algorithms. This means that BigInts
    // are limited to 16+17179869176 bytes, or just over 16GiB.
    throw Exception.InvalidArgument(
      "Cannot allocate BigInt with >= 2147483648 limbs",
    )
  }

  let numtagLen = 4n
  let tagLen = 4n
  let sizeLen = 4n
  let resflagsLen = 4n
  let limbsLen = absi32(limbs) * 8n
  let len = numtagLen + tagLen + sizeLen + resflagsLen + limbsLen

  let ptr = Memory.malloc(len)
  Memory.fill(ptr, 0n, len)

  WasmI32.store(ptr, Tags._GRAIN_BOXED_NUM_HEAP_TAG, 0n)
  WasmI32.store(ptr, Tags._GRAIN_BIGINT_BOXED_NUM_TAG, 4n)
  WasmI32.store(ptr, limbs, 8n)
  WasmI32.store(ptr, 0n, 12n)

  ptr
}

// For debugging
@unsafe
provide let debugDumpNumber = (num: WasmI32) => {
  use WasmI32.{ (*), (+), (-), (&), (>>>), (<) }
  //let num = WasmI32.fromGrain(num)
  RPrint.printString("-=-=-=-== debug dump ==-=-=-=-")
  RPrint.printString("Ref Count:")
  RPrint.printNumber(WasmI64.extendI32U(WasmI32.load(num - 8n, 0n)))
  RPrint.printString("Heap Tag:")
  RPrint.printNumber(WasmI64.extendI32U(WasmI32.load(num, 0n)))
  RPrint.printString("Boxed Num Tag:")
  RPrint.printNumber(WasmI64.extendI32U(WasmI32.load(num, 4n)))
  RPrint.printString("Num Limbs:")
  let limbs = WasmI32.load(num, 8n)
  RPrint.printNumber(WasmI64.extendI32U(limbs))
  RPrint.printString("Flags:")
  RPrint.printNumber(WasmI64.extendI32U(0xffffn & WasmI32.load(num, 12n)))
  RPrint.printString("<reserved>:")
  RPrint.printNumber(
    WasmI64.extendI32U((0xffff0000n & WasmI32.load(num, 12n)) >>> 16n)
  )
  RPrint.printString("Limbs:")
  for (let mut i = 0n; i < limbs; i += 1n) {
    // if a nonzero limb is found, then we're at the min
    RPrint.printNumber(WasmI64.load(num, (i + 2n) * 8n))
  }
}

@unsafe
provide let getSize = ptr => {
  WasmI32.load(ptr, 8n)
}

@unsafe
let setSize = (ptr, n) => {
  WasmI32.store(ptr, n, 8n)
}

@unsafe
provide let getFlags = ptr => {
  WasmI32.load(ptr, 12n)
}

@unsafe
let flagIsSet = (ptr, flag) => {
  use WasmI32.{ (&), (!=) }
  (getFlags(ptr) & flag) != 0n
}

@unsafe
let getFlag = (ptr, flag) => {
  use WasmI32.{ (&), (>>>) }
  let setFlags = WasmI32.load(ptr, 12n)
  (setFlags & flag) >>> WasmI32.ctz(flag)
}

@unsafe
let setFlag = (ptr, flag, value) => {
  use WasmI32.{ (*), (|), (&) }
  let (!) = lnot
  WasmI32.store(
    ptr,
    WasmI32.load(ptr, 12n) & !flag | flag * (if (WasmI32.eqz(value)) {
      0n
    } else {
      1n
    }),
    12n
  )
}

@unsafe
provide let getLimb = (ptr, i) => {
  use WasmI32.{ (+), (*) }
  WasmI64.load(ptr, (i + 2n) * 8n)
}

@unsafe
let setLimb = (ptr, i, v) => {
  use WasmI32.{ (+), (*) }
  WasmI64.store(ptr, v, (i + 2n) * 8n)
}

@unsafe
let getHalfSize = ptr => {
  // for when it's important to know *precisely* the number of half-limbs,
  // excluding trailing zeros
  let size = getSize(ptr)
  use WasmI32.{ (-), (<<), gtU as (>) }
  use WasmI64.{ (>>>) }
  if (
    size > 0n &&
    WasmI32.eqz(WasmI32.wrapI64(getLimb(ptr, size - 1n) >>> 32N))
  ) {
    // last half-limb is trailing zeros
    (size << 1n) - 1n
  } else {
    size << 1n
  }
}

// "Half-limb" operators for 32-bit-based algorithms
// (some, such as multiplication, are simpler to implement
//  using 32-bit than with 64-bit)
@unsafe
let getHalfLimb = (ptr, i) => {
  use WasmI32.{ (+), (*) }
  WasmI32.load(ptr, (i + 4n) * 4n)
}

@unsafe
let setHalfLimb = (ptr, i, v) => {
  use WasmI32.{ (+), (*) }
  WasmI32.store(ptr, v, (i + 4n) * 4n)
}

@unsafe
let clone = (num: WasmI32) => {
  use WasmI32.{ (+), (*) }
  let len = getSize(num) * 8n + 16n
  let ret = Memory.malloc(len)
  Memory.copy(ret, num, len)
  ret
}

@unsafe
let cloneWithLen = (num: WasmI32, len: WasmI32) => {
  use WasmI32.{ (+), (*) }
  let oldlen = getSize(num) * 8n + 16n
  let newlen = len * 8n + 16n
  let ret = Memory.malloc(newlen)
  Memory.fill(ret, 0n, newlen)
  Memory.copy(ret, num, if (WasmI32.ltU(oldlen, newlen)) oldlen else newlen)
  WasmI32.store(ret, len, 8n)
  ret
}

/**
 * Remove any trailing zero limbs from the given number
 * (NOTE: Result is not guaranteed to be a new number)
 */
@unsafe
let trimNumberInPlace = (num: WasmI32) => {
  let numLimbs = getSize(num)
  let mut neededLimbs = numLimbs
  use WasmI64.{ (!=) }
  use WasmI32.{ (-), (>=), (==) }
  for (let mut i = numLimbs - 1n; i >= 0n; i -= 1n) {
    // if a nonzero limb is found, then we're at the min
    if (getLimb(num, i) != 0N) {
      break
    }
    // otherwise, this is a zero limb, so we don't need it
    neededLimbs -= 1n
  }
  let ret = if (neededLimbs == numLimbs) {
    num
  } else {
    // NOTE: We cheat here. We could clone the number, but instead
    //       we have it lie about its length. When the number is freed,
    //       it will still free the entire underlying array
    setSize(num, neededLimbs)
    num
  }
  ret
}

@unsafe
let makeZero = () => {
  init(0n)
}

@unsafe
provide let makeWrappedInt32 = (value: WasmI32) => {
  use WasmI32.{ (*), (<) }
  let ret = init(1n)
  if (value < 0n) {
    setFlag(ret, _IS_NEGATIVE, 1n)
  }
  let value = if (value < 0n) {
    value * -1n
  } else {
    value
  }
  setLimb(ret, 0n, WasmI64.extendI32U(value))
  ret
}

@unsafe
provide let makeWrappedUint32 = (value: WasmI32) => {
  let ret = init(1n)
  setLimb(ret, 0n, WasmI64.extendI32U(value))
  ret
}

@unsafe
provide let makeWrappedInt64 = (value: WasmI64) => {
  use WasmI64.{ (*), (<) }
  let ret = init(1n)
  if (value < 0N) {
    setFlag(ret, _IS_NEGATIVE, 1n)
  }
  let value = if (value < 0N) {
    value * -1N
  } else {
    value
  }
  setLimb(ret, 0n, value)
  ret
}

@unsafe
provide let makeWrappedUint64 = (value: WasmI64) => {
  let ret = init(1n)
  setLimb(ret, 0n, value)
  ret
}

@unsafe
provide let isNegative = (num: WasmI32) => {
  flagIsSet(num, _IS_NEGATIVE)
}

/**
 * Returns true if the given bigint is equal to zero
 */
@unsafe
provide let eqz = (num: WasmI32) => {
  let numLimbs = getSize(num)
  use WasmI64.{ (!=) }
  use WasmI32.{ (-), (>=) }
  for (let mut i = numLimbs - 1n; i >= 0n; i -= 1n) {
    if (getLimb(num, i) != 0N) {
      return false
    }
  }
  return true
}

@unsafe
let negateInPlace = (num: WasmI32) => {
  setFlag(num, _IS_NEGATIVE, if (flagIsSet(num, _IS_NEGATIVE)) 0n else 1n)
  num
}

@unsafe
provide let negate = (num: WasmI32) => {
  let ret = clone(num)
  setFlag(ret, _IS_NEGATIVE, if (flagIsSet(ret, _IS_NEGATIVE)) 0n else 1n)
  ret
}

@unsafe
let absInPlace = (num: WasmI32) => {
  setFlag(num, _IS_NEGATIVE, 0n)
  num
}

@unsafe
provide let abs = (num: WasmI32) => {
  let ret = clone(num)
  setFlag(ret, _IS_NEGATIVE, 0n)
  ret
}

/*
 * Conversions
 */
@unsafe
provide let canConvertToInt32 = (num: WasmI32) => {
  use WasmI64.{ leU as (<=) }
  use WasmI32.{ (==) }
  let numLimbs = getSize(num)
  if (numLimbs == 0n) {
    true
  } else if (numLimbs == 1n) {
    let limb = getLimb(num, 0n)
    limb <= _SMAX32_I64
  } else {
    false
  }
}

@unsafe
provide let toInt32 = (num: WasmI32) => {
  use WasmI64.{ leU as (<=) }
  use WasmI32.{ (==), (*) }
  let numLimbs = getSize(num)
  if (numLimbs == 0n) {
    0n
  } else if (numLimbs == 1n) {
    let limb = getLimb(num, 0n)
    if (limb <= _SMAX32_I64) {
      if (flagIsSet(num, _IS_NEGATIVE)) {
        -1n * WasmI32.wrapI64(limb)
      } else {
        WasmI32.wrapI64(limb)
      }
    } else {
      throw Exception.Overflow
    }
  } else {
    throw Exception.Overflow
  }
}

@unsafe
provide let canConvertToInt64 = (num: WasmI32) => {
  use WasmI64.{ leU as (<=) }
  use WasmI32.{ (==) }
  let numLimbs = getSize(num)
  if (numLimbs == 0n) {
    true
  } else if (numLimbs == 1n) {
    let limb = getLimb(num, 0n)
    if (limb <= _SMAX32_I64) {
      true
    } else {
      false
    }
  } else {
    false
  }
}

@unsafe
provide let toInt64 = (num: WasmI32) => {
  use WasmI64.{ leU as (<=), (*) }
  use WasmI32.{ (==) }
  let numLimbs = getSize(num)
  if (numLimbs == 0n) {
    0N
  } else if (numLimbs == 1n) {
    let limb = getLimb(num, 0n)
    if (limb <= _SMAX32_I64) {
      if (flagIsSet(num, _IS_NEGATIVE)) {
        -1N * limb
      } else {
        limb
      }
    } else {
      throw Exception.Overflow
    }
  } else {
    throw Exception.Overflow
  }
}

@unsafe
provide let toUnsignedInt64 = (num: WasmI32) => {
  use WasmI64.{ leU as (<=) }
  use WasmI32.{ (==) }
  let numLimbs = getSize(num)
  if (numLimbs == 0n) {
    0N
  } else if (numLimbs == 1n) {
    let limb = getLimb(num, 0n)
    limb
  } else {
    throw Exception.Overflow
  }
}

@unsafe
provide let toFloat64 = (num: WasmI32) => {
  // approximate!
  // semi-port of https://github.com/JuliaLang/julia/issues/31293#issuecomment-477220553
  use WasmI64.{ leU as (<=) }
  use WasmI32.{ (==) }
  use WasmF64.{ (+), (*) }
  let numLimbs = getSize(num)
  let res = if (eqz(num)) {
    0.0W
  } else if (WasmI32.gtU(numLimbs, 16n)) {
    // Float64 infinity (bigger than FLOAT_MAX)
    WasmF64.reinterpretI64(
      0b0111111111110000000000000000000000000000000000000000000000000000N
    )
  } else if (numLimbs == 1n) {
    WasmF64.convertI64U(getLimb(num, 0n))
  } else {
    // We have to convert manually. if anyone has a better way
    // to do this (performance or accuracy-wise), please submit a PR
    // factor == 2^64
    let factor = WasmF64.reinterpretI64(
      0b0100001111110000000000000000000000000000000000000000000000000000N
    )
    let mut result = 0.0W
    use WasmI32.{ (+) }
    for (let mut i = 0n; WasmI32.ltU(i, numLimbs); i += 1n) {
      if (!WasmI32.eqz(i)) {
        result *= factor
      }
      use WasmF64.{ (+) }
      result += WasmF64.convertI64U(getLimb(num, i))
    }
    result
  }
  if (flagIsSet(num, _IS_NEGATIVE)) {
    WasmF64.neg(res)
  } else {
    res
  }
}

@unsafe
provide let toFloat32 = (num: WasmI32) => {
  WasmF32.demoteF64(toFloat64(num))
}

/*
 * Comparisons
 */

@unsafe
let cmpUnsignedI64 = (num1: WasmI32, num2: WasmI64) => {
  use WasmI32.{ (-), (>=), (==), (!=) }
  use WasmI64.{ (*), (<) }
  let num1Limbs = getSize(num1)
  let num2Limbs = 1n
  let delta = num1Limbs - num2Limbs
  let num2abs = if (num2 < 0N) -1N * num2 else num2
  if (delta != 0n) {
    return delta
  }
  // num1 and num2 have the same size. Compare all limbs, high to low
  for (let mut i = num1Limbs - 1n; i >= 0n; i -= 1n) {
    let limb1 = getLimb(num1, i)
    let limb2 = if (i == 0n) num2abs else 0N
    if (WasmI64.ltU(limb1, limb2)) {
      return -1n
    } else if (WasmI64.ltU(limb2, limb1)) {
      return 1n
    }
  }

  return 0n
}

@unsafe
provide let cmpI64 = (num1: WasmI32, num2: WasmI64) => {
  use WasmI64.{ (<) }
  use WasmI32.{ (*) }
  if (eqz(num1)) {
    if (WasmI64.eqz(num2)) {
      0n
    } else if (num2 < 0N) {
      1n
    } else {
      -1n
    }
  } else if (flagIsSet(num1, _IS_NEGATIVE)) {
    if (WasmI64.eqz(num2) || !(num2 < 0N)) {
      -1n
    } else {
      -1n * cmpUnsignedI64(num1, num2)
    }
  } else {
    if (WasmI64.eqz(num2) || num2 < 0N) {
      1n
    } else {
      cmpUnsignedI64(num1, num2)
    }
  }
}

@unsafe
provide let cmpU64 = (num1: WasmI32, num2: WasmI64) => {
  if (eqz(num1)) {
    if (WasmI64.eqz(num2)) {
      0n
    } else {
      1n
    }
  } else {
    if (WasmI64.eqz(num2)) {
      1n
    } else {
      cmpUnsignedI64(num1, num2)
    }
  }
}

@unsafe
provide let cmpF64 = (num1: WasmI32, num2: WasmF64) => {
  let asf64 = toFloat64(num1)
  use WasmF64.{ (<), (>) }
  if (asf64 < num2) {
    -1n
  } else if (asf64 > num2) {
    1n
  } else {
    0n
  }
}

@unsafe
provide let cmpF32 = (num1: WasmI32, num2: WasmF32) => {
  cmpF64(num1, WasmF64.promoteF32(num2))
}

@unsafe
let cmpUnsigned = (num1: WasmI32, num2: WasmI32) => {
  use WasmI32.{ (-), (>=), (!=) }
  let num1Limbs = getSize(num1)
  let num2Limbs = getSize(num2)
  let delta = num1Limbs - num2Limbs
  if (delta != 0n) {
    return delta
  }
  // num1 and num2 have the same size. Compare all limbs, high to low
  for (let mut i = num1Limbs - 1n; i >= 0n; i -= 1n) {
    let limb1 = getLimb(num1, i)
    let limb2 = getLimb(num2, i)
    if (WasmI64.ltU(limb1, limb2)) {
      return -1n
    } else if (WasmI64.ltU(limb2, limb1)) {
      return 1n
    }
  }
  return 0n
}

@unsafe
provide let cmp = (num1: WasmI32, num2: WasmI32) => {
  if (eqz(num1)) {
    if (eqz(num2)) {
      0n
    } else if (flagIsSet(num2, _IS_NEGATIVE)) {
      1n
    } else {
      -1n
    }
  } else if (flagIsSet(num1, _IS_NEGATIVE)) {
    if (eqz(num2) || !flagIsSet(num2, _IS_NEGATIVE)) {
      -1n
    } else {
      cmpUnsigned(num2, num1)
    }
  } else {
    if (eqz(num2) || flagIsSet(num2, _IS_NEGATIVE)) {
      1n
    } else {
      cmpUnsigned(num1, num2)
    }
  }
}

@unsafe
provide let eq = (num1: WasmI32, num2: WasmI32) => {
  use WasmI32.{ (==) }
  cmp(num1, num2) == 0n
}

@unsafe
provide let ne = (num1: WasmI32, num2: WasmI32) => {
  use WasmI32.{ (!=) }
  cmp(num1, num2) != 0n
}

@unsafe
provide let lt = (num1: WasmI32, num2: WasmI32) => {
  use WasmI32.{ (<) }
  cmp(num1, num2) < 0n
}

@unsafe
provide let lte = (num1: WasmI32, num2: WasmI32) => {
  use WasmI32.{ (<=) }
  cmp(num1, num2) <= 0n
}

@unsafe
provide let gt = (num1: WasmI32, num2: WasmI32) => {
  use WasmI32.{ (>) }
  cmp(num1, num2) > 0n
}

@unsafe
provide let gte = (num1: WasmI32, num2: WasmI32) => {
  use WasmI32.{ (>=) }
  cmp(num1, num2) >= 0n
}

/*
 * String Utilities
 */

@unsafe
let countTrailingZeroBits = (num: WasmI32) => {
  let numLimbs = getSize(num)
  use WasmI64.{ (!=) }
  use WasmI32.{ (+), (<) }
  let mut result = 0n
  for (let mut i = 0n; i < numLimbs; i += 1n) {
    let limb = getLimb(num, i)
    if (limb != 0N) {
      result += WasmI32.wrapI64(WasmI64.ctz(limb))
      break
    } else {
      result += 64n
    }
  }
  result
}

let _DIGITS = "0123456789abcdefghijklmnopqrstuvwxyz"
// maximum number of digits that can fully fit a uint64 (for each valid base):
let _SIZES = [>
  0,
  0,
  64, // 2
  40, // 3
  32, // 4
  27, // 5
  24, // 6
  22, // 7
  21, // 8
  20, // 9
  19, // 10
  18, // 11
  17, // 12
  17, // 13
  16, // 14
  16, // 15
  16, // 16
  15, // 17
  15, // 18
  15, // 19
  14, // 20
  14, //
  14, //
  14, // 23
  13, // 24
  13, //
  13, //
  13, //
  13, //
  13, //
  13, //
  12,
  12,
  12,
  12,
  12,
  12,
]

@unsafe
provide let bigIntToString = (num: WasmI32, base: WasmI32) => {
  use WasmI32.{ (+), (<), (>) }
  let getDigit = n => WasmI32.load8U(WasmI32.fromGrain(_DIGITS) + n, 8n)
  if (base < 2n || base > 32n) {
    throw Exception.InvalidArgument("toString base must be in range [2,32]")
  }
  use WasmI64.{ (-), (*), (|), (<<), (>) }
  if (eqz(num)) {
    "0"
  } else {
    let size = DS.untagSimpleNumber(_SIZES[DS.tagSimpleNumber(base)])
    use WasmI32.{ (==), (-) as subWasmI32 }
    let mut result = []
    if (base == 2n || base == 4n || base == 8n || base == 16n || base == 32n) {
      // if base is a power of two, use optimized path
      let bits = WasmI64.extendI32U(WasmI32.ctz(base))
      let mask = (1N << bits) - 1N
      let numLimbs = getSize(num)
      let totalBits = 64N * WasmI64.extendI32U(numLimbs) -
        WasmI64.clz(getLimb(num, subWasmI32(numLimbs, 1n)))
      let mut acc = 0N
      let mut accBits = 0N
      for (let mut i = 0n; i < numLimbs; i += 1n) {
        use WasmI64.{ (+), (&), (>>>), (>=) }
        let limb = getLimb(num, i)
        acc = acc | limb << accBits
        accBits += 64N
        while (accBits >= bits) {
          result = [
            DS.tagChar(getDigit(WasmI32.wrapI64(acc & mask))),
            ...result
          ]
          acc = acc >>> bits
          if (accBits > 64N) {
            acc = limb >>> (64N - (accBits - bits))
          }
          accBits -= bits
        }
      }
      if (acc > 0N) {
        result = [DS.tagChar(getDigit(WasmI32.wrapI64(acc))), ...result]
      }
    } else {
      let base = WasmI64.extendI32U(base)
      let d = base
      let mut tmp = clone(num)
      setFlag(tmp, _IS_NEGATIVE, 0n)
      while (!eqz(tmp)) {
        use WasmI32.{ (-), (<<), (>=) }
        let tmpCopy = tmp
        let numLimbs = getSize(tmpCopy)
        tmp = init(numLimbs)
        let mut c = 0N
        let numHalfLimbs = numLimbs << 1n
        for (let mut i = numHalfLimbs - 1n; i >= 0n; i -= 1n) {
          use WasmI64.{ (+), divU as (/), remU as (%), (<<) }
          use WasmI32.{ (-) }
          let halfLimb = getHalfLimb(tmpCopy, i)
          // we need this if to exclude the trailing 0 half-limb, if it exists
          if (!(halfLimb == 0n && numHalfLimbs - 1n == i)) {
            let tmpInner = WasmI64.extendI32U(halfLimb) + (c << 32N)
            setHalfLimb(tmp, i, WasmI32.wrapI64(tmpInner / d))
            c = tmpInner % d
          }
        }
        Memory.decRef(tmpCopy)
        tmp = trimNumberInPlace(tmp)
        result = [
          DS.tagChar(getDigit(WasmI32.wrapI64(WasmI64.remU(c, base)))),
          ...result
        ]
      }
    }
    while (match (result) {
      [c, ...tl] when DS.untagChar(c) == DS.untagChar('0') => true,
      _ => false,
    }) {
      match (result) {
        [c, ...tl] => result = tl,
        _ => void, // <- impossible
      }
    }
    if (flagIsSet(num, _IS_NEGATIVE)) {
      result = ['-', ...result]
    }
    @unsafe
    let rec computeLength = (lst, acc) => {
      match (lst) {
        [] => acc,
        [_, ...tl] => computeLength(tl, acc + 1n),
      }
    }
    let length = computeLength(result, 0n)
    let ret = DS.allocateString(length)
    @unsafe
    let rec populateString = (lst, idx, str) => {
      match (lst) {
        [] => void,
        [hd, ...tl] => {
          WasmI32.store8(str + idx, DS.untagChar(hd), 8n)
          populateString(tl, idx + 1n, str)
        },
      }
    }
    populateString(result, 0n, ret)
    WasmI32.toGrain(ret): String
  }
}

@unsafe
provide let bigIntToString10 = (num: WasmI32) => {
  bigIntToString(num, 10n)
}

/*
 * Addition and Subtraction
 */

@unsafe
let unsignedAdd = (num1: WasmI32, num2: WasmI32) => {
  use WasmI64.{ (!=) }
  use WasmI32.{ (+), (&), (|), ltU as (<), geU as (>=), (==) }
  let num1Limbs = getSize(num1)
  let num2Limbs = getSize(num2)
  let n = maxu32(num1Limbs, num2Limbs)
  let mut dest = init(n)
  let mut carry = 0N
  for (let mut i = 0n; i < n; i += 1n) {
    use WasmI64.{ (+) }
    let limb1 = if (i >= num1Limbs) {
      0N
    } else {
      getLimb(num1, i)
    }
    let limb2 = if (i >= num2Limbs) {
      0N
    } else {
      getLimb(num2, i)
    }
    let z = limb1 + limb2 + carry
    setLimb(dest, i, z)
    use WasmI64.{ ltU as (<) }
    carry = if (z < limb1 || z < limb2 || z < carry) 1N else 0N
  }
  // handle remaining carry (resize if needed)
  if (carry != 0N) {
    dest = cloneWithLen(dest, n + 1n)
    setLimb(dest, n, carry)
  }
  dest
}

@unsafe
let unsignedAddInt = (num1: WasmI32, int: WasmI64) => {
  use WasmI64.{ (!=) }
  use WasmI32.{ (+), (&), (|), gtU as (>), ltU as (<), geU as (>=), (==) }
  let num1Limbs = getSize(num1)
  let n = maxu32(num1Limbs, 1n)
  let mut dest = init(n)
  let mut carry = 0N
  for (let mut i = 0n; i < n; i += 1n) {
    use WasmI64.{ (+) }
    let limb1 = if (i >= num1Limbs) {
      0N
    } else {
      getLimb(num1, i)
    }
    let limb2 = if (i > 0n) {
      0N
    } else {
      int
    }
    let z = limb1 + limb2 + carry
    setLimb(dest, i, z)
    use WasmI64.{ ltU as (<) }
    carry = if (z < limb1 || z < limb2 || z < carry) 1N else 0N
    use WasmI32.{ ltU as (<), (-), (+), (*) }
    if (WasmI64.eqz(carry) && i < n - 1n) {
      // if we're not carrying, then there's nothing left to do but copy
      Memory.copy(
        dest + 16n + 8n * (i + 1n),
        num1 + 16n + 8n * (i + 1n),
        8n * (num1Limbs - (i + 1n))
      )
      break
    }
  }
  // handle remaining carry (resize if needed)
  if (carry != 0N) {
    dest = cloneWithLen(dest, n + 1n)
    setLimb(dest, n, carry)
  }
  dest
}

@unsafe
let unsignedSubImpl = (num1: WasmI32, num2: WasmI32) => {
  use WasmI32.{ (+), (&), (|), ltU as (<), geU as (>=), (==) }
  let num1Limbs = getSize(num1)
  let num2Limbs = getSize(num2)
  let m = minu32(num1Limbs, num2Limbs)
  let n = maxu32(num1Limbs, num2Limbs)
  let mut dest = init(n)
  let mut carry = 0N
  for (let mut i = 0n; i < n; i += 1n) {
    use WasmI64.{ (+), (-) }
    let limb1 = if (i >= num1Limbs) {
      0N
    } else {
      getLimb(num1, i)
    }
    let limb2 = if (i >= num2Limbs) {
      0N
    } else {
      getLimb(num2, i)
    }
    let z1 = limb1 - limb2
    use WasmI64.{ gtU as (>) }
    let carry1 = z1 > limb1
    let z = z1 - carry
    let carry2 = z > z1
    setLimb(dest, i, z)
    carry = if (carry1 || carry2) 1N else 0N
  }
  // carry should be nonzero at this point
  if (num1Limbs < num2Limbs) {
    setFlag(dest, _IS_NEGATIVE, 1n)
  }
  trimNumberInPlace(dest)
}

@unsafe
let unsignedSub = (num1: WasmI32, num2: WasmI32) => {
  let cmpRes = cmpUnsigned(num1, num2)
  use WasmI32.{ (>), (<) }
  if (cmpRes > 0n) {
    unsignedSubImpl(num1, num2)
  } else if (cmpRes < 0n) {
    let ret = unsignedSubImpl(num2, num1)
    negateInPlace(ret)
  } else {
    // num1 == num2
    makeZero()
  }
}

@unsafe
let unsignedSubIntImpl = (num1: WasmI32, int: WasmI64) => {
  use WasmI32.{ (+), (&), (|), ltU as (<), gtU as (>), geU as (>=), (==) }
  let num1Limbs = getSize(num1)
  let num2Limbs = 1n
  let n = maxu32(num1Limbs, 1n)
  let mut dest = init(n)
  let mut carry = 0N
  for (let mut i = 0n; i < n; i += 1n) {
    use WasmI64.{ (+), (-) }
    let limb1 = if (i >= num1Limbs) {
      0N
    } else {
      getLimb(num1, i)
    }
    let limb2 = if (i > 0n) {
      0N
    } else {
      int
    }
    let z1 = limb1 - limb2
    use WasmI64.{ gtU as (>) }
    let carry1 = z1 > limb1
    let z = z1 - carry
    let carry2 = z > z1
    setLimb(dest, i, z)
    carry = if (carry1 || carry2) 1N else 0N
    use WasmI32.{ (+), (-), (*) }
    if (WasmI64.eqz(carry) && i < n - 1n) {
      // if we're not carrying, then there's nothing left to do but copy
      Memory.copy(
        dest + 16n + 8n * (i + 1n),
        num1 + 16n + 8n * (i + 1n),
        8n * (num1Limbs - (i + 1n))
      )
      break
    }
  }
  // carry should be nonzero at this point
  if (num1Limbs < num2Limbs) {
    setFlag(dest, _IS_NEGATIVE, 1n)
  }
  trimNumberInPlace(dest)
}

@unsafe
let unsignedSubInt = (num1: WasmI32, int: WasmI64) => {
  let num1Limbs = getSize(num1)
  use WasmI32.{ (==) }
  use WasmI64.{ (==) as eqWasmI64, (-), ltU as (<) }
  if (num1Limbs == 0n || num1Limbs == 1n && getLimb(num1, 0n) < int) {
    let ret = init(1n)
    setLimb(ret, 0n, int - (if (num1Limbs == 0n) {
      0N
    } else {
      getLimb(num1, 0n)
    }))
    trimNumberInPlace(negateInPlace(ret))
  } else if (num1Limbs == 1n && eqWasmI64(getLimb(num1, 0n), int)) {
    makeZero()
  } else {
    unsignedSubIntImpl(num1, int)
  }
}

@unsafe
provide let add = (num1: WasmI32, num2: WasmI32) => {
  if (flagIsSet(num1, _IS_NEGATIVE)) {
    if (flagIsSet(num2, _IS_NEGATIVE)) {
      let ret = unsignedAdd(num1, num2)
      setFlag(ret, _IS_NEGATIVE, 1n)
      ret
    } else {
      unsignedSub(num2, num1)
    }
  } else {
    if (flagIsSet(num2, _IS_NEGATIVE)) {
      unsignedSub(num1, num2)
    } else {
      unsignedAdd(num1, num2)
    }
  }
}

@unsafe
provide let addInt = (num1: WasmI32, int: WasmI64) => {
  use WasmI64.{ (+), (^), (<) }
  // int is *signed*
  if (eqz(num1)) {
    let ret = makeWrappedUint64(int)
    if (int < 0N) {
      setFlag(ret, _IS_NEGATIVE, 1n)
    }
    ret
  } else if (flagIsSet(num1, _IS_NEGATIVE)) {
    let ret = if (int < 0N) {
      unsignedAddInt(num1, (int ^ _UMAX_I64) + 1N)
    } else {
      unsignedSubInt(num1, int)
    }
    negateInPlace(ret)
    ret
  } else {
    if (int < 0N) {
      unsignedSubInt(num1, (int ^ _UMAX_I64) + 1N)
    } else {
      unsignedAddInt(num1, int)
    }
  }
}

@unsafe
provide let sub = (num1: WasmI32, num2: WasmI32) => {
  if (flagIsSet(num1, _IS_NEGATIVE)) {
    if (flagIsSet(num2, _IS_NEGATIVE)) {
      unsignedSub(num2, num1)
    } else {
      let ret = unsignedAdd(num1, num2)
      setFlag(ret, _IS_NEGATIVE, 1n)
      ret
    }
  } else {
    if (flagIsSet(num2, _IS_NEGATIVE)) {
      unsignedAdd(num1, num2)
    } else {
      unsignedSub(num1, num2)
    }
  }
}

@unsafe
provide let subInt = (num1: WasmI32, int: WasmI64) => {
  use WasmI64.{ (+), (^), (<), (>) }
  // int is *signed*
  if (eqz(num1)) {
    let ret = makeWrappedUint64(int)
    // inverse:
    if (int > 0N) {
      setFlag(ret, _IS_NEGATIVE, 1n)
    }
    ret
  } else if (flagIsSet(num1, _IS_NEGATIVE)) {
    let ret = if (int < 0N) {
      unsignedSubInt(num1, (int ^ _UMAX_I64) + 1N)
    } else {
      unsignedAddInt(num1, int)
    }
    negateInPlace(ret)
    ret
  } else {
    if (int < 0N) {
      unsignedAddInt(num1, (int ^ _UMAX_I64) + 1N)
    } else {
      unsignedSubInt(num1, int)
    }
  }
}

@unsafe
provide let incr = (num: WasmI32) => {
  addInt(num, 1N)
}

@unsafe
provide let decr = (num: WasmI32) => {
  subInt(num, 1N)
}

/*
 * Multiplication
 */

@unsafe
let unsignedMul = (num1: WasmI32, num2: WasmI32) => {
  // num1 >= num2
  use WasmI32.{ (+), (-), (<<), (==) }
  use WasmI64.{ (*), (>>>) }
  let num1Limbs = getSize(num1)
  let num2Limbs = getSize(num2)
  let num1HalfLimbs = num1Limbs << 1n
  let num2HalfLimbs = num2Limbs << 1n
  let dest = init(num1Limbs + num2Limbs)
  let mut tmp = 0N
  // because 64-bit overflow calculation isn't straightforward (and
  // basically requires doing so anyway), we implement this alg with 32-bit half-limbs
  for (let mut i = 0n; WasmI32.ltU(i, num1HalfLimbs); i += 1n) {
    use WasmI64.{ (+) }
    let halfLimb1 = getHalfLimb(num1, i)
    let halfLimb2 = getHalfLimb(num2, 0n)
    tmp += WasmI64.extendI32U(halfLimb1) * WasmI64.extendI32U(halfLimb2)
    setHalfLimb(dest, i, WasmI32.wrapI64(tmp))
    tmp = tmp >>> 32N
  }
  setHalfLimb(dest, num1HalfLimbs, WasmI32.wrapI64(tmp))
  for (let mut j = 1n; WasmI32.ltU(j, num2HalfLimbs); j += 1n) {
    tmp = 0N
    let halfLimb2 = getHalfLimb(num2, j)
    if (j == num2HalfLimbs - 1n && halfLimb2 == 0n) {
      break
    }
    for (let mut i = 0n; WasmI32.ltU(i, num1HalfLimbs); i += 1n) {
      let curHalfLimb = getHalfLimb(dest, j + i)
      let halfLimb1 = getHalfLimb(num1, i)
      use WasmI64.{ (+) }
      tmp += WasmI64.extendI32U(curHalfLimb) +
        WasmI64.extendI32U(halfLimb1) * WasmI64.extendI32U(halfLimb2)
      use WasmI32.{ (+) }
      setHalfLimb(dest, j + i, WasmI32.wrapI64(tmp))
      tmp = tmp >>> 32N
    }
    let mut pos = j + num1HalfLimbs
    while (WasmI64.gtU(tmp, 0N)) {
      use WasmI64.{ (+) }
      tmp += WasmI64.extendI32U(getHalfLimb(dest, pos))
      use WasmI32.{ (+) }
      setHalfLimb(dest, pos, WasmI32.wrapI64(tmp))
      tmp = tmp >>> 32N
      pos += 1n
    }
  }
  trimNumberInPlace(dest)
}

// TODO(#1189): Replace with Karatsuba multiplication
@unsafe
provide let mul = (num1: WasmI32, num2: WasmI32) => {
  use WasmI32.{ (^) }
  let ret = if (eqz(num1) || eqz(num2)) {
    makeZero()
  } else {
    let num1Limbs = getSize(num1)
    let num2Limbs = getSize(num2)
    if (WasmI32.gtU(num2Limbs, num1Limbs)) {
      unsignedMul(num2, num1)
    } else {
      unsignedMul(num1, num2)
    }
  }
  setFlag(
    ret,
    _IS_NEGATIVE,
    getFlag(num1, _IS_NEGATIVE) ^ getFlag(num2, _IS_NEGATIVE)
  )
  ret
}

/*
 * Bitwise Ops
 */

@unsafe
provide let shl = (num: WasmI32, places: WasmI32) => {
  use WasmI32.{ (+), divU as (/), remU as (%), ltU as (<) }
  use WasmI64.{ (-), (&), (|), (<<) }
  // places is *unsigned*
  let numLimbs = getSize(num)
  let mut carry = 0N
  let a = places / 32n
  let b = places % 32n
  let mask = ((1N << WasmI64.extendI32U(b)) - 1N) <<
    (64N - WasmI64.extendI32U(b))
  let result = init(numLimbs + a)
  setFlag(result, _IS_NEGATIVE, getFlag(num, _IS_NEGATIVE))
  use WasmI32.{ (<<) }
  let numHalfLimbs = numLimbs << 1n
  for (let mut i = 0n; i < numHalfLimbs; i += 1n) {
    use WasmI64.{ (>>>), (<<) }
    let acc = WasmI64.extendI32U(getHalfLimb(num, i)) << 32N | carry
    carry = (acc & mask) >>> 32N
    setHalfLimb(
      result,
      i + a,
      WasmI32.wrapI64((acc << WasmI64.extendI32U(b)) >>> 32N)
    )
  }
  use WasmI64.{ gtU as (>) }
  let ret = if (carry > 0N) {
    let ret = cloneWithLen(result, numLimbs + a + 1n)
    use WasmI64.{ (>>>) }
    setHalfLimb(
      ret,
      numHalfLimbs + a,
      WasmI32.wrapI64(carry >>> (32N - WasmI64.extendI32U(b)))
    )
    ret
  } else {
    result
  }
  trimNumberInPlace(ret)
}

@unsafe
provide let shrS = (num: WasmI32, places: WasmI32) => {
  // places is *unsigned*
  let numLimbs = getSize(num)
  let mut carry = 0N
  use WasmI32.{ (+), (-), divU as (/), remU as (%), (&), (<<), (>>>), (>=) }
  let a = places / 32n
  let b = places % 32n
  let mask = (1n << b) - 1n
  let numHalfLimbs = numLimbs << 1n
  if (WasmI32.geU(a, numHalfLimbs)) {
    // edge case: we shift right all the way
    if (flagIsSet(num, _IS_NEGATIVE)) {
      makeWrappedInt32(-1n)
    } else {
      makeZero()
    }
  } else {
    let newHalfLimbs = numHalfLimbs - a
    let ret = init(
      (newHalfLimbs >>> 1n) + (if (WasmI32.eqz(newHalfLimbs & 1n)) {
        0n
      } else {
        1n
      })
    )
    setFlag(ret, _IS_NEGATIVE, getFlag(num, _IS_NEGATIVE))
    for (let mut i = numHalfLimbs - 1n; i >= a; i -= 1n) {
      use WasmI64.{ (&), (<<), (|), (>>>) }
      let acc = carry << 32N | WasmI64.extendI32U(getHalfLimb(num, i))
      carry = acc & WasmI64.extendI32U(mask)
      setHalfLimb(ret, i - a, WasmI32.wrapI64(acc >>> WasmI64.extendI32U(b)))
    }
    let ret = if (flagIsSet(ret, _IS_NEGATIVE)) {
      let mut underflow = false
      use WasmI64.{ gtU as (>) }
      if (carry > 0N) {
        underflow = true
      } else {
        use WasmI32.{ ltU as (<) }
        for (let mut i = 0n; i < a; i += 1n) {
          if (0n < getHalfLimb(ret, i)) {
            underflow = true
            break
          }
        }
      }
      if (underflow) {
        let newRet = decr(ret)
        Memory.decRef(ret)
        newRet
      } else {
        ret
      }
    } else {
      ret
    }
    trimNumberInPlace(ret)
  }
}

@unsafe
let bitwiseNotUnsigned = (num: WasmI32) => {
  // *not the user-facing bitwise-not*
  // the user-facing ops need some bit-flipping ability, which this provides,
  // but `bitwiseNot` is the user-facing bitwise NOT implementation
  let num1Limbs = getSize(num)
  let ret = init(num1Limbs)
  use WasmI32.{ (+), ltU as (<) }
  use WasmI64.{ (^) }
  for (let mut i = 0n; i < num1Limbs; i += 1n) {
    setLimb(ret, i, getLimb(num, i) ^ _UMAX_I64)
  }
  ret
}

@unsafe
let bitwiseAndPositive = (num1: WasmI32, num2: WasmI32, copyTrailing: WasmI32) => {
  // bitwise and, but both num1 and num2 are assumed to be positive
  let num1Limbs = getSize(num1)
  let num2Limbs = getSize(num2)
  let newLimbs = maxu32(num1Limbs, num2Limbs)
  let ret = init(newLimbs)
  use WasmI32.{ (+), ltU as (<), (==) }
  use WasmI64.{ (&) }
  let numToProcess = minu32(num1Limbs, num2Limbs) // anything past this is 0
  for (let mut i = 0n; i < numToProcess; i += 1n) {
    setLimb(ret, i, getLimb(num1, i) & getLimb(num2, i))
  }
  if (numToProcess < newLimbs && copyTrailing == 1n) {
    // will be a no-op if numToProcess == num1Limbs
    for (let mut i = numToProcess; i < num1Limbs; i += 1n) {
      setLimb(ret, i, getLimb(num1, i))
    }
  }
  if (numToProcess < newLimbs && copyTrailing == 2n) {
    // will be a no-op if numToProcess == num1Limbs
    for (let mut i = numToProcess; i < num2Limbs; i += 1n) {
      setLimb(ret, i, getLimb(num2, i))
    }
  }
  ret
}

@unsafe
let bitwiseOrPositive = (num1: WasmI32, num2: WasmI32) => {
  // bitwise or, but both num1 and num2 are assumed to be positive
  let num1Limbs = getSize(num1)
  let num2Limbs = getSize(num2)
  let newLimbs = maxu32(num1Limbs, num2Limbs)
  let ret = init(newLimbs)
  use WasmI32.{ (+), ltU as (<) }
  use WasmI64.{ (|) }
  for (let mut i = 0n; i < newLimbs; i += 1n) {
    let limb1 = if (i < num1Limbs) getLimb(num1, i) else 0N
    let limb2 = if (i < num2Limbs) getLimb(num2, i) else 0N
    setLimb(ret, i, limb1 | limb2)
  }
  ret
}

@unsafe
let bitwiseXorPositive = (num1: WasmI32, num2: WasmI32) => {
  // bitwise xor, but both num1 and num2 are assumed to be positive
  let num1Limbs = getSize(num1)
  let num2Limbs = getSize(num2)
  let newLimbs = maxu32(num1Limbs, num2Limbs)
  let ret = init(newLimbs)
  use WasmI32.{ (+), ltU as (<) }
  use WasmI64.{ (^) }
  for (let mut i = 0n; i < newLimbs; i += 1n) {
    let limb1 = if (i < num1Limbs) getLimb(num1, i) else 0N
    let limb2 = if (i < num2Limbs) getLimb(num2, i) else 0N
    setLimb(ret, i, limb1 ^ limb2)
  }
  ret
}

// https://stackoverflow.com/a/32298732

@unsafe
provide let bitwiseNot = (num: WasmI32) => {
  // ~x == -x - 1
  let numNegated = negate(num)
  let result = decr(numNegated)
  Memory.decRef(numNegated)
  result
}

@unsafe
provide let bitwiseAnd = (num1: WasmI32, num2: WasmI32) => {
  let num1 = WasmI32.fromGrain(num1)
  let num2 = WasmI32.fromGrain(num2)
  let ret = if (!flagIsSet(num1, _IS_NEGATIVE)) {
    if (!flagIsSet(num2, _IS_NEGATIVE)) {
      // A & B
      bitwiseAndPositive(num1, num2, 0n)
    } else {
      // A & -B == A & ~(B-1)
      let num2Neg = negate(num2)
      let num2Sub1 = decr(num2Neg)
      Memory.decRef(num2Neg)
      let notNum2Sub1 = bitwiseNotUnsigned(num2Sub1)
      Memory.decRef(num2Sub1)
      let combined = bitwiseAndPositive(num1, notNum2Sub1, 1n)
      Memory.decRef(notNum2Sub1)
      combined
    }
  } else {
    if (!flagIsSet(num2, _IS_NEGATIVE)) {
      // -A & B == ~(A-1) & B
      let num1Neg = negate(num1) // A
      let num1Sub1 = decr(num1Neg) // A-1
      Memory.decRef(num1Neg)
      let notNum1Sub1 = bitwiseNotUnsigned(num1Sub1) // ~(A-1)
      Memory.decRef(num1Sub1)
      let combined = bitwiseAndPositive(notNum1Sub1, num2, 2n) // ~(A-1) & B
      Memory.decRef(notNum1Sub1)
      combined
    } else {
      // -A & -B == -((A-1) | (B-1) + 1)
      let num1Neg = negate(num1) // A
      let num2Neg = negate(num2) // B
      let num1Sub1 = decr(num1Neg)
      let num2Sub1 = decr(num2Neg)
      let orResult = bitwiseOrPositive(num1Sub1, num2Sub1)
      let ret = incr(orResult)
      Memory.decRef(num1Neg)
      Memory.decRef(num2Neg)
      Memory.decRef(num1Sub1)
      Memory.decRef(num2Sub1)
      Memory.decRef(orResult)
      // avoid extra allocation on negate()
      setFlag(ret, _IS_NEGATIVE, 1n)
      ret
    }
  }
  trimNumberInPlace(ret)
}

@unsafe
provide let bitwiseOr = (num1: WasmI32, num2: WasmI32) => {
  let num1 = WasmI32.fromGrain(num1)
  let num2 = WasmI32.fromGrain(num2)
  let ret = if (!flagIsSet(num1, _IS_NEGATIVE)) {
    if (!flagIsSet(num2, _IS_NEGATIVE)) {
      // A | B
      bitwiseOrPositive(num1, num2)
    } else {
      // A | -B == -(((B-1) & ~A) + 1)
      let num2Neg = negate(num2) // B
      let num2Sub1 = decr(num2Neg) // B-1
      Memory.decRef(num2Neg)
      let notNum1 = bitwiseNotUnsigned(num1) // ~A
      let retSub1 = bitwiseAndPositive(notNum1, num2Sub1, 2n) // (B-1) & ~A
      Memory.decRef(num2Sub1)
      Memory.decRef(notNum1)
      let ret = incr(retSub1)
      Memory.decRef(retSub1)
      negateInPlace(ret)
      ret
    }
  } else {
    if (!flagIsSet(num2, _IS_NEGATIVE)) {
      // A | -B == -(((A-1) & ~B) + 1)
      let num1Neg = negate(num1) // A
      let num1Sub1 = decr(num1Neg) // A-1
      Memory.decRef(num1Neg)
      let notNum2 = bitwiseNotUnsigned(num2) // ~B
      let retSub1 = bitwiseAndPositive(num1Sub1, notNum2, 1n) // (A-1) & ~B
      Memory.decRef(num1Sub1)
      Memory.decRef(notNum2)
      let ret = incr(retSub1)
      Memory.decRef(retSub1)
      negateInPlace(ret)
      ret
    } else {
      // -A | -B == -((A-1) & (B-1) + 1)
      let num1Neg = negate(num1) // A
      let num2Neg = negate(num2) // B
      let num1Sub1 = decr(num1Neg) // (A-1)
      let num2Sub1 = decr(num2Neg) // (B-1)
      let andResult = bitwiseAndPositive(num1Sub1, num2Sub1, 0n) // (A-1) & (B-1)
      let ret = incr(andResult) // ((A-1) & (B-1)) + 1
      Memory.decRef(num1Neg)
      Memory.decRef(num2Neg)
      Memory.decRef(num1Sub1)
      Memory.decRef(num2Sub1)
      Memory.decRef(andResult)
      // avoid extra allocation on negate()
      setFlag(ret, _IS_NEGATIVE, 1n)
      ret
    }
  }
  trimNumberInPlace(ret)
}

@unsafe
provide let bitwiseXor = (num1: WasmI32, num2: WasmI32) => {
  let num1 = WasmI32.fromGrain(num1)
  let num2 = WasmI32.fromGrain(num2)
  let ret = if (!flagIsSet(num1, _IS_NEGATIVE)) {
    if (!flagIsSet(num2, _IS_NEGATIVE)) {
      // A ^ B
      bitwiseXorPositive(num1, num2)
    } else {
      // A ^ -B == A ^ (B-1)+1
      let num2Neg = negate(num2) // B
      let num2Sub1 = decr(num2Neg) // B-1
      Memory.decRef(num2Neg)
      let retSub1 = bitwiseXorPositive(num2Sub1, num1) // (A^(B-1))
      Memory.decRef(num2Sub1)
      let ret = incr(retSub1)
      Memory.decRef(retSub1)
      // avoid extra allocation on negate()
      setFlag(ret, _IS_NEGATIVE, 1n)
      ret
    }
  } else {
    if (!flagIsSet(num2, _IS_NEGATIVE)) {
      // -A ^ B == (B^(A-1))+1
      let num1Neg = negate(num1) // A
      let num1Sub1 = decr(num1Neg) // A-1
      Memory.decRef(num1Neg)
      let retSub1 = bitwiseXorPositive(num1Sub1, num2) // (B^(A-1))
      Memory.decRef(num1Sub1)
      let ret = incr(retSub1)
      Memory.decRef(retSub1)
      // avoid extra allocation on negate()
      setFlag(ret, _IS_NEGATIVE, 1n)
      ret
    } else {
      // -A ^ -B == (A-1)^(B-1)
      let num1Neg = negate(num1) // A
      let num2Neg = negate(num2) // B
      let num1Sub1 = decr(num1Neg)
      let num2Sub1 = decr(num2Neg)
      let ret = bitwiseXorPositive(num1Sub1, num2Sub1)
      Memory.decRef(num1Neg)
      Memory.decRef(num2Neg)
      Memory.decRef(num1Sub1)
      Memory.decRef(num2Sub1)
      ret
    }
  }
  trimNumberInPlace(ret)
}

@unsafe
provide let countLeadingZeros = (num: WasmI32) => {
  // if positive, there are an infinite number. if negative, there are none.
  if (flagIsSet(num, _IS_NEGATIVE)) {
    0n
  } else {
    _SMAX_I32
  }
}

@unsafe
provide let countTrailingZeros = (num: WasmI32) => {
  // the number of trailing zeros is the same for `x` and `-x` (using two's complement),
  // so we can safely ignore the sign.
  let numLimbs = getSize(num)
  let mut ret = 0N
  use WasmI32.{ (+), ltU as (<) }
  for (let mut i = 0n; i < numLimbs; i += 1n) {
    let limb = getLimb(num, i)
    let limbtz = WasmI64.ctz(limb)
    use WasmI64.{ (+), (!=) }
    ret += limbtz
    if (limbtz != 64N) {
      break
    }
  }
  ret
}

@unsafe
provide let popcnt = (num: WasmI32, flagDest: WasmI32) => {
  // negative numbers have an infinite number of ones, so we return SMAX
  if (flagIsSet(num, _IS_NEGATIVE)) {
    WasmI32.store(flagDest, 1n, 0n)
    _SMAX32_I64
  } else {
    let numLimbs = getSize(num)
    let mut ret = 0N
    use WasmI32.{ (+), ltU as (<) }
    for (let mut i = 0n; i < numLimbs; i += 1n) {
      use WasmI64.{ (+) }
      let limb = getLimb(num, i)
      let limbtz = WasmI64.popcnt(limb)
      ret += limbtz
    }
    ret
  }
}

/*
 * Division
 */

// BigInt GCD
@unsafe
provide let gcd = (num1: WasmI32, num2: WasmI32) => {
  if (eqz(num1)) {
    return abs(num2)
  }
  if (eqz(num2)) {
    return abs(num1)
  }
  let mut u = abs(num1)
  let mut v = abs(num2)
  let i = countTrailingZeroBits(u)
  let j = countTrailingZeroBits(v)
  let k = minu32(i, j)
  let mut newu = shrS(u, i)
  let mut newv = shrS(v, j)
  Memory.decRef(u)
  Memory.decRef(v)
  u = newu
  v = newv
  while (true) {
    if (gt(u, v)) {
      let tmp = v
      v = u
      u = tmp
    }
    newv = sub(v, u)
    Memory.decRef(v)
    v = newv
    if (eqz(v)) {
      return shl(u, k)
    }
    newv = shrS(v, countTrailingZeroBits(v))
    Memory.decRef(v)
    v = newv
  }
  return 0n
}

// For division, "normalized" refers to the following (from Brent & Zimmermann):
//
// We say that B = sum_0^{n-1} b_j \beta^j is *normalized* when its most significant
// word b_{n-1} satisfies b_{n-1} >= \beta / 2. This is a stricter condition
// (for \beta > 2) than simply requiring b_{n-1} to be non-zero.
// If B is not normalized, we can compute A' = 2^k A and B' = 2^k B so that
// B' is normalized, then divide A' by B' giving A' = Q'B' + R'. The quotient
// and remainder of the division of A by B are, respectively, Q := Q' and R := R'/(2^k);
// the latter division being exact

// Brent & Zimmermann v0.5.9 Algorithm 1.6 (Chapter 1.4)
@unsafe
let baseCaseDivRem = (a: WasmI32, b: WasmI32, result: WasmI32) => {
  use WasmI32.{ (+), (-), (*), (&), (<<), (>>>), (>=) }
  let aOrig = a
  // b is `n` half-limbs
  // a is `n+m` half-limbs, m >= 0 (i.e. `a` has at least as many limbs as `b`)
  // b is normalized
  // \beta == 2^32 (we use half-limbs in this implementation because it makes calculating qjstar faster)
  let n = getHalfSize(b)
  let m = getHalfSize(a) - n
  let qsize = (if (WasmI32.eqz(m + 1n & 1n)) {
    m + 1n
  } else {
    m + 2n
  }) >>> 1n
  let mut q = init(qsize)
  let mut a = 0n
  let bTimesBetaM = shl(b, m * 32n) // b * \beta^m == b * (2^32)^m == b*2^(32*m)
  if (gte(aOrig, bTimesBetaM)) {
    setHalfLimb(q, m, 1n)
    a = sub(aOrig, bTimesBetaM)
  } else {
    // (clone for sane reference management)
    a = clone(aOrig)
  }
  Memory.decRef(bTimesBetaM)
  for (let mut j = m - 1n; j >= 0n; j -= 1n) {
    use WasmI64.{ divU as (/), (|), (<<) }
    let anjBeta = WasmI64.extendI32U(getHalfLimb(a, n + j)) << 32N // a_{n+j}\beta
    let anj1 = WasmI64.extendI32U(getHalfLimb(a, n + j - 1n)) // a_{n+j-1}
    let bn1 = WasmI64.extendI32U(getHalfLimb(b, n - 1n)) // b_{n-1}
    let qjstar = (anjBeta | anj1) / bn1 // q_j^\ast (quotient selection)
    let mut qj = WasmI32.wrapI64(qjstar) // min(q_j^ast, \beta - 1) (equiv. to qjstar & _UMAX_I6432)
    let bTimesBetaJ = shl(b, j * 32n) // b * \beta^j == b * (2^32)^j == b*2^(32*j)
    let qjWrapped = makeWrappedUint32(qj)
    let qjTimesBTimesBetaJ = mul(bTimesBetaJ, qjWrapped)
    Memory.decRef(qjWrapped)
    let anew = sub(a, qjTimesBTimesBetaJ)
    Memory.decRef(a)
    a = anew
    while (flagIsSet(a, _IS_NEGATIVE)) {
      qj -= 1n
      let anew = add(a, bTimesBetaJ)
      Memory.decRef(a)
      a = anew
    }
    Memory.decRef(bTimesBetaJ)
    setHalfLimb(q, j, qj)
  }
  WasmI32.store(result, trimNumberInPlace(q), 0n) // Q := q
  WasmI32.store(result, trimNumberInPlace(a), 4n) // R := a
}

@unsafe
let baseCaseDivRemUnnormalized = (a: WasmI32, b: WasmI32, result: WasmI32) => {
  // wrapper around baseCaseDivRem which accepts unnormalized b
  // b is `n` half-limbs; n > 0
  // a is `n+m` half-limbs, m >= 0 (i.e. `a` has at least as many limbs as `b`)
  use WasmI32.{ (-), gtU as (>) }
  let n = getHalfSize(b)
  //assert !WasmI32.eqz(n)
  let mostSignificantHalfLimb = getHalfLimb(b, n - 1n)
  let k = WasmI32.clz(mostSignificantHalfLimb)
  if (k > 0n) {
    let anew = shl(a, k)
    let bnew = shl(b, k)
    baseCaseDivRem(anew, bnew, result)
    Memory.decRef(anew)
    Memory.decRef(bnew)
    let rold = WasmI32.load(result, 4n)
    let rnew = shrS(rold, k)
    Memory.decRef(rold)
    WasmI32.store(result, rnew, 4n) // R := R' / 2^k
  } else {
    baseCaseDivRem(a, b, result)
  }
}

@unsafe
let division = (
  num1: WasmI32,
  num2: WasmI32,
  destContainer: WasmI32,
  divMod: Bool,
) => {
  use WasmI32.{ (^), (==) }
  if (eqz(num2)) {
    throw Exception.DivisionByZero
  }
  let num1HalfLimbs = getHalfSize(num1)
  let num2HalfLimbs = getHalfSize(num2)
  let mut q = 0n
  let mut r = 0n
  if (eqz(num1)) {
    q = makeZero()
    r = makeZero()
  } else if (WasmI32.ltU(num1HalfLimbs, num2HalfLimbs)) {
    q = makeZero()
    r = clone(num1)
  } else if (num2HalfLimbs == 1n) {
    let d = getLimb(num2, 0n)
    use WasmI32.{ (+), (-), (<<), (>=) }
    q = init(getSize(num1))
    let mut r2 = 0N
    for (let mut i = num1HalfLimbs - 1n; i >= 0n; i -= 1n) {
      use WasmI64.{ (+), divU as (/), remU as (%), (<<) }
      let halfLimb = getHalfLimb(num1, i)
      if (!(halfLimb == 0n && num1HalfLimbs - 1n == i)) {
        let tmp = WasmI64.extendI32U(halfLimb) + (r2 << 32N)
        setHalfLimb(q, i, WasmI32.wrapI64(tmp / d))
        r2 = tmp % d
      }
    }
    q = trimNumberInPlace(q)
    r = init(1n)
    setLimb(r, 0n, r2)
  } else {
    let result = Memory.malloc(8n) // holder for q and r
    let num1abs = abs(num1)
    let num2abs = abs(num2)
    baseCaseDivRemUnnormalized(num1abs, num2abs, result)
    Memory.decRef(num1abs)
    Memory.decRef(num2abs)
    q = WasmI32.load(result, 0n)
    r = WasmI32.load(result, 4n)
    Memory.free(result)
    if (
      flagIsSet(num1, _IS_NEGATIVE) && !flagIsSet(num2, _IS_NEGATIVE) ||
      !flagIsSet(num1, _IS_NEGATIVE) && flagIsSet(num2, _IS_NEGATIVE)
    ) {
      // fix sign for negative div by positive & vice versa
      q = negateInPlace(q)
    }
  }
  setFlag(
    q,
    _IS_NEGATIVE,
    getFlag(num1, _IS_NEGATIVE) ^ getFlag(num2, _IS_NEGATIVE)
  )
  if (flagIsSet(num1, _IS_NEGATIVE) && !eqz(r)) {
    setFlag(r, _IS_NEGATIVE, 1n)
  }
  // convert truncated division to floor division
  // https://en.wikipedia.org/wiki/Modulo_operation
  if (
    divMod &&
    (
      flagIsSet(r, _IS_NEGATIVE) && !flagIsSet(num2, _IS_NEGATIVE) ||
      !flagIsSet(r, _IS_NEGATIVE) && flagIsSet(num2, _IS_NEGATIVE)
    )
  ) {
    let newr = add(r, num2)
    Memory.decRef(r)
    let newq = decr(q)
    Memory.decRef(q)
    r = newr
    q = newq
  }
  // Finished. Return appropriate number
  WasmI32.store(destContainer, q, 0n)
  WasmI32.store(destContainer, r, 4n)
}

@unsafe
provide let quotRem = (num1: WasmI32, num2: WasmI32, dest: WasmI32) => {
  division(num1, num2, dest, false)
}

@unsafe
provide let divMod = (num1: WasmI32, num2: WasmI32, dest: WasmI32) => {
  division(num1, num2, dest, true)
}

@unsafe
provide let quot = (num1: WasmI32, num2: WasmI32) => {
  let dest = Memory.malloc(8n)
  division(num1, num2, dest, false)
  let ret = WasmI32.load(dest, 0n)
  Memory.free(dest)
  ret
}

@unsafe
provide let div = (num1: WasmI32, num2: WasmI32) => {
  let dest = Memory.malloc(8n)
  division(num1, num2, dest, true)
  let ret = WasmI32.load(dest, 0n)
  Memory.free(dest)
  ret
}

@unsafe
provide let rem = (num1: WasmI32, num2: WasmI32) => {
  let dest = Memory.malloc(8n)
  division(num1, num2, dest, false)
  let ret = WasmI32.load(dest, 4n)
  Memory.free(dest)
  ret
}

@unsafe
provide let mod = (num1: WasmI32, num2: WasmI32) => {
  let dest = Memory.malloc(8n)
  division(num1, num2, dest, true)
  let ret = WasmI32.load(dest, 4n)
  Memory.free(dest)
  ret
}
