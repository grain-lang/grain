/**
 * @module Result: Utilities for working with the Result data type.
 * 
 * The `Result` type is a special type of enum that exists to represent the possibility of a success case (with the `Ok` variant),
 * or an error case (with the `Err` variant). Use a `Result` as the return type of a function that may return an error.
 * 
 * @example import Result from "result"
 * 
 * Create new `Result` values using `Ok()` and `Err()`:
 * 
 * @example let success = Ok("Yay!")
 * @example let failure = Err("Something bad happened")
 */

/**
 * @section Values: Functions for working with the `result` data type.
 */

/**
 * Checks if the Result is of the `Ok` variant.
 *
 * @param result: The result to check
 * @returns `true` if the result is of the `Ok` variant, otherwise returns `false`
 */
export let isOk = result => {
  match (result) {
    Ok(_) => true,
    _ => false,
  }
}

/**
 * Checks if the Result is of the `Err` variant.
 *
 * @param result: The result to check
 * @returns `true` if the result is of the `Err` variant, otherwise returns `false`
 */
export let isErr = result => !isOk(result)

/**
 * Converts the Result to an Option. The error is discarded and replaced with `None`.
 *
 * @param result: The result to convert
 * @returns `Some(okValue)` with okValue representing the value inside of `Ok` if the result is of the `Ok` variant, otherwise returns `None`
 */
export let toOption = result => {
  match (result) {
    Ok(x) => Some(x),
    _ => None,
  }
}

/**
 * If the Result is `Ok`, applies the given function to the `Ok` value and returns the result. Returns the unmodified `Err` otherwise.
 *
 * @param fn: The function to apply
 * @param result: The result to map
 * @returns `fn(okValue)` if the result is of the `Ok` variant, okValue represent the value wrapped by the result, otherwise returns the unmodified `Err`
 */
export let flatMap = (fn, result) => {
  match (result) {
    Ok(x) => fn(x),
    Err(e) => Err(e),
  }
}

/**
 * If the Result is an `Err`, applies the given function to the `Err` value and returns the result. Returns the unmodified `Ok` value otherwise.
 *
 * @param fn: The function to apply
 * @param result: The result to map
 * @returns `fn(errValue)` if the result is of the `Err` variant, errValue represent the value wrapped by the result, otherwise returns the unmodified `Ok`
 */
export let flatMapErr = (fn, result) => {
  match (result) {
    Err(e) => fn(e),
    Ok(x) => Ok(x),
  }
}

/**
 * If the Result is `Ok(x)`, returns `Ok(fn(x))`. Returns the unmodified `Err` otherwise.
 *
 * @param fn: The function to map
 * @param result: The result to map on
 * @returns `Ok(fn(okValue))` if the result is of the `Ok` variant, otherwise returns the unmodified `Err`
 */
export let map = (fn, result) => {
  match (result) {
    Ok(x) => Ok(fn(x)),
    Err(e) => Err(e),
  }
}

/**
 * If the Result is `Err(x)`, returns `Err(fn(x))`. Returns the unmodified `Ok` otherwise.
 *
 * @param fn: The function to map
 * @param result: The result to map on
 * @returns `Err(fn(errValue))` if the result is of the `Err` variant, otherwise returns the unmodified `Ok`
 */
export let mapErr = (fn, result) => {
  match (result) {
    Err(e) => Err(fn(e)),
    Ok(x) => Ok(x),
  }
}

/**
 * If the Result is `Ok(x)`, returns `fn(x)`. Returns the provided default otherwise.
 *
 * @param fn: The function to map
 * @param def: The default value to return
 * @param result: The result to map on
 * @returns `Ok(fn(okValue))` if the result is of the `Ok` variant, otherwise returns the value given by the `def` param
 */
export let mapWithDefault = (fn, def, result) => {
  match (result) {
    Ok(a) => fn(a),
    _ => def,
  }
}

/**
 * If the Result is `Ok(x)`, returns `fnOk(x)`. If the Result is `Err(y)`, returns `fnErr(y)`.
 *
 * @param fn: The function to map
 * @param def: The default value to return
 * @param result: The result to map on
 * @returns `fnOk(okValue)` if the result is of the `Ok` variant, otherwise returns `fnErr(errValue)`
 */
export let mapWithDefaultFn = (fnOk, fnErr, result) => {
  match (result) {
    Ok(a) => fnOk(a),
    Err(a) => fnErr(a),
  }
}

/**
 * If the first Result is `Ok`, returns the first Result. Returns the second Result otherwise.
 *
 * @param result1: The first result
 * @param result2: The second result
 * @returns `result1` if result1 is of the `Ok` variant, otherwise returns `result2`
 */
export let or = (result1, result2) => {
  match (result1) {
    Ok(x) => result1,
    _ => result2,
  }
}

/**
 * If the first Result is `Err`, returns the first Result. Returns the second Result otherwise.
 *
 * @param result1: The first result
 * @param result2: The second result
 * @returns `result1` if result1 is of the `Err` variant, otherwise returns `result2`
 */
export let and = (result1, result2) => {
  match (result1) {
    Ok(_) => result2,
    Err(_) => result1,
  }
}

/**
 * If the Result is `Ok(x)`, applies the first function to `x`. If the Result is `Err(y)`, applies the second function to `y`.
 *
 * @param fnOk: The function to apply on the result if it is an `Err`
 * @param fnErr: The function to apply on the result if it is an `Err`
 * @param result: The result to apply the function on
 */
export let peek = (fnOk, fnErr, result) => {
  match (result) {
    Ok(x) => ignore(fnOk(x)),
    Err(x) => ignore(fnErr(x)),
  }
}

/**
 * If the Result is `Ok(x)`, applies the function to `x`.
 *
 * @param fn: The function to apply
 * @param result: The result to apply the function on
 */
export let peekOk = (fn, result) => {
  peek(fn, identity, result)
}

/**
 * If the Result is `Err(x)`, applies the function to `x`.
 *
 * @param fn: The function to apply
 * @param result: The result to apply the function on
 */
export let peekErr = (fn, result) => {
  peek(identity, fn, result)
}

/**
 * Extracts the value inside an `Ok` result, otherwise throw an
 * exception containing the message and contents of the `Err`.
 *
 * @param msg: The message to prepend if the result contains an `Err`
 * @param result: The result to extract a value from
 * @returns The unwrapped `ok` value if the result is of the `Ok` variant, otherwise throws `msg: err`
 *
 * @example Result.expect("Unexpected error", Ok(1234)) == 1234
 *
 * @since v0.4.0
 */
export let expect = (msg, result) => {
  match (result) {
    Ok(x) => x,
    Err(err) => fail msg ++ ": " ++ toString(err),
  }
}

/**
 * Extracts the value inside an `Ok` result, otherwise throw an
 * exception containing a default message and contents of the `Err`.
 *
 * @param result: The result to extract a value from
 * @returns The unwrapped `ok` value if the result is of the `Ok` variant, otherwise it throws with `Could not unwrap Err value: This will throw`
 *
 * @example Result.unwrap(Err("This will throw"))
 *
 * @since v0.4.0
 */
export let unwrap = result => {
  expect("Could not unwrap Err value", result)
}
