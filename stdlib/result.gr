/**
 * @module Result: Utilities for working with the Result data type.
 * 
 * The `Result` type is a special type of enum that exists to represent the possibility of a success case (with the `Ok` variant), or an error case (with the `Err` variant). Use a `Result` as the return type of a function that may return an error.
 * 
 * @example import Result from "result"
 * 
 * Create new `Result` values using `Ok()` and `Err()`:
 * 
 * @example let success = Ok("Yay!")
 * @example let failure = Err("Something bad happened")
 */

/**
 * @section Values: Functions for working with the `result` data type.
 */

/**
 * Checks if the Result is the `Ok` variant.
 *
 * @param v: The result to check
 * @returns A boolean representing if the result isOk
 */
export let isOk = v => {
  match (v) {
    Ok(_) => true,
    _ => false,
  }
}

/**
 * Checks if the Result is the `Err` variant.
 *
 * @param v: The result to check
 * @returns A boolean representing if the result isErr
 */
export let isErr = v => !isOk(v)

/**
 * Converts the Result to an Option. The error is discarded and replaced with `None`.
 *
 * @param v: The result to convert
 * @returns The result as an option
 */
export let toOption = v => {
  match (v) {
    Ok(x) => Some(x),
    _ => None,
  }
}

/**
 * If the Result is `Ok`, applies the given function to the `Ok` value and returns the result. Returns the unmodified `Err` otherwise.
 *
 * @param fn: The function to apply
 * @param v: The result to map
 * @returns The result of the applied function
 */
export let flatMap = (fn, v) => {
  match (v) {
    Ok(x) => fn(x),
    Err(e) => Err(e),
  }
}

/**
 * If the Result is an `Err`, applies the given function to the `Err` value and returns the result. Returns the unmodified `Ok` value otherwise.
 *
 * @param fn: The function to apply
 * @param v: The result to map
 * @returns The result of the applied function
 */
export let flatMapErr = (fn, v) => {
  match (v) {
    Err(e) => fn(e),
    Ok(x) => Ok(x),
  }
}

/**
 * If the Result is `Ok(x)`, returns `Ok(fn(x))`. Returns the unmodified `Err` otherwise.
 *
 * @param fn: The function to map
 * @param v: The result to map on
 * @returns The result with the functions mapped
 */
export let map = (fn, v) => {
  match (v) {
    Ok(x) => Ok(fn(x)),
    Err(e) => Err(e),
  }
}

/**
 * If the Result is `Err(x)`, returns `Err(fn(x))`. Returns the unmodified `Ok` otherwise.
 *
 * @param fn: The function to map
 * @param v: The result to map on
 * @returns The result with the functions mapped
 */
export let mapErr = (fn, v) => {
  match (v) {
    Err(e) => Err(fn(e)),
    Ok(x) => Ok(x),
  }
}

/**
 * If the Result is `Ok(x)`, returns `fnOk(fn(x))`. If the Result is `Err(y)`, returns `fnErr(y)`.
 *
 * @param fn: The function to map
 * @param v: The result to map on
 * @returns The result with the functions mapped
 */
export let mapWithDefault = (fn, def, v) => {
  match (v) {
    Ok(a) => fn(a),
    _ => def,
  }
}

/**
 * If the Result is `Ok(x)`, returns `fnOk(x)`. If the Result is `Err(y)`, returns `fnErr(y)`.
 *
 * @param fn: The function to map
 * @param v: The result to map on
 * @returns The result with the functions mapped
 */
export let mapWithDefaultFn = (fnOk, fnErr, v) => {
  match (v) {
    Ok(a) => fnOk(a),
    Err(a) => fnErr(a),
  }
}

/**
 * If the first Result is `Ok`, returns the first Result. Returns the second Result otherwise.
 *
 * @param r1: The first result
 * @param r2: The second result
 * @returns The result that is Ok
 */
export let or = (r1, r2) => {
  match (r1) {
    Ok(x) => r1,
    _ => r2,
  }
}

/**
 * If the first Result is `Err`, returns the first Result. Returns the second Result otherwise.
 *
 * @param r1: The first result
 * @param r2: The second result
 * @returns The result that is Err
 */
export let and = (r1, r2) => {
  match (r1) {
    Ok(_) => r2,
    Err(_) => r1,
  }
}

/**
 * If the Result is `Ok(x)`, applies the first function to `x`. If the Result is `Err(y)`, applies the second function to `y`.
 *
 * @param fnOk: The function to apply on the result if it is an `Err`
 * @param fnErr: The function to apply on the result if it is an `Err`
 * @param r: The result to apply the function on
 * @returns The result with the appropriate function applied
 */
export let peek = (fnOk, fnErr, r) => {
  match (r) {
    Ok(x) => ignore(fnOk(x)),
    Err(x) => ignore(fnErr(x)),
  }
  r
}

/**
 * If the Result is `Ok(x)`, applies the function to `x`.
 *
 * @param fn: The function to apply
 * @param r: The result to apply the function on
 * @returns The result with the function applied if it is `Ok`
 */
export let peekOk = (fn, r) => {
  peek(fn, identity, r)
}

/**
 * If the Result is `Err(x)`, applies the function to `x`.
 *
 * @param fn: The function to apply
 * @param r: The result to apply the function on
 * @returns The result with the function applied if it is `Err`
 */
export let peekErr = (fn, r) => {
  peek(identity, fn, r)
}

/**
 * Extracts the value inside an `Ok` result, otherwise throw an
 * exception containing the message and contents of the `Err`.
 *
 * @param msg: The message to prepend if the result contains an `Err`
 * @param result: The result to extract a value from
 * @returns The value inside an `Ok` result
 *
 * @example Result.expect("Unexpected error", Ok(1234))
 *
 * @since v0.4.0
 */
export let expect = (msg, result) => {
  match (result) {
    Ok(x) => x,
    Err(err) => fail msg ++ ": " ++ toString(err),
  }
}

/**
 * Extracts the value inside an `Ok` result, otherwise throw an
 * exception containing a default message and contents of the `Err`.
 *
 * @param result: The result to extract a value from
 * @returns The value inside an `Ok` result
 *
 * @example Result.unwrap(Err("This will throw"))
 *
 * @since v0.4.0
 */
export let unwrap = result => {
  expect("Could not unwrap Err value", result)
}
