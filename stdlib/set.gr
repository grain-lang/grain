/**
 * @module Set: A Set is an unordered collection of unique values. Operations on a Set mutate the internal state, so it never needs to be re-assigned.
 * @example import Set from "set"
 */
import List from "list"
import Array from "array"
import { hash } from "hash"

record Bucket<t> {
  mut key: t,
  mut next: Option<Bucket<t>>
}

record Set<k> {
  mut size: Number,
  mut buckets: Array<Option<Bucket<k>>>
}

// TODO: This could take an `eq` function to custom comparisons
/**
 * Creates a new, empty set with an initial storage size for the given number of elements.
 *
 * @param size: The size of the set.
 * @returns An empty set of the entered size.
 */
export let makeSized = (size) => {
  let buckets = Array.make(size, None);
  {
    size: 0,
    buckets
  }
}
/**
 * Creates a new, empty set.
 *
 * @returns An empty set.
 */
export let make = () => {
  makeSized(16)
}

let getBucketIndex = (key, buckets) => {
  let bucketsLength = Array.length(buckets);
  let hashedKey = hash(key);
  hashedKey % bucketsLength
}

let rec copyNodeWithNewHash = (oldNode, next, tail) => {
  match (oldNode) {
    None => void,
    Some(node) => {
      let idx = getBucketIndex(node.key, next);
      let newNode = Some(node);
      match (tail[idx]) {
        None => {
          next[idx] = newNode;
        },
        Some(tailNode) => {
          // If there's already a tail node, we add this to the end
          tailNode.next = newNode;
        }
      }
      // Always place this node as the new tail
      tail[idx] = newNode;
      // Recurse with the next node
      copyNodeWithNewHash(node.next, next, tail);
    }
  }
}

let resize = (set) => {
  let currentBuckets = set.buckets;
  let currentSize = Array.length(currentBuckets);
  let nextSize = currentSize * 2;
  if (nextSize >= currentSize) {
    let nextBuckets = Array.make(nextSize, None);
    // This tracks the tail nodes so we can set their `next` to None
    let tailNodes = Array.make(nextSize, None);
    set.buckets = nextBuckets;
    Array.forEach((old) => {
      copyNodeWithNewHash(old, nextBuckets, tailNodes);
    }, currentBuckets);
    Array.forEach((tail) => {
      match (tail) {
        None => void,
        Some(node) => {
          node.next = None;
        }
      }
    }, tailNodes);
  } else {
    void
  }
}

let rec nodeInBucket = (key, node) => {
  if (key == node.key) {
    true
  } else {
    match (node.next) {
      None => false,
      Some(next) => nodeInBucket(key, next)
    }
  }
}

/**
 * Adds a new value to the set. If the value already exists, nothing happens.
 *
 * @param key: The value to add to the set.
 * @param set: The set to append too.
 */
export let add = (key, set) => {
  let buckets = set.buckets;
  let idx = getBucketIndex(key, buckets)
  let bucket = buckets[idx];
  match (bucket) {
    None => {
      buckets[idx] = Some({ key, next: None });
      set.size = incr(set.size);
    },
    Some(node) => {
      if (!nodeInBucket(key, node)) {
        buckets[idx] = Some({ key, next: bucket });
        set.size = incr(set.size);
      };
    }
  }
  // Resize if there are more than 2x the amount of nodes as buckets
  if (set.size > (Array.length(buckets) * 2)) {
    resize(set);
  } else {
    void
  }
}

/**
 * Returns `true` if the set contains the given value.
 *
 * @param key: The key to search for.
 * @param set: The set to be searched.
 * @returns `true` if the set contains the given value.
 */
export let contains = (key, set) => {
  let buckets = set.buckets;
  let idx = getBucketIndex(key, buckets);
  let bucket = buckets[idx];
  match (bucket) {
    None => false,
    Some(node) => nodeInBucket(key, node)
  }
}

let rec removeInBucket = (key, node) => {
  match (node.next) {
    None => false,
    Some(next) => {
      if (key == next.key) {
        node.next = next.next;
        true
      } else {
        removeInBucket(key, next)
      }
    }
  }
}

/**
 * Removes the given value from the set.
 *
 * @param key: The value to remove from the set.
 * @param set: The set to remove from.
 */
export let remove = (key, set) => {
  let buckets = set.buckets;
  let idx = getBucketIndex(key, buckets);
  let bucket = buckets[idx];
  match (bucket) {
    None => void,
    Some(node) => {
      // If it is a top-level node, just replace with next node
      if (key == node.key) {
        set.size = decr(set.size);
        buckets[idx] = node.next;
      } else {
        if (removeInBucket(key, node)) {
          set.size = decr(set.size);
        }
      }
    }
  }
}

/**
 * Returns the number of values within the set.
 *
 * @param set: The set to determine the length from.
 * @returns The length of the set.
 */
export let size = (set) => {
  set.size
}

/**
 * Returns a boolean indicating weather or not the set is empty.
 *
 * @param set: The set to check.
 * @returns `true` if the set contains no values.
 */
export let isEmpty = (set) => {
  size(set) == 0
}

/**
 * Removes all values from the given set.
 *
 * @param set: The set to clear.
 */
export let clear = (set) => {
  set.size = 0;
  let buckets = set.buckets;
  Array.forEachi((bucket, idx) => {
    buckets[idx] = None;
  }, buckets);
}

let rec forEachBucket = (fn, node) => {
  match (node) {
    None => void,
    Some({ key, next }) => {
      fn(key);
      forEachBucket(fn, next);
    }
  }
}

/**
 * Iterates the given function over each value in the set.
 *
 * @param fn: The function to call on each element in the set.
 * @param set: The set to iterate.
 */
export let forEach = (fn, set) => {
  let buckets = set.buckets;
  Array.forEach((bucket) => {
    forEachBucket(fn, bucket)
  }, buckets);
}

let rec reduceEachBucket = (fn, node, acc) => {
  match (node) {
    None => acc,
    Some({ key, next }) =>
      reduceEachBucket(fn, next, fn(acc, key))
  }
}

/**
 * Reduces all values within a set to a single value. The reducer function is called with the accumulator and the current value.
 *
 * @param fn: The function to call on each element in the set.
 * @param init: A value to which the previousValue is initialized with.
 * @param set: The set to reduce.
 * @returns The reduced set.
 */
export let reduce = (fn, init, set) => {
  let buckets = set.buckets;
  let mut acc = init;
  Array.forEach((bucket) => {
    acc = reduceEachBucket(fn, bucket, acc)
  }, buckets);
  acc
}

/**
 * Keeps all values that the predicate returned `true` for from the set.
 *
 * @param fn: The function used to filter the set returning `true` indicates to keep the value.
 * @param set: The set to filter.
 */
export let filter = (predicate, set) => {
  let keysToRemove = reduce((list, key) =>
    if (!predicate(key)) {
      [key, ...list]
    } else {
      list
    }, [], set);
  List.forEach((key) => {
    remove(key, set);
  }, keysToRemove);
}

/**
 * Removes all values that the predicate returned true for from the set.
 *
 * @param fn: The function used to filter the set returning `true` indicates to remove the value.
 * @param set: The set to filter.
 */
export let reject = (predicate, set) => {
  filter((key) => !predicate(key), set)
}

/**
 * Returns a list from the values of a set.
 *
 * @param set: The set to convert.
 * @returns The generated List.
 */
export let toList = (set) => {
  reduce((list, key) => [key, ...list], [], set)
}

/**
 * Creates a set from a list.
 *
 * @param list: The list to convert.
 * @returns The generated set.
 */
export let fromList = (list) => {
  let set = make();
  List.forEach((key) => {
    add(key, set);
  }, list);
  set
}

/**
 * Returns an array from the values of a set.
 *
 * @param set: The set to convert.
 * @returns The generated array.
 */
export let toArray = (set) => {
  Array.fromList(toList(set))
}

/**
 * Creates a set from an array.
 *
 * @param array: The array to convert.
 * @returns The generated set.
 */
export let fromArray = (array) => {
  let set = make();
  Array.forEach((key) => {
    add(key, set);
  }, array);
  set
}

/**
 * Creates a single set from the union of the given sets.
 *
 * @param set1: The first set to union.
 * @param set2: The second set to union.
 * @returns The generated set.
 */
export let union = (set1, set2) => {
  let set = make();
  forEach((key) => {
    add(key, set);
  }, set1)
  forEach((key) => {
    add(key, set);
  }, set2);
  set
}

/**
 * Creates a set from the difference of the given sets.
 *
 * @param set1: The first set to merge.
 * @param set2: The second set to merge.
 * @returns The generated set.
 */
export let diff = (set1, set2) => {
  let set = make();
  forEach((key) => {
    if (!contains(key, set2)) {
      add(key, set);
    }
  }, set1)
  forEach((key) => {
    if (!contains(key, set1)) {
      add(key, set);
    }
  }, set2);
  set
}

/**
 * Creates a set from the intersection of the given sets.
 *
 * @param set1: The first set to merge.
 * @param set2: The second set to merge.
 * @returns The generated set.
 */
export let intersect = (set1, set2) => {
  let set = make();
  forEach((key) => {
    if (contains(key, set2)) {
      add(key, set);
    }
  }, set1)
  forEach((key) => {
    if (contains(key, set1)) {
      add(key, set);
    }
  }, set2);
  set
}

// TODO: Should return a Record type instead of a Tuple
// Waiting on https://github.com/grain-lang/grain/issues/190
/**
 * Returns a tuple representing the internal state state of the set.
 *
 * @param set: The set to operate on.
 * @returns The tuple representation of the internal state of the set.
 */
export let getInternalStats = (set) => {
  (set.size, Array.length(set.buckets))
}
