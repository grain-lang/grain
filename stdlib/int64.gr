/**
 * @module Int64: Operations on the Int64 type.
 * @example import Int64 from "int64"
 */
import WasmI32 from "runtime/unsafe/wasmi32"
import WasmI64 from "runtime/unsafe/wasmi64"
import Exception from "runtime/exception"
import Memory from "runtime/unsafe/memory"

import {
  newInt64
} from "runtime/dataStructures"

import {
  coerceNumberToInt64 as fromNumber,
  coerceInt64ToNumber as toNumber
} from "runtime/numbers"

/**
 * @section Values: Functions for working with the `Int64` data type.
 */

/**
 * Coverts the argument from a `Number` to a `Int64`.
 *
 * @param x: The `Number` to convert
 * @returns The converted `Number`
 */
export fromNumber

/**
 * Coverts the argument from a `Int64` to a `Number`.
 *
 * @param x: The `Int64` to convert
 * @returns The converted `Int64`
 */
export toNumber

/**
 * Increments the number by 1.
 *
 * @param x: The `Int64` to increment
 * @returns The incremented `Int64`
 */
@disableGC
export let rec incr = (n: Int64) => {
  let n = WasmI32.fromGrain(n)
  let ptr = newInt64(WasmI64.add(WasmI64.load(n, 8n), 1N))
  let ret = WasmI32.toGrain(ptr): Int64
  Memory.decRef(n)
  Memory.decRef(WasmI32.fromGrain(incr))
  ret
}

/**
 * Decrements the number by 1.
 *
 * @param x: The `Int64` to decrement
 * @returns The decremented `Int64`
 */
@disableGC
export let decr = (n: Int64) => {
  let n = WasmI32.fromGrain(n)
  let ptr = newInt64(WasmI64.sub(WasmI64.load(n, 8n), 1N))
  let ret = WasmI32.toGrain(ptr): Int64
  Memory.decRef(n)
  Memory.decRef(WasmI32.fromGrain(decr))
  ret
}

/**
 * Integer addition.
 *
 * @param x: The first operand
 * @param y: The second operand
 * @returns The sum of the two operands
 */
@disableGC
export let rec add = (x: Int64, y: Int64) => {
  let xv = WasmI64.load(WasmI32.fromGrain(x), 8n)
  let yv = WasmI64.load(WasmI32.fromGrain(y), 8n)
  let ptr = newInt64(WasmI64.add(xv, yv))
  let ret = WasmI32.toGrain(ptr): Int64
  Memory.decRef(WasmI32.fromGrain(x))
  Memory.decRef(WasmI32.fromGrain(y))
  Memory.decRef(WasmI32.fromGrain(add))
  ret
}

/**
 * Integer subtraction.
 *
 * @param x: The first operand
 * @param y: The second operand
 * @returns The difference of the two operands
 */
@disableGC
export let rec sub = (x: Int64, y: Int64) => {
  let xv = WasmI64.load(WasmI32.fromGrain(x), 8n)
  let yv = WasmI64.load(WasmI32.fromGrain(y), 8n)
  let ptr = newInt64(WasmI64.sub(xv, yv))
  let ret = WasmI32.toGrain(ptr): Int64
  Memory.decRef(WasmI32.fromGrain(x))
  Memory.decRef(WasmI32.fromGrain(y))
  Memory.decRef(WasmI32.fromGrain(sub))
  ret
}

/**
 * Integer multiplication.
 *
 * @param x: The first operand
 * @param y: The second operand
 * @returns The product of the two operands
 */
@disableGC
export let rec mul = (x: Int64, y: Int64) => {
  let xv = WasmI64.load(WasmI32.fromGrain(x), 8n)
  let yv = WasmI64.load(WasmI32.fromGrain(y), 8n)
  let ptr = newInt64(WasmI64.mul(xv, yv))
  let ret = WasmI32.toGrain(ptr): Int64
  Memory.decRef(WasmI32.fromGrain(x))
  Memory.decRef(WasmI32.fromGrain(y))
  Memory.decRef(WasmI32.fromGrain(mul))
  ret
}

/**
 * Integer division.
 *
 * @param x: The first operand
 * @param y: The second operand
 * @returns The quotient of the two operands
 */
@disableGC
export let rec div = (x: Int64, y: Int64) => {
  let xv = WasmI64.load(WasmI32.fromGrain(x), 8n)
  let yv = WasmI64.load(WasmI32.fromGrain(y), 8n)
  let ptr = newInt64(WasmI64.divS(xv, yv))
  let ret = WasmI32.toGrain(ptr): Int64
  Memory.decRef(WasmI32.fromGrain(x))
  Memory.decRef(WasmI32.fromGrain(y))
  Memory.decRef(WasmI32.fromGrain(div))
  ret
}

/**
 * Unsigned integer division.
 *
 * @param x: The first operand
 * @param y: The second operand
 * @returns The quotient of the two operands
 */
@disableGC
export let rec divU = (x: Int64, y: Int64) => {
  let xv = WasmI64.load(WasmI32.fromGrain(x), 8n)
  let yv = WasmI64.load(WasmI32.fromGrain(y), 8n)
  let ptr = newInt64(WasmI64.divU(xv, yv))
  let ret = WasmI32.toGrain(ptr): Int64
  Memory.decRef(WasmI32.fromGrain(x))
  Memory.decRef(WasmI32.fromGrain(y))
  Memory.decRef(WasmI32.fromGrain(divU))
  ret
}

/**
 * Integer remainder.
 *
 * @param x: The first operand
 * @param y: The second operand
 * @returns The signed remainder from a division of its two operands
 */
@disableGC
export let rec rem = (x: Int64, y: Int64) => {
  let xv = WasmI64.load(WasmI32.fromGrain(x), 8n)
  let yv = WasmI64.load(WasmI32.fromGrain(y), 8n)
  let ptr = newInt64(WasmI64.remS(xv, yv))
  let ret = WasmI32.toGrain(ptr): Int64
  Memory.decRef(WasmI32.fromGrain(x))
  Memory.decRef(WasmI32.fromGrain(y))
  Memory.decRef(WasmI32.fromGrain(rem))
  ret
}

/**
 * Unsigned integer remainder.
 *
 * @param x: The first operand
 * @param y: The second operand
 * @returns The unsigned remainder from a division of its two operands
 */
@disableGC
export let rec remU = (x: Int64, y: Int64) => {
  let xv = WasmI64.load(WasmI32.fromGrain(x), 8n)
  let yv = WasmI64.load(WasmI32.fromGrain(y), 8n)
  let ptr = newInt64(WasmI64.remU(xv, yv))
  let ret = WasmI32.toGrain(ptr): Int64
  Memory.decRef(WasmI32.fromGrain(x))
  Memory.decRef(WasmI32.fromGrain(y))
  Memory.decRef(WasmI32.fromGrain(remU))
  ret
}

@disableGC
let abs = (n) => {
  let mask = WasmI64.shrS(n, 63N)
  WasmI64.sub(WasmI64.xor(n, mask), mask)
}

/**
 * Integer modulo.
 *
 * @param x: The first operand
 * @param y: The second operand
 * @returns The remainder from a division of its two operands
 */
@disableGC
export let rec mod = (x: Int64, y: Int64) => {
  let xval = WasmI64.load(WasmI32.fromGrain(x), 8n)
  let yval = WasmI64.load(WasmI32.fromGrain(y), 8n)

  if (WasmI64.eqz(yval)) {
    throw Exception.ModuloByZero
  }

  let ptr = if (WasmI64.ltS(WasmI64.xor(xval, yval), 0N)) {
    let xabs = abs(xval)
    let yabs = abs(yval)
    let mval = WasmI64.remS(xabs, yabs)
    let mres = WasmI64.sub(yabs, mval)
    newInt64(if (WasmI64.ne(mval, 0N)) (if (WasmI64.ltS(yval, 0N)) WasmI64.sub(0N, mres) else mres) else 0N)
  } else {
    newInt64(WasmI64.remS(xval, yval))
  }
  let ret = WasmI32.toGrain(ptr): Int64
  Memory.decRef(WasmI32.fromGrain(x))
  Memory.decRef(WasmI32.fromGrain(y))
  Memory.decRef(WasmI32.fromGrain(mod))
  ret
}

/**
 * Integer count leading zeros.
 *
 * @param x: The operand
 * @returns The number of leading zeros in its operand
 */
@disableGC
export let rec clz = (n: Int64) => {
  let nv = WasmI64.load(WasmI32.fromGrain(n), 8n)
  let ptr = newInt64(WasmI64.clz(nv))
  let ret = WasmI32.toGrain(ptr): Int64
  Memory.decRef(WasmI32.fromGrain(n))
  Memory.decRef(WasmI32.fromGrain(clz))
  ret
}

/**
 * Integer count trailing zeros.
 *
 * @param x: The operand
 * @returns The number of trailing zeros in its operand
 */
@disableGC
export let rec ctz = (n: Int64) => {
  let nv = WasmI64.load(WasmI32.fromGrain(n), 8n)
  let ptr = newInt64(WasmI64.ctz(nv))
  let ret = WasmI32.toGrain(ptr): Int64
  Memory.decRef(WasmI32.fromGrain(n))
  Memory.decRef(WasmI32.fromGrain(ctz))
  ret
}

/**
 * Integer population count.
 *
 * @param x: The operand
 * @returns The number of `1-bits` in its operand
 */
@disableGC
export let rec popcnt = (n: Int64) => {
  let nv = WasmI64.load(WasmI32.fromGrain(n), 8n)
  let ptr = newInt64(WasmI64.popcnt(nv))
  let ret = WasmI32.toGrain(ptr): Int64
  Memory.decRef(WasmI32.fromGrain(n))
  Memory.decRef(WasmI32.fromGrain(popcnt))
  ret
}

/**
 * Integer rotate left.
 *
 * @param x: The first operand
 * @param y: The second operand
 * @returns The value of the first operand rotated to the left by the shift count
 */
@disableGC
export let rec rotl = (x: Int64, y: Int64) => {
  let xv = WasmI64.load(WasmI32.fromGrain(x), 8n)
  let yv = WasmI64.load(WasmI32.fromGrain(y), 8n)
  let ptr = newInt64(WasmI64.rotl(xv, yv))
  let ret = WasmI32.toGrain(ptr): Int64
  Memory.decRef(WasmI32.fromGrain(x))
  Memory.decRef(WasmI32.fromGrain(y))
  Memory.decRef(WasmI32.fromGrain(rotl))
  ret
}

/**
 * Integer rotate right.
 *
 * @param x: The first operand
 * @param y: The second operand
 * @returns The value of the first operand rotated to the right by the shift count
 */
@disableGC
export let rec rotr = (x: Int64, y: Int64) => {
  let xv = WasmI64.load(WasmI32.fromGrain(x), 8n)
  let yv = WasmI64.load(WasmI32.fromGrain(y), 8n)
  let ptr = newInt64(WasmI64.rotr(xv, yv))
  let ret = WasmI32.toGrain(ptr): Int64
  Memory.decRef(WasmI32.fromGrain(x))
  Memory.decRef(WasmI32.fromGrain(y))
  Memory.decRef(WasmI32.fromGrain(rotr))
  ret
}


/**
 * @section Comparisons: Comparison functions for working with integers.
 */

/**
 * Integer equal.
 *
 * @param x: The first argument
 * @param y: The second argument
 * @returns A boolean representing if the arguments are equal
 */
@disableGC
export let rec eq = (x: Int64, y: Int64) => {
  let xv = WasmI64.load(WasmI32.fromGrain(x), 8n)
  let yv = WasmI64.load(WasmI32.fromGrain(y), 8n)
  let ret = WasmI64.eq(xv, yv)
  Memory.decRef(WasmI32.fromGrain(x))
  Memory.decRef(WasmI32.fromGrain(y))
  Memory.decRef(WasmI32.fromGrain(eq))
  ret
}

/**
 * Integer inequality.
 *
 * @param x: The first argument
 * @param y: The second argument
 * @returns A boolean representing if the arguments are not equal
 */
@disableGC
export let rec ne = (x: Int64, y: Int64) => {
  let xv = WasmI64.load(WasmI32.fromGrain(x), 8n)
  let yv = WasmI64.load(WasmI32.fromGrain(y), 8n)
  let ret = WasmI64.ne(xv, yv)
  Memory.decRef(WasmI32.fromGrain(x))
  Memory.decRef(WasmI32.fromGrain(y))
  Memory.decRef(WasmI32.fromGrain(ne))
  ret
}

/**
 * Integer equal to zero.
 *
 * @param x: The argument
 * @returns A boolean indicating if the argument is equal to zero
 */
@disableGC
export let rec eqz = (n: Int64) => {
  let xv = WasmI64.load(WasmI32.fromGrain(n), 8n)
  let ret = WasmI64.eqz(xv)
  Memory.decRef(WasmI32.fromGrain(n))
  Memory.decRef(WasmI32.fromGrain(eqz))
  ret
}

/**
 * Checks if the first argument is strictly less than the second argument.
 *
 * @param x: The first argument
 * @param y: The second argument
 * @returns A boolean representing if the first argument is less then the second argument
 */
@disableGC
export let rec lt = (x: Int64, y: Int64) => {
  let xv = WasmI64.load(WasmI32.fromGrain(x), 8n)
  let yv = WasmI64.load(WasmI32.fromGrain(y), 8n)
  let ret = WasmI64.ltS(xv, yv)
  Memory.decRef(WasmI32.fromGrain(x))
  Memory.decRef(WasmI32.fromGrain(y))
  Memory.decRef(WasmI32.fromGrain(lt))
  ret
}

/**
 * Checks if the first argument is strictly greater than the second argument.
 *
 * @param x: The first argument
 * @param y: The second argument
 * @returns A boolean representing if the first argument is greater then the second argument
 */
@disableGC
export let rec gt = (x: Int64, y: Int64) => {
  let xv = WasmI64.load(WasmI32.fromGrain(x), 8n)
  let yv = WasmI64.load(WasmI32.fromGrain(y), 8n)
  let ret = WasmI64.gtS(xv, yv)
  Memory.decRef(WasmI32.fromGrain(x))
  Memory.decRef(WasmI32.fromGrain(y))
  Memory.decRef(WasmI32.fromGrain(gt))
  ret
}

/**
 * Checks if the first argument is strictly less then or equal to the second argument.
 *
 * @param x: The first argument
 * @param y: The second argument
 * @returns A boolean representing if the first argument is less then or equal to the second argument
 */
@disableGC
export let rec lte = (x: Int64, y: Int64) => {
  let xv = WasmI64.load(WasmI32.fromGrain(x), 8n)
  let yv = WasmI64.load(WasmI32.fromGrain(y), 8n)
  let ret = WasmI64.leS(xv, yv)
  Memory.decRef(WasmI32.fromGrain(x))
  Memory.decRef(WasmI32.fromGrain(y))
  Memory.decRef(WasmI32.fromGrain(lte))
  ret
}

/**
 * Checks if the first argument is strictly greater then or equal to the second argument.
 *
 * @param x: The first argument
 * @param y: The second argument
 * @returns A boolean representing if the first argument is greater then or equal to the second argument
 */
@disableGC
export let rec gte = (x: Int64, y: Int64) => {
  let xv = WasmI64.load(WasmI32.fromGrain(x), 8n)
  let yv = WasmI64.load(WasmI32.fromGrain(y), 8n)
  let ret = WasmI64.geS(xv, yv)
  Memory.decRef(WasmI32.fromGrain(x))
  Memory.decRef(WasmI32.fromGrain(y))
  Memory.decRef(WasmI32.fromGrain(gte))
  ret
}

// Int64 bit/logical operations
/**
 * @section Logical operations: logical operations for working with Integers.
 */

/**
 * Computes the bitwise logical "not" of the argument.
 *
 * @param x: The first argument
 * @returns The bitwise logical "not" of the argument
 */
@disableGC
export let rec lnot = (x: Int64) => {
  let xv = WasmI64.load(WasmI32.fromGrain(x), 8n)
  let ptr = newInt64(WasmI64.xor(xv, 0xffffffffffffffffN))
  let ret = WasmI32.toGrain(ptr): Int64
  Memory.decRef(WasmI32.fromGrain(x))
  Memory.decRef(WasmI32.fromGrain(lnot))
  ret
}

/**
 * Computes the bitwise logical "and" of the argument.
 *
 * @param x: The first argument
 * @returns The bitwise logical "and" of the argument
 */
@disableGC
export let rec land = (x: Int64, y: Int64) => {
  let xv = WasmI64.load(WasmI32.fromGrain(x), 8n)
  let yv = WasmI64.load(WasmI32.fromGrain(y), 8n)
  let ptr = newInt64(WasmI64.and(xv, yv))
  let ret = WasmI32.toGrain(ptr): Int64
  Memory.decRef(WasmI32.fromGrain(x))
  Memory.decRef(WasmI32.fromGrain(y))
  Memory.decRef(WasmI32.fromGrain(land))
  ret
}

/**
 * Computes the bitwise logical "or" of the argument.
 *
 * @param x: The first argument
 * @returns The bitwise logical "or" of the argument
 */
@disableGC
export let rec lor = (x: Int64, y: Int64) => {
  let xv = WasmI64.load(WasmI32.fromGrain(x), 8n)
  let yv = WasmI64.load(WasmI32.fromGrain(y), 8n)
  let ptr = newInt64(WasmI64.or(xv, yv))
  let ret = WasmI32.toGrain(ptr): Int64
  Memory.decRef(WasmI32.fromGrain(x))
  Memory.decRef(WasmI32.fromGrain(y))
  Memory.decRef(WasmI32.fromGrain(lor))
  ret
}

/**
 * Computes the bitwise logical "xor" of the argument.
 *
 * @param x: The first argument
 * @param x: The second argument
 * @returns The bitwise logical "xor" of the argument
 */
@disableGC
export let rec lxor = (x: Int64, y: Int64) => {
  let xv = WasmI64.load(WasmI32.fromGrain(x), 8n)
  let yv = WasmI64.load(WasmI32.fromGrain(y), 8n)
  let ptr = newInt64(WasmI64.xor(xv, yv))
  let ret = WasmI32.toGrain(ptr): Int64
  Memory.decRef(WasmI32.fromGrain(x))
  Memory.decRef(WasmI32.fromGrain(y))
  Memory.decRef(WasmI32.fromGrain(lxor))
  ret
}

/**
 * Computes the bitwise arithmetic (signed) shift right of the first argument by the second argument.
 *
 * @param x: The first argument
 * @param x: The second argument
 * @returns The bitwise logical shift left of the first argument by the second argument
 */
@disableGC
export let rec shl = (x: Int64, y: Int64) => {
  let xv = WasmI64.load(WasmI32.fromGrain(x), 8n)
  let yv = WasmI64.load(WasmI32.fromGrain(y), 8n)
  let ptr = newInt64(WasmI64.shl(xv, yv))
  let ret = WasmI32.toGrain(ptr): Int64
  Memory.decRef(WasmI32.fromGrain(x))
  Memory.decRef(WasmI32.fromGrain(y))
  Memory.decRef(WasmI32.fromGrain(shl))
  ret
}

/**
 * Computes the bitwise logical shift right of the first argument by the second argument.
 *
 * @param x: The first argument
 * @param x: The second argument
 * @returns The bitwise arithmetic (signed) shift right of the first argument by the second argument
 */
@disableGC
export let rec shr = (x: Int64, y: Int64) => {
  let xv = WasmI64.load(WasmI32.fromGrain(x), 8n)
  let yv = WasmI64.load(WasmI32.fromGrain(y), 8n)
  let ptr = newInt64(WasmI64.shrS(xv, yv))
  let ret = WasmI32.toGrain(ptr): Int64
  Memory.decRef(WasmI32.fromGrain(x))
  Memory.decRef(WasmI32.fromGrain(y))
  Memory.decRef(WasmI32.fromGrain(shr))
  ret
}

/**
 * Computes the unsigned bitwise logical shift right of the first argument by the second argument.
 *
 * @param x: The first argument
 * @param x: The second argument
 * @returns The bitwise arithmetic (unsigned) shift right of the first argument by the second argument
 */
@disableGC
export let rec shrU = (x: Int64, y: Int64) => {
  let xv = WasmI64.load(WasmI32.fromGrain(x), 8n)
  let yv = WasmI64.load(WasmI32.fromGrain(y), 8n)
  let ptr = newInt64(WasmI64.shrU(xv, yv))
  let ret = WasmI32.toGrain(ptr): Int64
  Memory.decRef(WasmI32.fromGrain(x))
  Memory.decRef(WasmI32.fromGrain(y))
  Memory.decRef(WasmI32.fromGrain(shrU))
  ret
}
