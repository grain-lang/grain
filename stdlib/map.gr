// Standard library for Map (aka HashMap) functionality

import List from "list"
import Array from "array"
import { hash } from "hash"
import Memory from "runtime/unsafe/memory"
import WasmI32 from "runtime/unsafe/wasmi32"
import { allocateArray } from "runtime/dataStructures"

// TODO: Consider implementing this as List<(Box<k>, Box<v>)>
record Bucket<k, v> {
  mut key: k,
  mut value: v,
  mut next: Option<Bucket<k, v>>,
}

record Map<k, v> {
  mut size: Number,
  mut buckets: Array<Option<Bucket<k, v>>>,
}

/**
 * Creates a new empty map with an initial storage of the given length. As values are added or removed, the length may grow or shrink. Generally, you won't need to care about the length of your map and can use `Map.make()` instead.
 *
 * @param storageLength: The initial storage length of the map
 * @returns An empty map with the given initial storage length
 * 
 */
// TODO: This could take an `eq` function to custom comparisons
export let makeSized = storageLength => {
  let buckets = Array.make(storageLength, None)
  { size: 0, buckets }
}

/**
 * Creates a new, empty map.
 *
 * @returns An empty map
 * 
 */
export let make = () => {
  makeSized(16)
}

let getBucketIndex = (key, buckets) => {
  let bucketsLength = Array.length(buckets)
  let hashedKey = hash(key)
  hashedKey % bucketsLength
}

let rec copyNodeWithNewHash = (oldNode, next, tail) => {
  match (oldNode) {
    None => void,
    Some(node) => {
      let idx = getBucketIndex(node.key, next)
      let newNode = Some(node)
      match (tail[idx]) {
        None => {
          next[idx] = newNode
        },
        Some(tailNode) => {
          // If there's already a tail node, we add this to the end
          tailNode.next = newNode
        },
      }
      // Always place this node as the new tail
      tail[idx] = newNode
      // Recurse with the next node
      copyNodeWithNewHash(node.next, next, tail)
    },
  }
}

let resize = map => {
  let currentBuckets = map.buckets
  let currentSize = Array.length(currentBuckets)
  let nextSize = currentSize * 2
  if (nextSize >= currentSize) {
    let nextBuckets = Array.make(nextSize, None)
    // This tracks the tail nodes so we can set their `next` to None
    let tailNodes = Array.make(nextSize, None)
    map.buckets = nextBuckets
    Array.forEach(old => {
      copyNodeWithNewHash(old, nextBuckets, tailNodes)
    }, currentBuckets)
    Array.forEach(tail => {
      match (tail) {
        None => void,
        Some(node) => {
          node.next = None
        },
      }
    }, tailNodes)
  } else {
    void
  }
}

let rec replaceInBucket = (key, value, node) => {
  if (key == node.key) {
    node.value = value
    false
  } else {
    match (node.next) {
      None => true,
      Some(next) => replaceInBucket(key, value, next),
    }
  }
}

/**
 * Adds a new key pair to the map. If the key already exists in the map, the value is replaced.
 *
 * @param key: The key to add the value under
 * @param value: The value to set
 * @param map: The map to modify
 * 
 */
export let set = (key, value, map) => {
  let buckets = map.buckets
  let idx = getBucketIndex(key, buckets)
  let bucket = buckets[idx]
  match (bucket) {
    None => {
      buckets[idx] = Some({ key, value, next: None })
      map.size = incr(map.size)
    },
    Some(node) => {
      if (replaceInBucket(key, value, node)) {
        buckets[idx] = Some({ key, value, next: bucket })
        map.size = incr(map.size)
      }
    },
  }
  // Resize if there are more than 2x the amount of nodes as buckets
  if (map.size > Array.length(buckets) * 2) {
    resize(map)
  } else {
    void
  }
}

let rec valueFromBucket = (key, node) => {
  if (key == node.key) {
    Some(node.value)
  } else {
    match (node.next) {
      None => None,
      Some(next) => valueFromBucket(key, next),
    }
  }
}

/**
 * Returns the value for the given key.
 *
 * @param key: The key to look up
 * @param map: The map to get the value from
 * 
 * @returns `Some(value)` if the given key pair is in the map, `None` otherwise
 */
export let get = (key, map) => {
  let buckets = map.buckets
  let idx = getBucketIndex(key, buckets)
  let bucket = buckets[idx]
  match (bucket) {
    None => None,
    Some(node) => valueFromBucket(key, node),
  }
}

let rec nodeInBucket = (key, node) => {
  if (key == node.key) {
    true
  } else {
    match (node.next) {
      None => false,
      Some(next) => nodeInBucket(key, next),
    }
  }
}

/**
 * Determines if the map contains a value for the given key.
 *
 * @param key: The key to search for
 * @param map: The map to search
 * @returns `true` if the map contains the given key, `false` otherwise
 * 
 */
export let contains = (key, map) => {
  let buckets = map.buckets
  let idx = getBucketIndex(key, buckets)
  let bucket = buckets[idx]
  match (bucket) {
    None => false,
    Some(node) => nodeInBucket(key, node),
  }
}

let rec removeInBucket = (key, node) => {
  match (node.next) {
    None => false,
    Some(next) => {
      if (key == next.key) {
        node.next = next.next
        true
      } else {
        removeInBucket(key, next)
      }
    },
  }
}

/**
 * Removes the given key pair from the map. If the key pair doesn't exist, nothing happens.
 *
 * @param key: The key to remove
 * @param map: The map to update
 * 
 */
export let remove = (key, map) => {
  let buckets = map.buckets
  let idx = getBucketIndex(key, buckets)
  let bucket = buckets[idx]
  match (bucket) {
    None => void,
    Some(node) => {
      // If it is a top-level node, just replace with next node
      if (key == node.key) {
        map.size = decr(map.size)
        buckets[idx] = node.next
      } else {
        if (removeInBucket(key, node)) {
          map.size = decr(map.size)
        }
      }
    },
  }
}

/**
 * Applys a given function to a key pair in the map.
 *
 * @param key: The key indicating which key pair to update
 * @param fn: The function to apply
 * @param map: The map to modify
 * 
 */
export let update = (key, fn, map) => {
  let val = get(key, map)
  match (fn(val)) {
    Some(next) => set(key, next, map),
    None => remove(key, map),
  }
}

/**
 * Returns the number of key pairs within the map.
 *
 * @param map: The map to inspect
 * @returns The number of key pairs in the map
 * 
 */
export let size = map => {
  map.size
}

/**
 * Determines if the map contains no key pairs.
 *
 * @param map: The map to inspect
 * @returns `true` if the given map is empty, `false` otherwise
 * 
 */
export let isEmpty = map => {
  size(map) == 0
}

/**
 * Resets the map by removing all key pairs.
 *
 * @param map: The map to reset
 * 
 */
export let clear = map => {
  map.size = 0
  let buckets = map.buckets
  Array.forEachi((bucket, idx) => {
    buckets[idx] = None
  }, buckets)
}

let rec forEachBucket = (fn, node) => {
  match (node) {
    None => void,
    Some({ key, value, next }) => {
      fn(key, value)
      forEachBucket(fn, next)
    },
  }
}

/**
 * Iterates the map, calling an iterator function on each key pair.
 *
 * @param fn: The iterator function to call with each key pair
 * @param map: The map to iterate
 * 
 */
export let forEach = (fn, map) => {
  let buckets = map.buckets
  Array.forEach(bucket => {
    forEachBucket(fn, bucket)
  }, buckets)
}

let rec reduceEachBucket = (fn, node, acc) => {
  match (node) {
    None => acc,
    Some({ key, value, next }) =>
      reduceEachBucket(fn, next, fn(acc, key, value)),
  }
}

/**
 * Combines all elements of a map using a reducer function.
 *
 * @param fn: The reducer function to call on each key pair, where the value returned will be the next accumulator value
 * @param init: The initial value to use for the accumulator on the first iteration
 * @param map: The map to iterate
 * @returns The final accumulator returned from `fn`
 * 
 */
export let reduce = (fn, init, map) => {
  let buckets = map.buckets
  let mut acc = init
  Array.forEach(bucket => {
    acc = reduceEachBucket(fn, bucket, acc)
  }, buckets)
  acc
}

/**
 * Generates a list of all keys in the given map.
 *
 * @param map: The map to inspect
 * 
 * @returns A list of all keys in the given map
 */
export let keys = map => {
  reduce((list, key, _value) => [key, ...list], [], map)
}

/**
 * Generates a list of all values in the given map.
 *
 * @param map: The map to inspect
 * 
 * @returns A list of all values in the given map
 */
export let values = map => {
  reduce((list, _key, value) => [value, ...list], [], map)
}

/**
 * Generates a list of all key pairs in the given map.
 *
 * @param map: The map to inspect
 * 
 * @returns A list of all key pairs in the given map
 */
export let toList = map => {
  reduce((list, key, value) => [(key, value), ...list], [], map)
}

/**
 * Generates a map given a list of key pairs.
 *
 * @param list: The list to inspect
 * 
 * @returns A map made from the list of key pairs
 */
export let fromList = list => {
  let map = make()
  List.forEach(pair => {
    let (key, value) = pair
    set(key, value, map)
  }, list)
  map
}

let setInArray = array => {
  @disableGC
  let rec iter = (i, key, value) => {
    array[i] = (key, value)
    // no decRef on key and value, since they are stored in array
    Memory.decRef(WasmI32.fromGrain(iter))
    i + 1
  }
  iter
}

/**
 * Generates a array of all key pairs in the given map.
 *
 * @param map: The map to inspect
 * 
 * @returns A array of all key pairs in the given map
 */
@disableGC
export let rec toArray = map => {
  let length = WasmI32.shrS(WasmI32.fromGrain(map.size), 1n)
  // TODO(#783): Removing parens around Array<a> causes a parse error
  let array = WasmI32.toGrain(allocateArray(length)): (Array<a>)
  Memory.incRef(WasmI32.fromGrain(setInArray))
  Memory.incRef(WasmI32.fromGrain(array))
  let setInArray = setInArray(array)
  Memory.incRef(WasmI32.fromGrain(reduce))
  Memory.incRef(WasmI32.fromGrain(setInArray))
  Memory.incRef(WasmI32.fromGrain(map))
  reduce(setInArray, 0, map)
  Memory.decRef(WasmI32.fromGrain(setInArray))
  Memory.decRef(WasmI32.fromGrain(map))
  Memory.decRef(WasmI32.fromGrain(toArray))
  array
}

/**
 * Generates a map given a array of key pairs.
 *
 * @param array: The array to inspect
 * 
 * @returns A map made from the array of key pairs
 */
export let fromArray = array => {
  let map = make()
  Array.forEach(pair => {
    let (key, value) = pair
    set(key, value, map)
  }, array)
  map
}

/**
 * Removes key pairs from a map where a predicate function returns `false`.
 *
 * @param fn: The predicate function to indicate which key pairs to remove from the map, where returning `false` indicates the key pair should be removed
 * @param map: The map to iterate
 * 
 */
export let filter = (predicate, map) => {
  let keysToRemove = reduce((list, key, value) => if (!predicate(key, value)) {
    [key, ...list]
  } else {
    list
  }, [], map)
  List.forEach(key => {
    remove(key, map)
  }, keysToRemove)
}

/**
 * Removes key pairs from a map where a predicate function returns `true`.
 *
 * @param fn: The predicate function to indicate which key pairs to remove from the map, where returning `true` indicates the key pair should be removed
 * @param map: The map to iterate
 * 
 */
export let reject = (predicate, map) => {
  filter((key, value) => !predicate(key, value), map)
}

// TODO: Should return a Record type instead of a Tuple
// Waiting on https://github.com/grain-lang/grain/issues/190
/**
 * Provides data representing the internal state state of the map.
 *
 * @param map: The map to inspect
 * @returns The internal state of the map
 * 
 */
export let getInternalStats = map => {
  (map.size, Array.length(map.buckets))
}
