/**
 * @module Float32: Operations on the Float32 type.
 * @example import Float32 from "float32"
 */
import WasmI32 from "runtime/unsafe/wasmi32"
import WasmF32 from "runtime/unsafe/wasmf32"
import Memory from "runtime/unsafe/memory"
import {
  newFloat32
} from "runtime/dataStructures"

import {
  coerceNumberToFloat32 as fromNumber,
  coerceFloat32ToNumber as toNumber
} from "runtime/numbers"

/**
 * @section Values: Functions for working with the `Float32` data type.
 */

/**
 * Coverts the argument from a `Number` to a `Float32`.
 *
 * @param x: The `Number` to convert.
 * @returns The converted `Number`.
 */
export fromNumber

/**
 * Coverts the argument from a `Float32` to a `Number`.
 *
 * @param x: The `Float32` to convert.
 * @returns The converted `Float32`.
 */
export toNumber

/**
 * Floating-point addition.
 *
 * @param x: The first operand.
 * @param y: The second operand.
 * @returns The sum of the two operands.
 */
@disableGC
export let rec add = (x: Float32, y: Float32) => {
  let xv = WasmF32.load(WasmI32.fromGrain(x), 8n)
  let yv = WasmF32.load(WasmI32.fromGrain(y), 8n)
  let ptr = newFloat32(WasmF32.add(xv, yv))
  let ret = WasmI32.toGrain(ptr) : Float32
  Memory.decRef(WasmI32.fromGrain(x))
  Memory.decRef(WasmI32.fromGrain(y))
  Memory.decRef(WasmI32.fromGrain(add))
  ret
}

/**
 * Floating-point subtraction.
 *
 * @param x: The first operand.
 * @param y: The second operand.
 * @returns The difference of the two operands.
 */
@disableGC
export let rec sub = (x: Float32, y: Float32) => {
  let xv = WasmF32.load(WasmI32.fromGrain(x), 8n)
  let yv = WasmF32.load(WasmI32.fromGrain(y), 8n)
  let ptr = newFloat32(WasmF32.sub(xv, yv))
  let ret = WasmI32.toGrain(ptr) : Float32
  Memory.decRef(WasmI32.fromGrain(x))
  Memory.decRef(WasmI32.fromGrain(y))
  Memory.decRef(WasmI32.fromGrain(sub))
  ret
}

/**
 * Floating-point multiplication.
 *
 * @param x: The first operand.
 * @param y: The second operand.
 * @returns The product of the two operands.
 */
@disableGC
export let rec mul = (x: Float32, y: Float32) => {
  let xv = WasmF32.load(WasmI32.fromGrain(x), 8n)
  let yv = WasmF32.load(WasmI32.fromGrain(y), 8n)
  let ptr = newFloat32(WasmF32.mul(xv, yv))
  let ret = WasmI32.toGrain(ptr) : Float32
  Memory.decRef(WasmI32.fromGrain(x))
  Memory.decRef(WasmI32.fromGrain(y))
  Memory.decRef(WasmI32.fromGrain(mul))
  ret
}

/**
 * Floating-point division.
 *
 * @param x: The first operand.
 * @param y: The second operand.
 * @returns The quotient of the two operands.
 */
@disableGC
export let rec div = (x: Float32, y: Float32) => {
  let xv = WasmF32.load(WasmI32.fromGrain(x), 8n)
  let yv = WasmF32.load(WasmI32.fromGrain(y), 8n)
  let ptr = newFloat32(WasmF32.div(xv, yv))
  let ret = WasmI32.toGrain(ptr) : Float32
  Memory.decRef(WasmI32.fromGrain(x))
  Memory.decRef(WasmI32.fromGrain(y))
  Memory.decRef(WasmI32.fromGrain(div))
  ret
}

/**
 * @section Comparisons: Comparison functions for working with floating points.
 */

/**
 * Checks if the first argument is strictly less than the second argument.
 *
 * @param x: The first argument.
 * @param y: The second argument.
 * @returns A boolean representing if the first argument is less then the second argument.
 */
@disableGC
export let rec lt = (x: Float32, y: Float32) => {
  let xv = WasmF32.load(WasmI32.fromGrain(x), 8n)
  let yv = WasmF32.load(WasmI32.fromGrain(y), 8n)
  let ret = WasmF32.lt(xv, yv)
  Memory.decRef(WasmI32.fromGrain(x))
  Memory.decRef(WasmI32.fromGrain(y))
  Memory.decRef(WasmI32.fromGrain(lt))
  ret
}

/**
 * Checks if the first argument is strictly greater than the second argument.
 *
 * @param x: The first argument.
 * @param y: The second argument.
 * @returns A boolean representing if the first argument is greater then the second argument.
 */
@disableGC
export let rec gt = (x: Float32, y: Float32) => {
  let xv = WasmF32.load(WasmI32.fromGrain(x), 8n)
  let yv = WasmF32.load(WasmI32.fromGrain(y), 8n)
  let ret = WasmF32.gt(xv, yv)
  Memory.decRef(WasmI32.fromGrain(x))
  Memory.decRef(WasmI32.fromGrain(y))
  Memory.decRef(WasmI32.fromGrain(gt))
  ret
}

/**
 * Checks if the first argument is less than or equal to the second argument.
 *
 * @param x: The first argument.
 * @param y: The second argument.
 * @returns A boolean representing if the first argument is less then or equal to the second argument.
 */
@disableGC
export let rec lte = (x: Float32, y: Float32) => {
  let xv = WasmF32.load(WasmI32.fromGrain(x), 8n)
  let yv = WasmF32.load(WasmI32.fromGrain(y), 8n)
  let ret = WasmF32.le(xv, yv)
  Memory.decRef(WasmI32.fromGrain(x))
  Memory.decRef(WasmI32.fromGrain(y))
  Memory.decRef(WasmI32.fromGrain(lte))
  ret
}

/**
 * Checks if the first argument is greater than or equal to the second argument.
 *
 * @param x: The first argument.
 * @param y: The second argument.
 * @returns A boolean representing if the first argument is greater then or equal to the second argument.
 */
@disableGC
export let rec gte = (x: Float32, y: Float32) => {
  let xv = WasmF32.load(WasmI32.fromGrain(x), 8n)
  let yv = WasmF32.load(WasmI32.fromGrain(y), 8n)
  let ret = WasmF32.ge(xv, yv)
  Memory.decRef(WasmI32.fromGrain(x))
  Memory.decRef(WasmI32.fromGrain(y))
  Memory.decRef(WasmI32.fromGrain(gte))
  ret
}

/**
 * @section Constants: Constants related to floating points.
 */

/**
 * Generate infinity as a `Float32`.
 *
 * @returns infinity as a `Float32`.
 */
@disableGC
let rec makeInfinity = () => {
  let ptr = newFloat32(WasmF32.reinterpretI32(0b01111111100000000000000000000000n))
  let ret = WasmI32.toGrain(ptr) : Float32
  Memory.decRef(WasmI32.fromGrain(makeInfinity))
  ret
}

/**
 * Infinity as a `Float32`.
 */
export let infinity = makeInfinity()

/**
 * Generate Nan as a `Float32`.
 *
 * @returns nan as a `Float32`.
 */
@disableGC
let rec makeNaN = () => {
  let ptr = newFloat32(WasmF32.reinterpretI32(0b01111111100000000000000000000001n))
  let ret = WasmI32.toGrain(ptr) : Float32
  Memory.decRef(WasmI32.fromGrain(makeNaN))
  ret
}

/**
 * Nan as a `Float32`.
 */
export let nan = makeNaN()
