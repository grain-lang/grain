/**
 * Utilities for working with byte sequences.
 *
 * @example include "bytes"
 *
 * @since v0.3.2
 */

module Bytes

include "runtime/unsafe/memory"
include "runtime/unsafe/wasmi32"
include "runtime/unsafe/wasmi64"
include "runtime/unsafe/wasmf32"
include "runtime/unsafe/wasmf64"
include "runtime/unsafe/conv"
include "runtime/dataStructures"
from DataStructures use {
  tagInt8,
  tagUint8,
  tagInt16,
  tagUint16,
  untagInt8,
  untagUint8,
  untagInt16,
  untagUint16,
  allocateBytes,
  allocateString,
}
include "runtime/exception"
include "int32"
include "runtime/numbers"
from Numbers use { coerceNumberToWasmI32 }

@unsafe
let _SIZE_OFFSET = 4n
@unsafe
let _VALUE_OFFSET = 8n
@unsafe
let _INT8_BYTE_SIZE = 1n
@unsafe
let _INT16_BYTE_SIZE = 2n
@unsafe
let _INT32_BYTE_SIZE = 4n
@unsafe
let _FLOAT32_BYTE_SIZE = 4n
@unsafe
let _INT64_BYTE_SIZE = 8n
@unsafe
let _FLOAT64_BYTE_SIZE = 8n

/** Throws an exception if the index specified is out-of-bounds */
@unsafe
let checkIndexIsInBounds = (i, byteSize, max) => {
  from WasmI32 use { (+), (<), (>) }
  if (i < 0n) {
    throw IndexOutOfBounds
  }
  if (i + byteSize > max) {
    throw IndexOutOfBounds
  }
}

/** Gets the size of a Bytes via its ptr */
@unsafe
let getSize = ptr => WasmI32.load(ptr, _SIZE_OFFSET)

/**
 * Creates a new byte sequence of the input size.
 *
 * @param size: The number of bytes to store
 * @returns The new byte sequence
 *
 * @since v0.3.2
 */
@unsafe
provide let make = (size: Number) => {
  from WasmI32 use { (+) }
  let size = coerceNumberToWasmI32(size)
  let bytes = allocateBytes(size)
  Memory.fill(bytes + 8n, 0n, size)
  WasmI32.toGrain(bytes): Bytes
}

/**
 * An empty byte sequence.
 *
 * @since v0.3.2
 */
provide let empty = make(0)

/**
 * Creates a new byte sequence from the input string.
 *
 * @param string: The string to copy into a byte sequence
 * @returns The new byte sequence
 *
 * @since v0.3.2
 */
@unsafe
provide let fromString = (string: String) => {
  from WasmI32 use { (+) }
  let src = WasmI32.fromGrain(string)
  let size = getSize(src)
  let dst = allocateBytes(size)
  Memory.copy(dst + _VALUE_OFFSET, src + _VALUE_OFFSET, size)
  WasmI32.toGrain(dst): Bytes
}

/**
 * Creates a new string from the input bytes.
 *
 * @param bytes: The source byte sequence
 * @returns The string representation of the bytes
 *
 * @since v0.3.2
 */
@unsafe
provide let toString = (bytes: Bytes) => {
  from WasmI32 use { (+) }
  let src = WasmI32.fromGrain(bytes)
  let size = getSize(src)
  let dst = allocateString(size)
  Memory.copy(dst + _VALUE_OFFSET, src + _VALUE_OFFSET, size)
  WasmI32.toGrain(dst): String
}

/**
 * Returns the length of a byte sequence.
 *
 * @param bytes: The byte sequence to inspect
 * @returns The number of bytes
 *
 * @since v0.3.2
 */
@unsafe
provide let length = (bytes: Bytes) => {
  let b = WasmI32.fromGrain(bytes)
  Conv.wasmI32ToNumber(getSize(b))
}

/**
 * Creates a new byte sequence that contains the same bytes as the input byte sequence.
 *
 * @param bytes: The byte sequence to copy
 * @returns The new byte sequence
 *
 * @since v0.3.2
 */
@unsafe
provide let copy = (b: Bytes) => {
  from WasmI32 use { (+) }
  let src = WasmI32.fromGrain(b)
  let size = getSize(src)
  let dst = allocateBytes(size)
  Memory.copy(dst + _VALUE_OFFSET, src + _VALUE_OFFSET, size)
  WasmI32.toGrain(dst): Bytes
}

/**
 * Returns a copy of a subset of the input byte sequence.
 *
 * @param start: The start index
 * @param length: The number of bytes to include after the starting index
 * @param bytes: The byte sequence to copy from
 * @returns A byte sequence with of the copied bytes
 *
 * @throws InvalidArgument(String): When `start + length` is greater than the bytes size
 *
 * @since v0.3.2
 */
@unsafe
provide let slice = (start: Number, length: Number, bytes: Bytes) => {
  from WasmI32 use { (+), (>) }
  let src = WasmI32.fromGrain(bytes)
  let size = getSize(src)
  let iOrig = start
  let lenOrig = length
  let start = coerceNumberToWasmI32(start)
  let length = coerceNumberToWasmI32(length)
  if (start + length > size) {
    throw Exception.InvalidArgument(
      "The given index and length do not specify a valid range of bytes"
    )
  }
  let dst = allocateBytes(length)
  let offset = start
  Memory.copy(dst + _VALUE_OFFSET, src + _VALUE_OFFSET + start, length)
  WasmI32.toGrain(dst): Bytes
}

/**
 * Returns a copy of a byte sequence with bytes added or removed from the beginning and/or end.
 *
 * A positive number represents bytes to add, while a negative number represents bytes to remove.
 *
 * @param left: The number of uninitialized bytes to prepend
 * @param right: The number of uninitialized bytes to append
 * @param bytes: The byte sequence get a subset of bytes from
 * @returns A resized byte sequence
 *
 * @throws InvalidArgument(String): When the new size is negative
 *
 * @since v0.3.2
 */
@unsafe
provide let resize = (left: Number, right: Number, bytes: Bytes) => {
  from WasmI32 use { (+), (-), (*), (<), (>) }
  let src = WasmI32.fromGrain(bytes)
  let size = getSize(src)
  let leftOrig = left
  let rightOrig = right
  let left = coerceNumberToWasmI32(left)
  let right = coerceNumberToWasmI32(right)
  let newSize = size + left + right
  if (newSize < 0n) {
    throw Exception.InvalidArgument("The resulting length is less than 0")
  }
  let dst = allocateBytes(newSize)
  let mut srcOffset = 0n
  let mut dstOffset = 0n
  if (left < 0n) {
    srcOffset = left * -1n
    dstOffset = 0n
  }
  if (left > 0n) {
    srcOffset = 0n
    dstOffset = left
  }
  let len = if (right < 0n) {
    size + right - srcOffset
  } else {
    size - srcOffset
  }
  if (len > 0n) {
    Memory.copy(
      dst + _VALUE_OFFSET + dstOffset,
      src + _VALUE_OFFSET + srcOffset,
      len
    )
  }
  WasmI32.toGrain(dst): Bytes
}

/**
 * Copies a range of bytes from a source byte sequence to a given location
 * in a destination byte sequence.
 *
 * @param srcIndex: The starting index to copy bytes from
 * @param dstIndex: The starting index to copy bytes into
 * @param length: The amount of bytes to copy from the source byte sequence
 * @param src: The source byte sequence
 * @param dst: The destination byte sequence
 *
 * @throws InvalidArgument(String): When `srcIndex + length` is greater than the `src` bytes size
 * @throws InvalidArgument(String): When the `dstIndex + length` is greater than the `dst` bytes size
 *
 * @since v0.3.2
 */
@unsafe
provide let move =
  (
    srcIndex: Number,
    dstIndex: Number,
    length: Number,
    src: Bytes,
    dst: Bytes,
  ) => {
  from WasmI32 use { (+), (>) }
  let srcIndexOrig = srcIndex
  let dstIndexOrig = dstIndex
  let lenthOrig = length
  let src = WasmI32.fromGrain(src)
  let srcSize = getSize(src)
  let srcIndex = coerceNumberToWasmI32(srcIndex)
  let dst = WasmI32.fromGrain(dst)
  let dstSize = getSize(dst)
  let dstIndex = coerceNumberToWasmI32(dstIndex)
  let length = coerceNumberToWasmI32(length)
  if (srcIndex + length > srcSize) {
    throw Exception.InvalidArgument("Invalid source bytes range")
  }
  if (dstIndex + length > dstSize) {
    throw Exception.InvalidArgument("Invalid destination bytes range")
  }
  let end = srcIndex + length
  Memory.copy(
    dst + _VALUE_OFFSET + dstIndex,
    src + _VALUE_OFFSET + srcIndex,
    length
  )
}

/**
 * Creates a new byte sequence that contains the bytes of both byte sequences.
 *
 * @param bytes1: The beginning byte sequence
 * @param bytes2: The ending byte sequence
 * @returns The new byte sequence
 *
 * @since v0.3.2
 */
provide let concat = (bytes1: Bytes, bytes2: Bytes) => {
  let len1 = length(bytes1)
  let len2 = length(bytes2)
  let ret = resize(0, len2, bytes1)
  move(0, len1, len2, bytes2, ret)
  ret
}

/**
 * Replaces all bytes in a byte sequnce with the new value provided.
 *
 * @param value: The value replacing each byte
 * @param bytes: The byte sequence to update
 *
 * @since v0.3.2
 * @history v0.6.0: `value` argument type changed to `Uint8`
 */
@unsafe
provide let fill = (value: Uint8, bytes: Bytes) => {
  from WasmI32 use { (+) }
  let src = WasmI32.fromGrain(bytes)
  let size = getSize(src)
  let v = untagUint8(value)
  Memory.fill(src + _VALUE_OFFSET, v, size)
}

/**
 * Replaces all bytes in a byte sequence with zeroes.
 *
 * @param bytes: The byte sequence to clear
 *
 * @since v0.5.0
 */
@unsafe
provide let clear = (bytes: Bytes) => {
  from WasmI32 use { (+) }
  let src = WasmI32.fromGrain(bytes)
  let size = getSize(src)
  Memory.fill(src + _VALUE_OFFSET, 0n, size)
}

/**
 * Gets a signed 8-bit integer starting at the given byte index.
 *
 * @param index: The byte index to access
 * @param bytes: The byte sequence to access
 * @returns A signed 8-bit integer that starts at the given index
 *
 * @throws IndexOutOfBounds: When `index` is negative
 * @throws IndexOutOfBounds: When `index + 1` is greater than the bytes size
 *
 * @since v0.6.0
 * @history v0.3.2: Originally called `getInt8S`, returning an `Int32`
 */
@unsafe
provide let getInt8 = (index: Number, bytes: Bytes) => {
  from WasmI32 use { (+) }
  let ptr = WasmI32.fromGrain(bytes)
  let size = getSize(ptr)
  let offset = coerceNumberToWasmI32(index)
  checkIndexIsInBounds(offset, _INT8_BYTE_SIZE, size)
  let n = WasmI32.load8S(ptr + offset, _VALUE_OFFSET)
  tagInt8(n)
}

/**
 * Sets a signed 8-bit integer starting at the given byte index.
 *
 * @param index: The byte index to update
 * @param value: The value to set
 * @param bytes: The byte sequence to mutate
 *
 * @throws IndexOutOfBounds: When `index` is negative
 * @throws IndexOutOfBounds: When `index + 1` is greater than the bytes size
 *
 * @since v0.3.2
 * @history v0.6.0: `value` argument type changed to `Int8`
 */
@unsafe
provide let setInt8 = (index: Number, value: Int8, bytes: Bytes) => {
  from WasmI32 use { (+) }
  let ptr = WasmI32.fromGrain(bytes)
  let size = getSize(ptr)
  let offset = coerceNumberToWasmI32(index)
  checkIndexIsInBounds(offset, _INT8_BYTE_SIZE, size)
  let v = untagInt8(value)
  WasmI32.store8(ptr + offset, v, _VALUE_OFFSET)
}

/**
 * Gets an unsigned 8-bit integer starting at the given byte index.
 *
 * @param index: The byte index to access
 * @param bytes: The byte sequence to access
 * @returns An unsigned 8-bit integer that starts at the given index
 *
 * @throws IndexOutOfBounds: When `index` is negative
 * @throws IndexOutOfBounds: When `index + 1` is greater than the bytes size
 *
 * @since v0.6.0
 * @history v0.3.2: Originally called `getInt8U`, returning an `Int32`
 */
@unsafe
provide let getUint8 = (index: Number, bytes: Bytes) => {
  from WasmI32 use { (+) }
  let ptr = WasmI32.fromGrain(bytes)
  let size = getSize(ptr)
  let offset = coerceNumberToWasmI32(index)
  checkIndexIsInBounds(offset, _INT8_BYTE_SIZE, size)
  let n = WasmI32.load8U(ptr + offset, _VALUE_OFFSET)
  tagUint8(n)
}

/**
 * Sets an unsigned 8-bit integer starting at the given byte index.
 *
 * @param index: The byte index to update
 * @param value: The value to set
 * @param bytes: The byte sequence to mutate
 *
 * @throws IndexOutOfBounds: When `index` is negative
 * @throws IndexOutOfBounds: When `index + 1` is greater than the bytes size
 *
 * @since v0.6.0
 */
@unsafe
provide let setUint8 = (index: Number, value: Uint8, bytes: Bytes) => {
  from WasmI32 use { (+) }
  let ptr = WasmI32.fromGrain(bytes)
  let size = getSize(ptr)
  let offset = coerceNumberToWasmI32(index)
  checkIndexIsInBounds(offset, _INT8_BYTE_SIZE, size)
  let v = untagUint8(value)
  WasmI32.store8(ptr + offset, v, _VALUE_OFFSET)
}

/**
 * Gets a signed 16-bit integer starting at the given byte index.
 *
 * @param index: The byte index to access
 * @param bytes: The byte sequence to access
 * @returns A signed 16-bit integer that starts at the given index
 *
 * @throws IndexOutOfBounds: When `index` is negative
 * @throws IndexOutOfBounds: When `index + 2` is greater than the bytes size
 *
 * @since v0.6.0
 * @history v0.3.2: Originally called `getInt16S`, returning an `Int32`
 */
@unsafe
provide let getInt16 = (index: Number, bytes: Bytes) => {
  from WasmI32 use { (+) }
  let ptr = WasmI32.fromGrain(bytes)
  let size = getSize(ptr)
  let offset = coerceNumberToWasmI32(index)
  checkIndexIsInBounds(offset, _INT16_BYTE_SIZE, size)
  let n = WasmI32.load16S(ptr + offset, _VALUE_OFFSET)
  tagInt16(n)
}

/**
 * Sets a signed 16-bit integer starting at the given byte index.
 *
 * @param index: The byte index to update
 * @param value: The value to set
 * @param bytes: The byte sequence to mutate
 *
 * @throws IndexOutOfBounds: When `index` is negative
 * @throws IndexOutOfBounds: When `index + 2` is greater than the bytes size
 *
 * @since v0.3.2
 * @history v0.6.0: `value` argument type changed to `Int16`
 */
@unsafe
provide let setInt16 = (index: Number, value: Int16, bytes: Bytes) => {
  from WasmI32 use { (+) }
  let ptr = WasmI32.fromGrain(bytes)
  let size = getSize(ptr)
  let offset = coerceNumberToWasmI32(index)
  checkIndexIsInBounds(offset, _INT16_BYTE_SIZE, size)
  let v = untagInt16(value)
  WasmI32.store16(ptr + offset, v, _VALUE_OFFSET)
}

/**
 * Gets an unsigned 16-bit integer starting at the given byte index.
 *
 * @param index: The byte index to access
 * @param bytes: The byte sequence to access
 * @returns An unsigned 16-bit integer that starts at the given index
 *
 * @throws IndexOutOfBounds: When `index` is negative
 * @throws IndexOutOfBounds: When `index + 2` is greater than the bytes size
 *
 * @since v0.6.0
 * @history v0.3.2: Originally called `getInt16U`, returning an `Int32`
 */
@unsafe
provide let getUint16 = (index: Number, bytes: Bytes) => {
  from WasmI32 use { (+) }
  let ptr = WasmI32.fromGrain(bytes)
  let size = getSize(ptr)
  let offset = coerceNumberToWasmI32(index)
  checkIndexIsInBounds(offset, _INT16_BYTE_SIZE, size)
  let n = WasmI32.load16U(ptr + offset, _VALUE_OFFSET)
  tagUint16(n)
}

/**
 * Sets an unsigned 16-bit integer starting at the given byte index.
 *
 * @param index: The byte index to update
 * @param value: The value to set
 * @param bytes: The byte sequence to mutate
 *
 * @throws IndexOutOfBounds: When `index` is negative
 * @throws IndexOutOfBounds: When `index + 2` is greater than the bytes size
 *
 * @since v0.6.0
 */
@unsafe
provide let setUint16 = (index: Number, value: Uint16, bytes: Bytes) => {
  from WasmI32 use { (+) }
  let ptr = WasmI32.fromGrain(bytes)
  let size = getSize(ptr)
  let offset = coerceNumberToWasmI32(index)
  checkIndexIsInBounds(offset, _INT16_BYTE_SIZE, size)
  let v = untagUint16(value)
  WasmI32.store16(ptr + offset, v, _VALUE_OFFSET)
}

/**
 * Gets a signed 32-bit integer starting at the given byte index.
 *
 * @param index: The byte index to access
 * @param bytes: The byte sequence to access
 * @returns A signed 32-bit integer that starts at the given index
 *
 * @throws IndexOutOfBounds: When `index` is negative
 * @throws IndexOutOfBounds: When `index + 4` is greater than the bytes size
 *
 * @since v0.3.2
 */
@unsafe
provide let getInt32 = (index: Number, bytes: Bytes) => {
  from WasmI32 use { (+) }
  let ptr = WasmI32.fromGrain(bytes)
  let size = getSize(ptr)
  let offset = coerceNumberToWasmI32(index)
  checkIndexIsInBounds(offset, _INT32_BYTE_SIZE, size)
  let n = WasmI32.load(ptr + offset, _VALUE_OFFSET)
  Conv.toInt32(n)
}

/**
 * Sets a signed 32-bit integer starting at the given byte index.
 *
 * @param index: The byte index to update
 * @param value: The value to set
 * @param bytes: The byte sequence to mutate
 *
 * @throws IndexOutOfBounds: When `index` is negative
 * @throws IndexOutOfBounds: When `index + 4` is greater than the bytes size
 *
 * @since v0.3.2
 */
@unsafe
provide let setInt32 = (index: Number, value: Int32, bytes: Bytes) => {
  from WasmI32 use { (+) }
  let ptr = WasmI32.fromGrain(bytes)
  let size = getSize(ptr)
  let offset = coerceNumberToWasmI32(index)
  checkIndexIsInBounds(offset, _INT32_BYTE_SIZE, size)
  let v = Conv.fromInt32(value)
  WasmI32.store(ptr + offset, v, _VALUE_OFFSET)
}

/**
 * Gets an unsigned 32-bit integer starting at the given byte index.
 *
 * @param index: The byte index to access
 * @param bytes: The byte sequence to access
 * @returns An unsigned 32-bit integer that starts at the given index
 *
 * @throws IndexOutOfBounds: When `index` is negative
 * @throws IndexOutOfBounds: When `index + 4` is greater than the bytes size
 *
 * @since v0.6.0
 */
@unsafe
provide let getUint32 = (index: Number, bytes: Bytes) => {
  from WasmI32 use { (+) }
  let ptr = WasmI32.fromGrain(bytes)
  let size = getSize(ptr)
  let offset = coerceNumberToWasmI32(index)
  checkIndexIsInBounds(offset, _INT32_BYTE_SIZE, size)
  let n = WasmI32.load(ptr + offset, _VALUE_OFFSET)
  Conv.toUint32(n)
}

/**
 * Sets an unsigned 32-bit integer starting at the given byte index.
 *
 * @param index: The byte index to update
 * @param value: The value to set
 * @param bytes: The byte sequence to mutate
 *
 * @throws IndexOutOfBounds: When `index` is negative
 * @throws IndexOutOfBounds: When `index + 4` is greater than the bytes size
 *
 * @since v0.6.0
 */
@unsafe
provide let setUint32 = (index: Number, value: Uint32, bytes: Bytes) => {
  from WasmI32 use { (+) }
  let ptr = WasmI32.fromGrain(bytes)
  let size = getSize(ptr)
  let offset = coerceNumberToWasmI32(index)
  checkIndexIsInBounds(offset, _INT32_BYTE_SIZE, size)
  let v = Conv.fromUint32(value)
  WasmI32.store(ptr + offset, v, _VALUE_OFFSET)
}

/**
 * Gets a 32-bit float starting at the given byte index.
 *
 * @param index: The byte index to access
 * @param bytes: The byte sequence to access
 * @returns A 32-bit float that starts at the given index
 *
 * @throws IndexOutOfBounds: When `index` is negative
 * @throws IndexOutOfBounds: When `index + 4` is greater than the bytes size
 *
 * @since v0.3.2
 */
@unsafe
provide let getFloat32 = (index: Number, bytes: Bytes) => {
  from WasmI32 use { (+) }
  let ptr = WasmI32.fromGrain(bytes)
  let size = getSize(ptr)
  let offset = coerceNumberToWasmI32(index)
  checkIndexIsInBounds(offset, _INT32_BYTE_SIZE, size)
  let n = WasmF32.load(ptr + offset, _VALUE_OFFSET)
  Conv.toFloat32(n)
}

/**
 * Sets a 32-bit float starting at the given byte index.
 *
 * @param index: The byte index to update
 * @param value: The value to set
 * @param bytes: The byte sequence to mutate
 *
 * @throws IndexOutOfBounds: When `index` is negative
 * @throws IndexOutOfBounds: When `index + 4` is greater than the bytes size
 *
 * @since v0.3.2
 */
@unsafe
provide let setFloat32 = (index: Number, value: Float32, bytes: Bytes) => {
  from WasmI32 use { (+) }
  let ptr = WasmI32.fromGrain(bytes)
  let size = getSize(ptr)
  let offset = coerceNumberToWasmI32(index)
  checkIndexIsInBounds(offset, _INT32_BYTE_SIZE, size)
  let v = Conv.fromFloat32(value)
  WasmF32.store(ptr + offset, v, _VALUE_OFFSET)
}

/**
 * Gets a signed 64-bit integer starting at the given byte index.
 *
 * @param index: The byte index to access
 * @param bytes: The byte sequence to access
 * @returns A signed 64-bit integer that starts at the given index
 *
 * @throws IndexOutOfBounds: When `index` is negative
 * @throws IndexOutOfBounds: When `index + 8` is greater than the bytes size
 *
 * @since v0.3.2
 */
@unsafe
provide let getInt64 = (index: Number, bytes: Bytes) => {
  from WasmI32 use { (+) }
  let ptr = WasmI32.fromGrain(bytes)
  let size = getSize(ptr)
  let offset = coerceNumberToWasmI32(index)
  checkIndexIsInBounds(offset, _INT64_BYTE_SIZE, size)
  let n = WasmI64.load(ptr + offset, _VALUE_OFFSET)
  Conv.toInt64(n)
}

/**
 * Sets a signed 64-bit integer starting at the given byte index.
 *
 * @param index: The byte index to update
 * @param value: The value to set
 * @param bytes: The byte sequence to mutate
 *
 * @throws IndexOutOfBounds: When `index` is negative
 * @throws IndexOutOfBounds: When `index + 8` is greater than the bytes size
 *
 * @since v0.3.2
 */
@unsafe
provide let setInt64 = (index: Number, value: Int64, bytes: Bytes) => {
  from WasmI32 use { (+) }
  let ptr = WasmI32.fromGrain(bytes)
  let size = getSize(ptr)
  let offset = coerceNumberToWasmI32(index)
  checkIndexIsInBounds(offset, _INT64_BYTE_SIZE, size)
  let v = Conv.fromInt64(value)
  WasmI64.store(ptr + offset, v, _VALUE_OFFSET)
}

/**
 * Gets an unsigned 64-bit integer starting at the given byte index.
 *
 * @param index: The byte index to access
 * @param bytes: The byte sequence to access
 * @returns An unsigned 64-bit integer that starts at the given index
 *
 * @throws IndexOutOfBounds: When `index` is negative
 * @throws IndexOutOfBounds: When `index + 8` is greater than the bytes size
 *
 * @since v0.6.0
 */
@unsafe
provide let getUint64 = (index: Number, bytes: Bytes) => {
  from WasmI32 use { (+) }
  let ptr = WasmI32.fromGrain(bytes)
  let size = getSize(ptr)
  let offset = coerceNumberToWasmI32(index)
  checkIndexIsInBounds(offset, _INT64_BYTE_SIZE, size)
  let n = WasmI64.load(ptr + offset, _VALUE_OFFSET)
  Conv.toUint64(n)
}

/**
 * Sets an unsigned 64-bit integer starting at the given byte index.
 *
 * @param index: The byte index to update
 * @param value: The value to set
 * @param bytes: The byte sequence to mutate
 *
 * @throws IndexOutOfBounds: When `index` is negative
 * @throws IndexOutOfBounds: When `index + 8` is greater than the bytes size
 *
 * @since v0.6.0
 */
@unsafe
provide let setUint64 = (index: Number, value: Uint64, bytes: Bytes) => {
  from WasmI32 use { (+) }
  let ptr = WasmI32.fromGrain(bytes)
  let size = getSize(ptr)
  let offset = coerceNumberToWasmI32(index)
  checkIndexIsInBounds(offset, _INT64_BYTE_SIZE, size)
  let v = Conv.fromUint64(value)
  WasmI64.store(ptr + offset, v, _VALUE_OFFSET)
}

/**
 * Gets a 64-bit float starting at the given byte index.
 *
 * @param index: The byte index to access
 * @param bytes: The byte sequence to access
 * @returns A 64-bit float that starts at the given index
 *
 * @throws IndexOutOfBounds: When `index` is negative
 * @throws IndexOutOfBounds: When `index + 8` is greater than the bytes size
 *
 * @since v0.3.2
 */
@unsafe
provide let getFloat64 = (index: Number, bytes: Bytes) => {
  from WasmI32 use { (+) }
  let ptr = WasmI32.fromGrain(bytes)
  let size = getSize(ptr)
  let offset = coerceNumberToWasmI32(index)
  checkIndexIsInBounds(offset, _FLOAT64_BYTE_SIZE, size)
  let n = WasmF64.load(ptr + offset, _VALUE_OFFSET)
  Conv.toFloat64(n)
}

/**
 * Sets a 64-bit float starting at the given byte index.
 *
 * @param index: The byte index to update
 * @param value: The value to set
 * @param bytes: The byte sequence to mutate
 *
 * @throws IndexOutOfBounds: When `index` is negative
 * @throws IndexOutOfBounds: When `index + 8` is greater than the bytes size
 *
 * @since v0.3.2
 */
@unsafe
provide let setFloat64 = (index: Number, value: Float64, bytes: Bytes) => {
  from WasmI32 use { (+) }
  let ptr = WasmI32.fromGrain(bytes)
  let size = getSize(ptr)
  let offset = coerceNumberToWasmI32(index)
  checkIndexIsInBounds(offset, _FLOAT64_BYTE_SIZE, size)
  let v = Conv.fromFloat64(value)
  WasmF64.store(ptr + offset, v, _VALUE_OFFSET)
}
