import Memory from "runtime/unsafe/memory"
import WasmI32 from "runtime/unsafe/wasmi32"
import WasmI64 from "runtime/unsafe/wasmi64"
import WasmF32 from "runtime/unsafe/wasmf32"
import WasmF64 from "runtime/unsafe/wasmf64"
import Conv from "runtime/unsafe/conv"
import { tagSimpleNumber, allocateBytes } from "runtime/dataStructures"
import Exception from "runtime/exception"
import Int32 from "int32"

/** Converts Number to WasmI32 */
@disableGC
let numberToWasmI32 = n => {
  Conv.fromInt32(Int32.fromNumber(n))
}

/** Throws an exception if the index specified is out-of-bounds */
@disableGC
let ensureIndexIsInBounds = (i, byteSize, max) => {
  let (+) = WasmI32.add
  let (<) = WasmI32.ltS
  let (>) = WasmI32.gtS
  if (i < 0n) {
    throw Exception.IndexOutOfBounds
  }
  if ((i + byteSize) > max) {
    throw Exception.IndexOutOfBounds
  }
}

/** Gets the Bytes pointer and size */
@disableGC
let getPointerAndSize = (bytes) => {
  let ptr = WasmI32.fromGrain(bytes)
  let size = WasmI32.load(ptr, 4n)
  (ptr, size)
}

/** Gets the Bytes pointer and byte offset */
@disableGC
let getPointerAndOffset = (bytes, byteSize, i) => {
  let (+) = WasmI32.add
  let (*) = WasmI32.mul
  let pointerAndSize = getPointerAndSize(bytes)
  let (ptr, size) = pointerAndSize
  Memory.free(WasmI32.fromGrain(pointerAndSize))
  let i = numberToWasmI32(i)
  ensureIndexIsInBounds(i, byteSize, size)
  let offset = 8n + i
  (ptr, offset)
}

/**
 * Sets a signed 8-bit integer starting at the given byte index.
 * @param b: Bytes - The Bytes buffer
 * @param i: Number - The byte index
 * @param v: Int32 - The value to set
 * @returns Void
 */
@disableGC
export let setInt8 = (b: Bytes, i: Number, v: Int32) => {
  let byteSize = 1n
  let pointerAndOffset = getPointerAndOffset(b, byteSize, i)
  let (ptr, offset) = pointerAndOffset
  Memory.free(WasmI32.fromGrain(pointerAndOffset))
  let value = Conv.fromInt32(v)
  WasmI32.store8(ptr, value, offset)
}

/**
 * Gets a signed 8-bit integer starting at the given byte index.
 * @param b: Bytes - The Bytes buffer
 * @param i: Number - The byte index
 * @returns Int32
 */
@disableGC
export let getInt8S = (b: Bytes, i: Number) => {
  let byteSize = 1n
  let pointerAndOffset = getPointerAndOffset(b, byteSize, i)
  let (ptr, offset) = pointerAndOffset
  Memory.free(WasmI32.fromGrain(pointerAndOffset))
  let n = WasmI32.load8S(ptr, offset)
  Conv.toInt32(n)
}

/**
 * Gets an unsigned 8-bit integer starting at the given byte index.
 * @param b: Bytes - The Bytes buffer
 * @param i: Number - The byte index
 * @returns Int32
 */
@disableGC
export let getInt8U = (b: Bytes, i: Number) => {
  let byteSize = 1n
  let pointerAndOffset = getPointerAndOffset(b, byteSize, i)
  let (ptr, offset) = pointerAndOffset
  Memory.free(WasmI32.fromGrain(pointerAndOffset))
  let n = WasmI32.load8U(ptr, offset)
  Conv.toInt32(n)
}

/**
 * Sets a signed 16-bit integer starting at the given byte index.
 * @param b: Bytes - The Bytes buffer
 * @param i: Number - The byte index
 * @param v: Int32 - The value to set
 * @returns Void
 */
@disableGC
export let setInt16 = (b: Bytes, i: Number, v: Int32) => {
  let byteSize = 2n
  let pointerAndOffset = getPointerAndOffset(b, byteSize, i)
  let (ptr, offset) = pointerAndOffset
  Memory.free(WasmI32.fromGrain(pointerAndOffset))
  let value = Conv.fromInt32(v)
  WasmI32.store16(ptr, value, offset)
}

/**
 * Gets a signed 16-bit integer starting at the given byte index.
 * @param b: Bytes - The Bytes buffer
 * @param i: Number - The byte index
 * @returns Int32
 */
@disableGC
export let getInt16S = (b: Bytes, i: Number) => {
  let byteSize = 2n
  let pointerAndOffset = getPointerAndOffset(b, byteSize, i)
  let (ptr, offset) = pointerAndOffset
  Memory.free(WasmI32.fromGrain(pointerAndOffset))
  let n = WasmI32.load16S(ptr, offset)
  Conv.toInt32(n)
}

/**
 * Gets an unsigned 16-bit integer starting at the given byte index.
 * @param b: Bytes - The Bytes buffer
 * @param i: Number - The byte index
 * @returns Int32
 */
@disableGC
export let getInt16U = (b: Bytes, i: Number) => {
  let byteSize = 2n
  let pointerAndOffset = getPointerAndOffset(b, byteSize, i)
  let (ptr, offset) = pointerAndOffset
  Memory.free(WasmI32.fromGrain(pointerAndOffset))
  let n = WasmI32.load16U(ptr, offset)
  Conv.toInt32(n)

}

/**
 * Sets a signed 32-bit integer starting at the given byte index.
 * @param b: Bytes - The Bytes buffer
 * @param i: Number - The byte index
 * @param v: Int32 - The value to set
 * @returns Void
 */
@disableGC
export let setInt32 = (b: Bytes, i: Number, v: Int32) => {
  let byteSize = 4n
  let pointerAndOffset = getPointerAndOffset(b, byteSize, i)
  let (ptr, offset) = pointerAndOffset
  Memory.free(WasmI32.fromGrain(pointerAndOffset))
  let value = Conv.fromInt32(v)
  WasmI32.store(ptr, value, offset)
}

/**
 * Gets a signed 32-bit integer starting at the given byte index.
 * @param b: Bytes - The Bytes buffer
 * @param i: Number - The byte index
 * @returns Int32
 */
@disableGC
export let getInt32 = (b: Bytes, i: Number) => {
  let byteSize = 4n
  let pointerAndOffset = getPointerAndOffset(b, byteSize, i)
  let (ptr, offset) = pointerAndOffset
  Memory.free(WasmI32.fromGrain(pointerAndOffset))
  let n = WasmI32.load(ptr, offset)
  Conv.toInt32(n)
}

/**
 * Sets a 32-bit float starting at the given byte index.
 * @param b: Bytes - The Bytes buffer
 * @param i: Number - The byte index
 * @param v: Float32 - The value to set
 * @returns Void
 */
@disableGC
export let setFloat32 = (b: Bytes, i: Number, v: Float32) => {
  let byteSize = 4n
  let pointerAndOffset = getPointerAndOffset(b, byteSize, i)
  let (ptr, offset) = pointerAndOffset
  Memory.free(WasmI32.fromGrain(pointerAndOffset))
  let value = Conv.fromFloat32(v)
  WasmF32.store(ptr, value, offset)
}

/**
 * Gets a 32-bit float starting at the given byte index.
 * @param b: Bytes - The Bytes buffer
 * @param i: Number - The byte index
 * @returns Float32
 */
@disableGC
export let getFloat32 = (b: Bytes, i: Number) => {
  let byteSize = 4n
  let pointerAndOffset = getPointerAndOffset(b, byteSize, i)
  let (ptr, offset) = pointerAndOffset
  Memory.free(WasmI32.fromGrain(pointerAndOffset))
  let n = WasmF32.load(ptr, offset)
  Conv.toFloat32(n)
}

/**
 * Sets a signed 64-bit integer starting at the given byte index.
 * @param b: Bytes - The Bytes buffer
 * @param i: Number - The byte index
 * @param v: Int64 - The value to set
 * @returns Void
 */
@disableGC
export let setInt64 = (b: Bytes, i: Number, v: Int64) => {
  let byteSize = 8n
  let pointerAndOffset = getPointerAndOffset(b, byteSize, i)
  let (ptr, offset) = pointerAndOffset
  Memory.free(WasmI32.fromGrain(pointerAndOffset))
  let value = Conv.fromInt64(v)
  WasmI64.store(ptr, value, offset)
}

/**
 * Gets a signed 64-bit integer starting at the given byte index.
 * @param b: Bytes - The Bytes buffer
 * @param i: Number - The byte index
 * @returns Int64
 */
@disableGC
export let getInt64 = (b: Bytes, i: Number) => {
  let byteSize = 8n
  let pointerAndOffset = getPointerAndOffset(b, byteSize, i)
  let (ptr, offset) = pointerAndOffset
  Memory.free(WasmI32.fromGrain(pointerAndOffset))
  let n = WasmI64.load(ptr, offset)
  Conv.toInt64(n)
}

/**
 * Sets a 64-bit float starting at the given byte index.
 * @param b: Bytes - The Bytes buffer
 * @param i: Number - The byte index
 * @param v: Float64 - The value to set
 * @returns Void
 */
@disableGC
export let setFloat64 = (b: Bytes, i: Number, v: Float64) => {
  let byteSize = 8n
  let pointerAndOffset = getPointerAndOffset(b, byteSize, i)
  let (ptr, offset) = pointerAndOffset
  Memory.free(WasmI32.fromGrain(pointerAndOffset))
  let value = Conv.fromFloat64(v)
  WasmF64.store(ptr, value, offset)
}

/**
 * Gets a 64-bit float starting at the given byte index.
 * @param b: Bytes - The Bytes buffer
 * @param i: Number - The byte index
 * @returns Float64
 */
@disableGC
export let getFloat64 = (b: Bytes, i: Number) => {
  let byteSize = 8n
  let pointerAndOffset = getPointerAndOffset(b, byteSize, i)
  let (ptr, offset) = pointerAndOffset
  Memory.free(WasmI32.fromGrain(pointerAndOffset))
  let n = WasmF64.load(ptr, offset)
  Conv.toFloat64(n)
}

/**
 * Return a new Bytes buffer that contains the same bytes as the argument.
 * @param b: Bytes - The Bytes buffer to copy
 * @returns Bytes
 */
@disableGC
export let copy = (b: Bytes) => {
  let (<) = WasmI32.ltS
  let (+) = WasmI32.add
  let pointerAndSize = getPointerAndSize(b)
  let (src, size) = pointerAndSize
  Memory.free(WasmI32.fromGrain(pointerAndSize))
  let dst = allocateBytes(size)
  Memory.copy(dst + 8n, src + 8n, size)
  WasmI32.toGrain(dst): Bytes
}

/**
 * Returns a new Bytes buffer containing a subset of the original Bytes buffer.
 * @param b: Bytes - The Bytes buffer get a subset of bytes from
 * @param i: Number - The start position to copy from
 * @param len: Number - The number of bytes to copy
 * @returns Bytes
 */
@disableGC
export let sub = (b: Bytes, i: Number, len: Number) => {
  let (>) = WasmI32.gtS
  let (+) = WasmI32.add
  let pointerAndSize = getPointerAndSize(b)
  let (src, size) = pointerAndSize
  Memory.free(WasmI32.fromGrain(pointerAndSize))
  let i = numberToWasmI32(i)
  let len = numberToWasmI32(len)
  if ((i + len) > size) {
    throw Exception.InvalidArgument("The given index and length do not specify a valid range of bytes")
  }
  let dst = allocateBytes(len)
  let offset = i
  Memory.copy(dst + 8n, src + 8n + i, len)
  WasmI32.toGrain(dst): Bytes
}


/**
 * Returns a new Bytes buffer with unintialized bytes prepended/appended to it.
 * If the `left` or `right` parameters are negative, bytes will be removed from the corresponding side instead of appended.
 * @param b: Bytes - The Bytes buffer get a subset of bytes from
 * @param left: Number - The number of uninitialized bytes to prepend
 * @param right: Number - The number of uninitialized bytes to append
 * @returns Bytes
 */
@disableGC
export let extend = (b: Bytes, left: Number, right: Number) => {
  let (<) = WasmI32.ltS
  let (>) = WasmI32.gtS
  let (+) = WasmI32.add
  let (-) = WasmI32.sub
  let (*) = WasmI32.mul
  let pointerAndSize = getPointerAndSize(b)
  let (src, size) = pointerAndSize
  Memory.free(WasmI32.fromGrain(pointerAndSize))
  let left = numberToWasmI32(left)
  let right = numberToWasmI32(right)
  let newLen = size + left + right
  if (newLen < 0n) {
    throw Exception.InvalidArgument("The resulting length is less than 0")
  }
  let dst = allocateBytes(newLen)
  let mut offset = left;
  let mut start = 0n;
  if (left < 0n) {
    start = left * -1n;
    offset = 0n;
  }
  let len = if (right < 0n) {
    (size + right) - start
  } else {
    size - start
  }
  if (len > 0n) {
    Memory.copy(dst + 8n + offset, src + 8n + start, len)
  }
  WasmI32.toGrain(dst): Bytes
}


/**
 * Copies a range of bytes bytes from a source buffer to a given location in a destination buffer.
 * @param src: Bytes - The source buffer
 * @param srcPos: Number - The starting byte index to copy bytes from
 * @param dst: Bytes - The destination buffer
 * @param dstPos: Number - The starting byte index to copy bytes into
 * @param len: Number - The amount of bytes to copy from the source buffer
 * @returns Void
 */
@disableGC
export let blit = (src: Bytes, srcPos: Number, dst: Bytes, dstPos: Number, len: Number) => {
  let (>) = WasmI32.gtS
  let (+) = WasmI32.add
  let srcPointerAndSize = getPointerAndSize(src)
  let (src, srcSize) = srcPointerAndSize
  Memory.free(WasmI32.fromGrain(srcPointerAndSize))
  let dstPointerAndSize = getPointerAndSize(dst)
  let (dst, dstSize) = dstPointerAndSize
  Memory.free(WasmI32.fromGrain(dstPointerAndSize))
  let srcPos = numberToWasmI32(srcPos)
  let dstPos = numberToWasmI32(dstPos)
  let len = numberToWasmI32(len)
  if ((srcPos + len) > srcSize) {
    throw Exception.InvalidArgument("Invalid source bytes range")
  }
  if ((dstPos + len) > dstSize) {
    throw Exception.InvalidArgument("Invalid destination bytes range")
  }
  let end = srcPos + len
  Memory.copy(dst + 8n + dstPos, src + 8n + srcPos, len)
}

/**
 * Get the byte length of a Bytes buffer.
 * @param input: Bytes - The Bytes buffer to check
 * @returns Number
 */
 @disableGC
export let length = (s: Bytes) => {
  let s = WasmI32.fromGrain(s)
  tagSimpleNumber(WasmI32.load(s, 4n))
}

/**
 * Creates a new Bytes buffer that contains the bytes of both buffers a and b.
 * @param a: Bytes - The buffer to be copied first
 * @param b: Bytes - The buffer to be appended
 * @returns Bytes
 */
export let append = (a: Bytes, b: Bytes) => {
  let alen = length(a)
  let blen = length(b)
  let c = extend(a, 0, blen)
  blit(b, 0, c, alen, blen)
  c
}

/**
 * Make a new Bytes buffer of n-bytes size.
 * @param n: Number - The number of bytes to store
 * @returns Bytes
 */
@disableGC
export let make = (n: Number) => {
  let bytes = allocateBytes(numberToWasmI32(n))
  WasmI32.toGrain(bytes): Bytes
}

/**
 * An empty Bytes buffer
 */
export let empty = make(0)

