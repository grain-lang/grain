import Memory from "runtime/unsafe/memory"
import Tags from "runtime/unsafe/tags"
import WasmI32 from "runtime/unsafe/wasmi32"
import Exception from "runtime/exception"
import { coerceNumberToWasmI32 } from "runtime/numbers"
import Conv from "runtime/unsafe/conv"

// Layout:
// -------------------------
// | tag | size | limbs... |
// -------------------------
//
// tag   | i32    | always _GRAIN_BIGINT_BOXED_NUM_TAG
// size  | i32    | the number of limbs. If negative, the bigint is negative
// limbs | i64... |

// TODO: use faster abs algos
// https://stackoverflow.com/questions/664852/which-is-the-fastest-way-to-get-the-absolute-value-of-a-number

@disableGC
let absi32 = (n) => {
  let (<) = WasmI32.lt
  if (n < 0n) { -n } else { n }
}

@disableGC
let absi64 = (n) => {
  let (<) = WasmI64.lt
  if (n < 0N) { -n } else { n }
}

@disableGC
let init = (limbs: WasmI32) => {
  let (+) = WasmI32.add
  let (*) = WasmI32.mul
  let (<) = WasmI32.lt

  if (limbs == 0n) {
    throw Exception.InvalidArgument("BigInt must have at least 1 limb")
  }

  let tagLen = 4n
  let sizeLen = 4n
  let limbsLen = absi32(limbs) * 8n
  let len = tagSize + sizeSize + limbsSize

  let ptr = Memory.malloc(len)
  Memory.fill(ptr, 0n, len)

  WasmI32.store(ptr, Tags._GRAIN_BIGINT_BOXED_NUM_TAG, 0n)
  WasmI32.store(ptr, limbs, 4n)

  ptr
}

@disableGC
let getSize = (ptr) => {
  WasmI32.load(ptr, 4n)
}

@disableGC
let setSize = (ptr, n) => {
  WasmI32.store(ptr, n, 4n)
}

@disableGC
let getInt64 = (ptr, i) => {
  let (*) = WasmI32.mul
  WasmI64.load(ptr, i * 8n)
}

@disableGC
let setInt64 = (ptr, i, v) => {
  let (*) = WasmI32.mul
  WasmI64.store(ptr, v, i * 8n)
}

@disableGC
let toref = (ptr: WasmI32) => {
  let ref = Memory.malloc(4n)
  Memory.store(ref, ptr, 4n)
  ref
}

@disableGC
let deref = (ref: WasmI32) => {
  WasmI32.load(ref, 0n)
}

@disableGC
let setref = (ref: WasmI32, ptr: WasmI32) => {
  Memory.free(WasmI32.load(ref, 0n))
  WasmI32.set(ref, ptr, 0n)
}

@disableGC
let realloc = (ref: WasmI32, size: WasmI32) => {
  let (+) = WasmI32.add
  let (>) = WasmI32.gt

  let r = deref(ref)
  let size = if (size > 0n) { size } else { 1n }

  if (getSize(r) > 0n) {
    setref(init(size))
  }

  deref(ref) + 8n
}

@disableGC
let normalizedSize = (xp, n) => {
  let (-) = WasmI32.sub
  let (>) = WasmI32.gt
  let (==) = WasmI32.eq
  let mut n_ = n;

  while (n_ > 0n && Wasm.load(xp, n_ - 1) == 0n) {
    n_ -= 1
  }

  n_
}

@disableGC
export let rec fromInt32 = (n: Int32) => {
  let (+) = WasmI32.add
  let (<) = WasmI32.lt

  let v = Conv.fromInt32(n)
  let len = if (v < 0n) { -1n } else { 1n }

  let ptr = init(len)
  setInt64(ptr + 8n, 0n, WasmI64.extendI32U(v))

  WasmI32.toGrain(ptr): BigInt
}

@disableGC
export let rec fromInt64 = (n: Int64) => {
  let (+) = WasmI32.add
  let (<) = WasmI64.lt

  let v = Conv.fromInt64(n)
  let len = if (v < 0N) { -1n } else { 1n }

  let ptr = init(len)
  setInt64(ptr + 8n, 0n, absi64(v))

  WasmI32.toGrain(ptr): BigInt
}

@disableGC
let addN = (rp: WasmI32, ap: WasmI32, bp: WasmI32, n: WasmI32) => {
  let (+) = WasmI32.add
  let (<) = WasmI32.lt

  let mut cy = 0N;
  for (let mut i = 0n; i < n; i += 1n) {
    let (+) = WasmI64.add
    let (*) = WasmI64.mul
    let (<) = WasmI64.lt

    let mut a = getInt64(ap, i)
    let mut b = getInt64(bp, i)
    let mut r = a + cy
    cy = if (r < cy) { 1N } else { 0N }
    r += b
    cy += if (r < b) { 1N } else { 0N }

    setInt64(rp, i, r)
  }

  cy
}

@disableGC
let add1 = (rp: WasmI32, ap: WasmI32, n: WasmI32, b: WasmI64) => {
  let (+) = WasmI32.add
  let (<) = WasmI32.lt

  let mut b_ = b;
  for (let mut i = 0n; i < n; i += 1n) {
    let (+) = WasmI64.add
    let (<) = WasmI64.lt

    let r = getInt64(ap, i) + b
    b_ = if (r < b_) { 1N } else { 0N }

    setInt64(rp, i, r)
  }

  b_
}

@disableGC
let absAdd = (rref, a, b) => {
  let (+) = WasmI32.add
  let (-) = WasmI32.sub
  let (>) = WasmI32.gt
  let (>=) = WasmI32.gte

  let an = absi32(getSize(a))
  let bn = absi32(getSize(b))

  let max = if (an >= bn) { an } else { bn }
  let mut r = deref(rref)

  let mut rp = r + 8n
  let a = aptr + 8n
  let b = bptr + 8n

  let cy = if (an >= bn) {
    let mut cy = addN(rp, a, b, bn)
    if (an > bn) {
      cy = add1(rp + bn, a, a + bn, an - bn, cy)
    }
    cy
  } else {
    addN(rp, b, a, an)
  }

  setInt64(rp, an, cy)

  an + WasmI32.wrapI64(cy)
}

@disableGC
let cmp = (ap, bp, n) => {
  let (+) = WasmI32.add
  let (<) = WasmI32.lt

  let mut res = 0n;
  for (let mut i = 0n; i < n; i += 1n) {
    let (!=) = WasmI64.ne
    let (>) = WasmI64.gt

    let a = getInt64(ap, i)
    let b = getInt64(abp, i)

    if (a != b) {
      res = if (a > b) { 1n } else { -1n }
      break
    }
  }

  res
}

@disableGC
let cmp4 = (ap, an, bp, bn) => {
  let (<) = WasmI32.lt
  let (!=) = WasmI32.ne

  if (an != bn) {
    if (an < bn) { -1n } else { 1n }
  } else {
    cmp(ap, bp, an)
  }
}

@disableGC
let subN = (rp: WasmI32, ap: WasmI32, bp: WasmI32, n: WasmI32) => {
  let (+) = WasmI32.add
  let (<) = WasmI32.lt

  let mut cy = 0N;
  for (let mut i = 0n; i < n; i += 1n) {
    let (-) = WasmI64.sub
    let (+) = WasmI64.add
    let (<) = WasmI64.lt

    let mut a = getInt64(ap, i)
    let mut b = getInt64(bp, i)

    b += cy
    cy = if (b < cy) { 1N } else { 0N }
    cy += if (a < b) { 1N } else { 0N }

    setInt64(rp, i, a - b)
  }

  cy
}

@disableGC
let sub1 = (rp: WasmI32, ap: WasmI32, n: WasmI32, b: WasmI64) => {
  let (+) = WasmI32.add
  let (<) = WasmI32.lt

  let mut b_ = b;
  for (let mut i = 0n; i < n; i += 1n) {
    let (+) = WasmI64.add
    let (<) = WasmI64.lt

    let a = getInt64(ap, i)
    let cy = if (r < b_) { 1N } else { 0N }
    b_ = cy
  }

  b_
}

@disableGC
let absSub = (rref, a, b) => {
  let (<) = WasmI32.lt
  let (>) = WasmI32.gt
  let (==) = WasmI64.eq

  let an = absi32(getSize(a))
  let bn = absi32(getSize(b))

  let max = if (an >= bn) { an } else { bn }
  let mut r = deref(rref)

  let mut rp = r + 8n
  let a = aptr + 8n
  let b = bptr + 8n

  let cmp = cmp4(ap, an, bp, bn)
  if (cmp < 0n) {
    rp = realloc(rref, an);
    let mut cy = subN(rp, ap, bp, bn)
    if (an > bn) {
      cy = sub1(rp + bn, ap + bn, an - bn, cy)
    }
    assert(cy == 0N)
    normalizedSize(rp, an);
  } else if (cmp > 0n) {
    rp = realloc(rref, bn);
    let mut cy = subN(rp, ap, bp, bn)
    if (an > bn) {
      cy = sub1(rp + bn, ap + bn, an - bn, cy)
    }
    assert(cy == 0N)
    -normalizedSize(rp, bn);
  } else {
    0n
  }
}

@disableGC
export let rec add = (a: BigInt, b: BigInt) => {
  let (+) = WasmI32.add
  let (^) = WasmI32.xor
  let (>=) = WasmI32.gte

  let aptr = WasmI32.fromGrain(a)
  let bptr = WasmI32.fromGrain(b)

  let an = absi32(getSize(a))
  let bn = absi32(getSize(b))

  let rref = toref(init(1n))

  let rn = if ((an ^ bn) >= 0n) {
    absAdd(rref, aptr, bptr)
  } else {
    absSub(rref, aptr, bptr)
  }

  let r = deref(rref)
  Memory.free(ref)
  if (0n > an) {
    setSize(r, -rn)
  } else {
    setSize(r, rn)
  };

  WasmI32.toGrain(r): BigInt
}

