/**
 * @module Option: Utilities for working with the Option data type.
 * 
 * The Option type is an enum that represents the possibility of something being present (with the `Some` variant), or not (with the `None` variant). Thereâ€™s no standalone `null` or `none` type in Grain; use an Option where you would normally reach for `null` or `none`
 * 
 * @example import Option from "option"
 * 
 * Create new `Option` values using `Some()` and `None`.
 * 
 * @example let has_value = Some(1234), no_value = None
 * 
 * @since v0.2.0
 */

/**
 * @section Values: Functions for working with the Option data type.
 */

/**
 * Checks if the Option is the `Some` variant.
 *
 * @param option: The Option to check
 * @returns `true` if the Option is the `Some` variant, `false` otherwise
 * 
 * @since v0.2.0
 */
export let isSome = (option) => {
  match (option) {
    Some(_) => true,
    None => false
  }
}

/**
 * Checks if the Option is the `None` variant.
 *
 * @param option: The Option to check
 * @returns `true` if the Option is the `None` variant, `false` otherwise
 * 
 * @since v0.2.0
 */
export let isNone = (option) => {
  match (option) {
    None => true,
    Some(_) => false
  }
}

/**
 * Checks if the Option is the `Some` variant and contains the given value. Uses the generic `==` equality operator.
 *
 * @param value: The value to expect
 * @param option: The Option to check
 * @returns `true` if the Option is the `Some` variant and contains the given value, `false` otherwise
 * 
 * @since v0.2.0
 */
export let contains = (value, option) => {
  match (option) {
    Some(x) => x == value,
    None => false
  }
}

/**
 * Extracts the value inside a `Some` result, otherwise throw an
 * exception containing the message provided. 
 * If it is `None`, throws the provided failure message.
 *
 * @param msg: The failure message
 * @param option: The Option to unwrap
 * @returns The unwrapped value if the Option is the `Some` variant
 * 
 * @since v0.2.0
 */
export let expect = (msg, option) => {
  match (option) {
    Some(x) => x,
    None => fail msg
  }
}

/**
 * Extracts the value inside a `Some` Option, otherwise 
 * throw an exception containing a default message.
 *
 * @param option: The Option to extract the value from
 * @returns The unwrapped value if the Option is the `Some` variant
 * 
 * @since v0.2.0
 */
export let unwrap = (option) => {
  expect("Could not unwrap None value", option)
}

/**
 * Extracts the value inside a `Some` Option, otherwise 
 * return the provided default value.
 *
 * @param default: The default value to return
 * @param option: The Option to unwrap
 * @returns The unwrapped value if the Option is the `Some` variant, otherwise the default value provided
 * 
 * @since v0.2.0
 */
export let unwrapWithDefault = (default, option) => {
  match (option) {
    Some(x) => x,
    None => default
  }
}

/**
 * If the Option is `Some(value)`, applies the given function to the `value` to produce a new Option.
 *
 * @param fn: The function to call on the value of an `Some` variant
 * @param option: The Option to map
 * @returns A new Option produced by the mapping function if the variant was `Some` or the unmodified `None` otherwise
 * 
 * @since v0.2.0
 */
export let map = (fn, option) => {
  match (option) {
    Some(x) => Some(fn(x)),
    None => None
  }
}

/**
 * If the Option is `Some(value)`, applies the given function to the `value` to produce a new value, otherwise uses the default value.
 * Useful for unwrapping a `Some` Option while providing a fallback for any None values.
 *
 * @param fn: The function to call on the value of a `Some` variant
 * @param default: A fallback value for a `None` variant
 * @param option: The Option to map
 * @returns The value produced by the mapping function if the Option is of the `Some` variant or the default value otherwise
 * 
 * @since v0.2.0
 */
export let mapWithDefault = (fn, default, option) => {
  match (option) {
    Some(x) => fn(x),
    None => default
  }
}

/**
 * If the Option is `Some(value)`, applies the `fn` function to the `value` to produce a new value.
 * If the Option is `None`, applies the `defaultFn` function to produce a new value.
 * Useful for unwrapping an Option into a value, whether it is `Some` or `None`.
 *
 * @param fn: The function to call on the value of a `Some` variant
 * @param defaultFn: The default function to map with
 * @param option: The Option to map
 * @returns The value produced by one of the mapping functions
 * 
 * @since v0.2.0
 */
export let mapWithDefaultFn = (fn, defaultFn, option) => {
  match (option) {
    Some(x) => fn(x),
    None => defaultFn()
  }
}

/**
 * If the Option is `Some(value)`, applies the given function to the `value` to produce a new Option.
 *
 * @param fn: The function to call on the value of a `Some` variant
 * @param option: The result to map
 * @returns A new Option produced by the mapping function if the variant was `Some` or the unmodified `None` otherwise
 * 
 * @since v0.2.0
 */
export let flatMap = (fn, option) => {
  match (option) {
    Some(x) => fn(x),
    None => None
  }
}

/**
 * If the Option is `Some(value)` call `fn` with the `value`, 
 * if the `fn` return `true` returns `Some(value)`, otherwise returns `None`.
 *
 * @param fn: The function to filter with
 * @param option: The Option to filter
 * @returns `Some(value)` if the filter function returns `true`, `None` otherwise
 * 
 * @since v0.2.0
 */
export let filter = (fn, option) => {
  match (option) {
    Some(x) =>
      if (fn(x)) {
        Some(x)
      } else {
        None
      },
    None => None
  }
}

/**
 * If both `optionA` and `optionB` are `Some(value)` return `Some((valueA, valueB))`, otherwise return `None`.
 *
 * @param optionA: The first Option to zip
 * @param optionB: The second Option to zip
 * @returns `Some((valueA, valueB))` if both Options are `Some` variants, otherwise `None`
 * 
 * @since v0.2.0
 */
export let zip = (optionA, optionB) => {
  match ((optionA, optionB)) {
    (Some(a), Some(b)) => Some((a, b)),
    _ => None
  }
}

/**
 * If both `optionA` and `optionB` are `Some(value)` return `Some((fn(valueA), fn(valueB)))`, otherwise return `None`.
 *
 * @param fn: The function to zip with
 * @param optionA: The first Option to zip
 * @param optionB: The second Option to zip
 * @returns `Some((fn(valueA), fn(valueB)))` if both Options are `Some` variants, otherwise `None`
 * 
 * @since v0.2.0
 */
export let zipWith = (fn, optionA, optionB) => {
  match ((optionA, optionB)) {
    (Some(a), Some(b)) => Some(fn(a, b)),
    _ => None
  }
}

/**
 * Flattens nested Options, like `Some(Some(1))` to `Some(1)`. If any of the Options are `None`, returns `None`.
 *
 * @param option: The Option to flatten
 * @returns `Some(Some(1))` to `Some(1)`. If any of the Options are `None`, returns `None`
 * 
 * @since v0.2.0
 */
export let flatten = (option) => {
  match (option) {
    Some(Some(x)) => Some(x),
    _ => None
  }
}

/**
 * If the Option is `Some(value)` returns `[ value ]`, Otherwise returns `[ ]`.
 *
 * @param option: The Option to convert
 * @returns `Some(value)` returns `[ value ]`, Otherwise returns `[ ]`
 * 
 * @since v0.2.0
 */
export let toList = (option) => {
  match (option) {
    Some(x) => [x],
    None => []
  }
}

/**
 * If the Option is `Some(value)` returns `[> value ]`, Otherwise returns `[> ]`.
 *
 * @param option: The Option to convert
 * @returns `Some(value)` returns `[> value ]`, Otherwise returns `[> ]`
 * 
 * @since v0.2.0
 */
export let toArray = (option) => {
  match (option) {
    Some(x) => [> x],
    None => [>]
  }
}

/**
 * If the Option is the `Some(value)`, returns `Ok(value)`. 
 * If it is `None`, returns an `Err(err)` where `err` is the provided error message.
 * Converts the Option to a Result. .
 *
 * @param err: The error to use if the Option is `None`
 * @param option: The Option to convert
 * @returns `Ok(value)` if the Option is `Some(value)` or `Err(err)` if the Option is `None`
 * 
 * @since v0.2.0
 */
export let toResult = (err, option) => {
  match (option) {
    Some(a) => Ok(a),
    None    => Err(err)
  }
}

/**
 * If the Option is `Some(value)`, applies the `fn` function to the `value` without producing a new value.
 * Useful for inspecting Options without changing anything.
 *
 * @param fn: The function to call on the value of a `Some` variant
 * @param option: The Option to inspect
 * 
 * @since v0.2.0
 */
export let sideEffect = (fn, option) => {
  match (option) {
    Some(x) => fn(x),
    None => void
  }
}

/**
 * If the Option is `Some(value)`, applies the `fn` function to the `value` without producing a new value.
 * Useful for inspecting Options without changing anything.
 *
 * @param fn: The function to call on the value of a `Some` variant
 * @param option: The Option to inspect
 * @returns The modified Option
 * 
 * @since v0.2.0
 */
export let peek = (fn, option) => {
  sideEffect(fn, option)
  option
}

/**
 * Behaves like a logical OR (`||`) where the first Option is only returned if it is the `Some` variant and falling back to the second Option in all other cases.
 *
 * @param optionA: The first Option
 * @param optionB: The first Option
 * @returns The first Option if it is the `Some` variant or the second Option otherwise
 * 
 * @since v0.2.0
 */
export let or = (optionA, optionB) => {
  match (optionA) {
    Some(x) => optionA,
    None => optionB
  }
}

/**
 * Behaves like a logical AND (`&&`) where the first Option is only returned if it is the `None` variant and falling back to the second Option Result in all other cases.
 *
 * @param optionA: The first Option
 * @param optionB: The first Option
 * @returns The second Option if both are the `Some` variant or the first Option otherwise
 * 
 * @since v0.2.0
 */
export let and = (optionA, optionB) => {
  match (optionA) {
    Some(_) => optionB,
    None => optionA
  }
}
