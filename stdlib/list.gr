/**
 * Utilities for working with lists.
 *
 * @example from "list" include List
 *
 * @since v0.2.0
 * @history v0.1.0: Originally named `lists`
 * @history v0.2.0: Renamed to `list`
 */
module List

from "runtime/unsafe/memory" include Memory
from "runtime/unsafe/wasmi32" include WasmI32
from "runtime/dataStructures" include DataStructures

/**
 * Creates a new list of the specified length where each element is
 * initialized with the result of an initializer function. The initializer
 * is called with the index of each list element.
 *
 * @param length: The length of the new list
 * @param fn: The initializer function to call with each index, where the value returned will be used to initialize the element
 * @returns The new list
 *
 * @example List.init(5, n => n + 3) // [3, 4, 5, 6, 7]
 *
 * @since v0.3.0
 */
provide let init = (length, fn) => {
  // This method can be further improved by checking the length against a specific size
  // and determining if it can be made tail-recursive, then use List.reverse on it.
  // Which would be the same as OCaml does it in https://github.com/ocaml/ocaml/blob/03839754f46319aa36d9dad56940a6f3c3bcb48a/stdlib/list.ml#L79
  let rec iter = (idx, length) => {
    if (idx >= length) {
      []
    } else {
      [fn(idx), ...iter(idx + 1, length)]
    }
  }
  iter(0, length)
}

/**
 * Computes the length of the input list.
 *
 * @param list: The list to inspect
 * @returns The number of elements in the list
 *
 * @since v0.1.0
 * @history v0.2.0: Made the function tail-recursive
 */
provide let length = list => {
  let rec iter = (len, list) => {
    match (list) {
      [] => len,
      [_, ...rest] => iter(len + 1, rest),
    }
  }
  iter(0, list)
}

/**
 * Determines if the list contains no elements.
 *
 * @param list: The list to inspect
 * @returns `true` if the list is empty and `false` otherwise
 *
 * @since v0.6.0
 */
provide let isEmpty = list => {
  match (list) {
    [] => true,
    _ => false,
  }
}

/**
 * Creates a new list with all elements in reverse order.
 *
 * @param list: The list to reverse
 * @returns The new list
 *
 * @since v0.1.0
 */
provide let reverse = list => {
  let rec iter = (list, acc) => {
    match (list) {
      [] => acc,
      [first, ...rest] => iter(rest, [first, ...acc]),
    }
  }
  iter(list, [])
}

/**
 * Creates a new list with the elements of the first list followed by
 * the elements of the second list.
 *
 * @param list1: The list containing elements to appear first
 * @param list2: The list containing elements to appear second
 * @returns The new list containing elements from `list1` followed by elements from `list2`
 *
 * @since v0.1.0
 */
provide let rec append = (list1, list2) => {
  match (list1) {
    [] => list2,
    [first, ...rest] => [first, ...append(rest, list2)],
  }
}

/**
 * Checks if the value is an element of the input list.
 * Uses the generic `==` structural equality operator.
 *
 * @param search: The value to compare
 * @param list: The list to inspect
 * @returns `true` if the value exists in the list or `false` otherwise
 *
 * @since v0.1.0
 */
provide let rec contains = (search, list) => {
  match (list) {
    [] => false,
    [first, ...rest] => first == search || contains(search, rest),
  }
}

/**
 * Combines all elements of a list using a reducer function,
 * starting from the "head", or left side, of the list.
 *
 * In `List.reduce(fn, initial, list)`, `fn` is called with
 * an accumulator and each element of the list, and returns
 * a new accumulator. The final value is the last accumulator
 * returned. The accumulator starts with value `initial`.
 *
 * @param fn: The reducer function to call on each element, where the value returned will be the next accumulator value
 * @param initial: The initial value to use for the accumulator on the first iteration
 * @param list: The list to iterate
 * @returns The final accumulator returned from `fn`
 *
 * @example List.reduce((a, b) => a + b, 0, [1, 2, 3]) // 6
 *
 * @since v0.2.0
 * @history v0.1.0: Originally named `foldLeft`
 * @history v0.2.0: Renamed to `reduce`
 */
provide let rec reduce = (fn, initial, list) => {
  match (list) {
    [] => initial,
    [first, ...rest] => reduce(fn, fn(initial, first), rest),
  }
}

/**
 * Combines all elements of a list using a reducer function,
 * starting from the "end", or right side, of the list.
 *
 * In `List.reduceRight(fn, initial, list)`, `fn` is called with
 * each element of the list and an accumulator, and returns
 * a new accumulator. The final value is the last accumulator
 * returned. The accumulator starts with value `initial`.
 *
 * @param fn: The reducer function to call on each element, where the value returned will be the next accumulator value
 * @param initial: The initial value to use for the accumulator on the first iteration
 * @param list: The list to iterate
 * @returns The final accumulator returned from `fn`
 *
 * @example List.reduceRight((a, b) => b ++ a, "", ["baz", "bar", "foo"]) // "foobarbaz"
 *
 * @since v0.2.0
 * @history v0.1.0: Originally named `foldRight`
 * @history v0.2.0: Renamed to `reduceRight`
 */
provide let rec reduceRight = (fn, initial, list) => {
  match (list) {
    [] => initial,
    [first, ...rest] => fn(first, reduceRight(fn, initial, rest)),
  }
}

/**
 * Produces a new list initialized with the results of a mapper function
 * called on each element of the input list.
 *
 * @param fn: The mapper function to call on each element, where the value returned will be used to initialize the element in the new list
 * @param list: The list to iterate
 * @returns The new list with mapped values
 *
 * @since v0.1.0
 */
provide let rec map = (fn, list) => {
  match (list) {
    [] => [],
    [first, ...rest] => [fn(first), ...map(fn, rest)],
  }
}

/**
 * Produces a new list initialized with the results of a mapper function
 * called on each element of the input list and its index.
 *
 * @param fn: The mapper function to call on each element, where the value returned will be used to initialize the element in the new list
 * @param list: The list to iterate
 * @returns The new list with mapped values
 *
 * @since v0.1.0
 */
provide let mapi = (fn, list) => {
  let rec iter = (fn, list, index) => {
    match (list) {
      [] => [],
      [first, ...rest] => [fn(first, index), ...iter(fn, rest, index + 1)],
    }
  }
  iter(fn, list, 0)
}

/**
 * Produces a new list by calling a function on each element
 * of the input list. Each iteration produces an intermediate
 * list, which are all appended to produce a "flattened" list
 * of all results.
 *
 * @param fn: The function to be called on each element, where the value returned will be a list that gets appended to the new list
 * @param list: The list to iterate
 * @returns The new list
 *
 * @since v0.2.0
 */
provide let rec flatMap = (fn, list) => {
  match (list) {
    [] => [],
    [first, ...rest] => append(fn(first), flatMap(fn, rest)),
  }
}

/**
 * Checks that the given condition is satisfied for all
 * elements in the input list.
 *
 * @param fn: The function to call on each element, where the returned value indicates if the element satisfies the condition
 * @param list: The list to check
 * @returns `true` if all elements satify the condition or `false` otherwise
 *
 * @since v0.1.0
 */
provide let rec every = (fn, list) => {
  match (list) {
    [] => true,
    // The short-circuiting of `&&` makes this tail-recursive
    [first, ...rest] => fn(first) && every(fn, rest),
  }
}

/**
 * Checks that the given condition is satisfied **at least
 * once** by an element in the input list.
 *
 * @param fn: The function to call on each element, where the returned value indicates if the element satisfies the condition
 * @param list: The list to iterate
 * @returns `true` if one or more elements satify the condition or `false` otherwise
 *
 * @since v0.1.0
 */
provide let rec some = (fn, list) => {
  match (list) {
    [] => false,
    // The short-circuiting of `||` makes this tail-recursive
    [first, ...rest] => fn(first) || some(fn, rest),
  }
}

/**
 * Iterates a list, calling an iterator function on each element.
 *
 * @param fn: The iterator function to call with each element
 * @param list: The list to iterate
 *
 * @since v0.1.0
 */
provide let rec forEach = (fn, list) => {
  match (list) {
    [] => void,
    [first, ...rest] => {
      fn(first): Void
      forEach(fn, rest)
    },
  }
}

/**
 * Iterates a list, calling an iterator function on each element.
 * Also passes the index as the second argument to the function.
 *
 * @param fn: The iterator function to call with each element
 * @param list: The list to iterate
 *
 * @since v0.1.0
 */
provide let forEachi = (fn, list) => {
  let rec iter = (fn, list, index) => {
    match (list) {
      [] => void,
      [first, ...rest] => {
        fn(first, index): Void
        iter(fn, rest, index + 1)
      },
    }
  }
  iter(fn, list, 0)
}

/**
 * Produces a new list by calling a function on each element of
 * the input list and only including it in the result list if the element satisfies
 * the condition.
 *
 * @param fn: The function to call on each element, where the returned value indicates if the element satisfies the condition
 * @param list: The list to iterate
 * @returns The new list containing elements where `fn` returned `true`
 *
 * @since v0.1.0
 */
provide let rec filter = (fn, list) => {
  match (list) {
    [] => [],
    [first, ...rest] =>
      if (fn(first)) [first, ...filter(fn, rest)] else filter(fn, rest),
  }
}

/**
 * Produces a new list by calling a function on each element of
 * the input list and only including it in the result list if the element satisfies
 * the condition. Also passes the index to the function.
 *
 * @param fn: The function to call on each element, where the returned value indicates if the element satisfies the condition
 * @param list: The list to iterate
 * @returns The new list containing elements where `fn` returned `true`
 *
 * @since v0.3.0
 */
provide let filteri = (fn, list) => {
  let rec iter = (fn, list, index) => {
    match (list) {
      [] => [],
      [first, ...rest] =>
        if (fn(first, index))
          [first, ...iter(fn, rest, index + 1)]
        else
          iter(fn, rest, index + 1),
    }
  }
  iter(fn, list, 0)
}

/**
 * Produces a new list by calling a function on each element of
 * the input list and excluding it from the result list if the element satisfies
 * the condition.
 *
 * @param fn: The function to call on each element, where the returned value indicates if the element satisfies the condition
 * @param list: The list to iterate
 * @returns The new list containing elements where `fn` returned `false`
 *
 * @since v0.1.0
 */
provide let rec reject = (fn, list) => {
  match (list) {
    [] => [],
    [first, ...rest] =>
      if (!fn(first)) [first, ...reject(fn, rest)] else reject(fn, rest),
  }
}

/**
 * Provides `Some(element)` containing the first element, or "head", of
 * the input list or `None` if the list is empty.
 *
 * @param list: The list to access
 * @returns `Some(firstElement)` if the list has elements or `None` otherwise
 *
 * @since v0.2.0
 * @history v0.1.0: Originally named `hd`
 * @history v0.2.0: Renamed to `head`
 * @history v0.3.0: Return type converted to `Option` type
 */
provide let head = list => {
  match (list) {
    [] => None,
    [first, ..._] => Some(first),
  }
}

/**
 * Provides `Some(tail)` containing all list items except the first element, or "tail", of
 * the input list or `None` if the list is empty.
 *
 * @param list: The list to access
 * @returns `Some(tail)` if the list has elements or `None` otherwise
 *
 * @since v0.2.0
 * @history v0.1.0: Originally named `tl`
 * @history v0.2.0: Renamed to `tail`
 * @history v0.3.0: Return type converted to `Option` type
 */
provide let tail = list => {
  match (list) {
    [] => None,
    [_, ...rest] => Some(rest),
  }
}

/**
 * Provides `Some(element)` containing the element in the list at the specified index
 * or `None` if the index is out-of-bounds or the list is empty.
 *
 * @param index: The index to access
 * @param list: The list to access
 * @returns `Some(element)` if the list contains an element at the index or `None` otherwise
 *
 * @since v0.1.0
 * @history v0.1.0: Originally failed for index out-of-bounds or list empty
 * @history v0.3.0: Return type converted to `Option` type
 */
provide let rec nth = (index, list) => {
  if (index < 0) {
    None
  } else {
    match (list) {
      [] => None,
      [first, ...rest] => if (index == 0) Some(first) else nth(index - 1, rest),
    }
  }
}

/**
 * Flattens nested lists.
 *
 * @param list: The list to flatten
 * @returns A new list containing all nested list elements combined
 *
 * @example List.flatten([[1, 2], [3, 4]]) // [1, 2, 3, 4]
 *
 * @since v0.1.0
 */
provide let rec flatten = list => {
  match (list) {
    [] => [],
    [first, ...rest] => append(first, flatten(rest)),
  }
}

/**
 * Inserts a new value into a list at the specified index.
 *
 * @param index: The index to update
 * @param value: The value to insert
 * @param list: The list to update
 * @returns The new list
 *
 * @throws Failure(String): When `index` is negative
 * @throws Failure(String): When `index` is more than 0 and greater than the list size
 *
 * @since v0.1.0
 * @history v0.6.0: Swapped order of `index` and `value` parameters
 */
provide let rec insert = (index, value, list) => {
  if (index < 0) {
    fail "insert index cannot be a negative number"
  } else {
    match (list) {
      [] => if (index == 0) [value] else fail "insert index is out-of-bounds",
      [first, ...rest] =>
        if (index == 0)
          [value, ...list]
        else
          [first, ...insert(index - 1, value, rest)],
    }
  }
}

/**
 * Counts the number of elements in a list that satisfy the given condition.
 *
 * @param fn: The function to call on each element, where the returned value indicates if the element satisfies the condition
 * @param list: The list to iterate
 * @returns The total number of elements that satisfy the condition
 *
 * @since v0.1.0
 * @history v0.2.0: Made the function tail-recursive
 */
provide let count = (fn, list) => {
  let rec iter = (n, list) => {
    match (list) {
      [] => n,
      [first, ...rest] => if (fn(first)) iter(n + 1, rest) else iter(n, rest),
    }
  }
  iter(0, list)
}

/**
 * Split a list into two, with the first list containing the required number of elements.
 *
 * @param count: The number of elements required
 * @param list: The list to split
 * @returns Two lists where the first contains exactly the required amount of elements and the second contains any remaining elements
 *
 * @throws Failure(String): When `count` is negative
 * @throws Failure(String): When the list doesn't contain at least the required amount of elements
 *
 * @since v0.1.0
 */
provide let part = (count, list) => {
  if (count < 0) {
    fail "part count cannot be a negative number"
  } else {
    let rec iter = (list1, list2, count) => {
      match (list2) {
        [] =>
          if (count > 0) fail "part count is out-of-bounds" else (list1, list2),
        [first, ...rest] =>
          if (count > 0)
            iter([first, ...list1], rest, count - 1)
          else
            (list1, list2),
      }
    }
    let (pt1, pt2) = iter([], list, count)
    (reverse(pt1), pt2)
  }
}

/**
 * Rotates list elements by the specified amount to the left, such that `n`th
 * element is the first in the new list.
 *
 * If value is negative, list elements will be rotated by the
 * specified amount to the right. See examples.
 *
 * @param n: The number of elements to rotate by
 * @param list: The list to be rotated
 *
 * @example List.rotate(2, [1, 2, 3, 4, 5]) // [3, 4, 5, 1, 2]
 * @example List.rotate(-1, [1, 2, 3, 4, 5]) // [5, 1, 2, 3, 4]
 * @example List.rotate(-7, [1, 2, 3, 4, 5]) // [4, 5, 1, 2, 3]
 *
 * @since v0.1.0
 *
 * @history v0.6.0: No longer throws if `count` outside list length bounds
 */
provide let rotate = (n, list) => {
  // Optimization: only compute the list length (O(n)) if n is negative
  // or if the entire list is exhausted when partitioning. This should improve
  // performance if the list is very long but n is small
  let getSplitI = () => {
    let len = length(list)
    if (len == 0) 0 else n % len
  }
  let (beginning, end) = if (n >= 0) {
    let rec iter = (list1, list2, n) => {
      match (list2) {
        [] => if (n > 0) None else Some((list1, list2)),
        [first, ...rest] =>
          if (n > 0)
            iter([first, ...list1], rest, n - 1)
          else
            Some((list1, list2)),
      }
    }
    let res = iter([], list, n)
    match (res) {
      None => part(getSplitI(), list),
      Some((pt1, pt2)) => (reverse(pt1), pt2),
    }
  } else {
    part(getSplitI(), list)
  }
  append(end, beginning)
}

/**
 * Produces a new list with any duplicates removed.
 * Uses the generic `==` structural equality operator.
 *
 * @param list: The list to filter
 * @returns The new list with only unique values
 *
 * @since v0.2.0
 * @history v0.1.0: Originally named `uniq`
 * @history v0.2.0: Renamed to `unique`
 */
provide let unique = list => {
  let rec iter = (list, acc) => {
    match (list) {
      [] => reverse(acc),
      [first, ...rest] =>
        if (contains(first, acc))
          iter(rest, acc)
        else
          iter(rest, [first, ...acc]),
    }
  }
  iter(list, [])
}

/**
 * Produces a new list filled with tuples of elements from both given lists.
 * The first tuple will contain the first item of each list, the second tuple
 * will contain the second item of each list, and so on.
 *
 * Calling this function with lists of different sizes will cause the returned
 * list to have the length of the smaller list.
 *
 * @param list1: The list to provide values for the first tuple element
 * @param list2: The list to provide values for the second tuple element
 * @returns The new list containing indexed pairs of `(a, b)`
 *
 * @example List.zip([1, 2, 3], [4, 5, 6]) // [(1, 4), (2, 5), (3, 6)]
 * @example List.zip([1, 2, 3], [4, 5]) // [(1, 4), (2, 5)]
 *
 * @since v0.5.3
 */
provide let zip = (list1, list2) => {
  let rec zipInner = (list1, list2, acc) => {
    match ((list1, list2)) {
      ([first1, ...rest1], [first2, ...rest2]) =>
        zipInner(rest1, rest2, [(first1, first2), ...acc]),
      _ => acc,
    }
  }
  reverse(zipInner(list1, list2, []))
}

/**
 * Produces a new list filled with elements defined by applying a function on
 * pairs from both given lists. The first element will contain the result of
 * applying the function to the first elements of each list, the second element
 * will contain the result of applying the function to the second elements of
 * each list, and so on.
 *
 * Calling this function with lists of different sizes will cause the returned
 * list to have the length of the smaller list.
 *
 * @param fn: The function to apply to pairs of elements
 * @param list1: The list whose elements will each be passed to the function as the first argument
 * @param list2: The list whose elements will each be passed to the function as the second argument
 * @returns The new list containing elements derived from applying the function to pairs of input list elements
 *
 * @example List.zipWith((a, b) => a + b, [1, 2, 3], [4, 5, 6]) // [5, 7, 9]
 * @example List.zipWith((a, b) => a * b, [1, 2, 3], [4, 5]) // [4, 10]
 *
 * @since v0.5.3
 */
provide let zipWith = (fn, list1, list2) => {
  let rec zipWithInner = (list1, list2, acc) => {
    match ((list1, list2)) {
      ([first1, ...rest1], [first2, ...rest2]) =>
        zipWithInner(rest1, rest2, [fn(first1, first2), ...acc]),
      _ => acc,
    }
  }
  reverse(zipWithInner(list1, list2, []))
}

/**
 * Produces two lists by splitting apart a list of tuples.
 *
 * @param list: The list of tuples to split
 * @returns An list containing all elements from the first tuple element, and a list containing all elements from the second tuple element
 *
 * @since v0.5.3
 */
provide let unzip = list => {
  reduceRight(
    ((first, second), (firstUnzipped, secondUnzipped)) => {
      ([first, ...firstUnzipped], [second, ...secondUnzipped])
    },
    ([], []),
    list
  )
}

/**
 * Produces a new list with the specified number of elements removed from
 * the beginning of the input list.
 *
 * @param count: The amount of elements to remove
 * @param list: The input list
 * @returns The new list without the dropped elements
 *
 * @throws Failure(String): When `count` is negative
 *
 * @since v0.2.0
 */
provide let rec drop = (count, list) => {
  if (count < 0) {
    fail "number of items to drop cannot be a negative number"
  } else {
    match ((count, list)) {
      (_, []) => [],
      (0, _) => list,
      (n, [first, ...rest]) => drop(n - 1, rest),
    }
  }
}

/**
 * Produces a new list with the elements removed from the beginning
 * of the input list until they no longer satisfy the given condition.
 * Stops when the predicate function returns `false`.
 *
 * @param fn: The function to call on each element, where the returned value indicates if the element satisfies the condition
 * @param list: The input list
 * @returns The new list without the dropped elements
 *
 * @since v0.2.0
 */
provide let rec dropWhile = (fn, list) => {
  match (list) {
    [] => list,
    [first, ...rest] => if (fn(first)) dropWhile(fn, rest) else list,
  }
}

/**
 * Produces a new list with–at most—the specified amount elements from
 * the beginning of the input list.
 *
 * @param count: The amount of elements to keep
 * @param list: The input list
 * @returns The new list containing the taken elements
 *
 * @throws Failure(String): When `count` is negative
 *
 * @since v0.2.0
 */
provide let rec take = (count, list) => {
  if (count < 0) {
    fail "number of items to take cannot be a negative number"
  } else {
    match ((count, list)) {
      (_, []) => list,
      (0, _) => [],
      (n, [first, ...rest]) => [first, ...take(n - 1, rest)],
    }
  }
}

/**
 * Produces a new list with elements from the beginning of the input list
 * as long as they satisfy the given condition.
 * Stops when the predicate function returns `false`.
 *
 * @param fn: The function to call on each element, where the returned value indicates if the element satisfies the condition
 * @param list: The input list
 * @returns The new list containing the taken elements
 *
 * @since v0.2.0
 */
provide let rec takeWhile = (fn, list) => {
  match (list) {
    [] => [],
    [first, ...rest] => if (fn(first)) [first, ...takeWhile(fn, rest)] else [],
  }
}

/**
 * Finds the first element in a list that satifies the given condition.
 *
 * @param fn: The function to call on each element, where the returned value indicates if the element satisfies the condition
 * @param list: The list to search
 * @returns `Some(element)` containing the first value found or `None` otherwise
 *
 * @since v0.2.0
 * @history v0.2.0: Originally failed if the list was empty
 * @history v0.3.0: Return type converted to `Option` type
 */
provide let rec find = (fn, list) => {
  match (list) {
    [] => None,
    [first, ...rest] => if (fn(first)) Some(first) else find(fn, rest),
  }
}

/**
 * Finds the first index in a list where the element satifies the given condition.
 *
 * @param fn: The function to call on each element, where the returned value indicates if the element satisfies the condition
 * @param list: The list to search
 * @returns `Some(index)` containing the index of the first element found or `None` otherwise
 *
 * @since v0.2.0
 * @history v0.2.0: Originally failed if the list was empty
 * @history v0.3.0: Return type converted to `Option` type
 */
provide let findIndex = (fn, list) => {
  let rec findItemIndex = (l, index) => {
    match (l) {
      [] => None,
      [first, ...rest] =>
        if (fn(first)) Some(index) else findItemIndex(rest, index + 1),
    }
  }
  findItemIndex(list, 0)
}

/**
 * Combines two lists into a Cartesian product of tuples containing
 * all ordered pairs `(a, b)`.
 *
 * @param list1: The list to provide values for the first tuple element
 * @param list2: The list to provide values for the second tuple element
 * @returns The new list containing all pairs of `(a, b)`
 *
 * @since v0.2.0
 */
provide let product = (list1, list2) => {
  let mut list = []
  forEach(aItem => {
    forEach(bItem => {
      list = [(aItem, bItem), ...list]
    }, list2)
  }, list1)
  reverse(list)
}

/**
 * Provides the subset of a list given zero-based start index and amount of elements
 * to include.
 *
 * @param start: The index of the list where the subset will begin (inclusive)
 * @param length: The amount of elements to be included in the subset
 * @param list: The input list
 * @returns The subset of the list
 *
 * @throws Failure(String): When `start` is negative
 * @throws Failure(String): When `length` is negative
 *
 * @since v0.2.0
 */
provide let sub = (start, length, list) => {
  take(length, drop(start, list))
}

// List.join helpers
@unsafe
let rec computeJoinSize = (sepSize: WasmI32, size: WasmI32, lst: List<String>) => {
  use WasmI32.{ (+) }
  use DataStructures.{ stringSize }
  match (lst) {
    [] => size,
    [hd] => size + stringSize(WasmI32.fromGrain(hd)),
    [hd, ...tl] => {
      let size = size + stringSize(WasmI32.fromGrain(hd)) + sepSize
      ignore(hd)
      computeJoinSize(sepSize, size, tl)
    },
  }
}
@unsafe
let rec buildJoinedString = (
  strPtr: WasmI32,
  sepPtr: WasmI32,
  sepSize: WasmI32,
  offset: WasmI32,
  lst: List<String>,
) => {
  use WasmI32.{ (+) }
  use DataStructures.{ stringSize }
  match (lst) {
    [] => void,
    // Last element
    [hd] => {
      let ptr = WasmI32.fromGrain(hd)
      let size = stringSize(ptr)
      Memory.copy(offset, ptr + 8n, size)
      ignore(hd)
    },
    [hd, ...tl] => {
      let ptr = WasmI32.fromGrain(hd)
      let size = stringSize(ptr)
      Memory.copy(offset, ptr + 8n, size)
      ignore(hd)
      let offset = offset + size
      Memory.copy(offset, sepPtr, sepSize)
      buildJoinedString(strPtr, sepPtr, sepSize, offset + sepSize, tl)
    },
  }
}
/**
 * Combine the given list of strings into one string with the specified
 * separator inserted between each item.
 *
 * @param separator: The separator to insert between elements
 * @param list: The list to combine
 * @returns The combined elements with the separator between each
 *
 * @since v0.4.0
 */
@unsafe
provide let join = (separator: String, list: List<String>) => {
  use WasmI32.{ (+), (-), (<=) }
  use DataStructures.{ allocateString, stringSize }
  let sepPtr = WasmI32.fromGrain(separator)
  let sepSize = stringSize(sepPtr)
  let strSize = computeJoinSize(sepSize, 0n, list)
  let newString = allocateString(strSize)
  buildJoinedString(newString, sepPtr + 8n, sepSize, newString + 8n, list)
  ignore(sepPtr)
  return WasmI32.toGrain(newString): String
}

/**
 * Reverses the first list and appends the second list to the end.
 *
 * @param list1: The list to reverse
 * @param list2: The list to append
 * @returns The new list
 *
 * @since v0.4.5
 */
provide let rec revAppend = (list1, list2) => {
  match (list1) {
    [hd, ...tl] => revAppend(tl, [hd, ...list2]),
    [] => list2,
  }
}

/**
 * Sorts the given list based on a given comparator function. The resulting list is sorted in increasing order.
 *
 * Ordering is calculated using a comparator function which takes two list elements and must return 0 if both are equal, a positive number if the first is greater, and a negative number if the first is smaller.
 * @param compare: The comparator function used to indicate sort order
 * @param list: The list to be sorted
 * @returns The sorted list
 *
 * @since v0.4.5
 * @history v0.6.0: Made `compare` a default argument
 */
provide let sort = (compare=compare, list) => {
  let rec merge = (left, right, list) => {
    match ((left, right)) {
      (_, []) => {
        revAppend(list, left)
      },
      ([], _) => {
        revAppend(list, right)
      },
      ([lhd, ...ltl], [rhd, ...rtl]) => {
        if (compare(lhd, rhd) < 0) {
          merge(ltl, right, append([lhd], list))
        } else {
          merge(left, rtl, append([rhd], list))
        }
      },
    }
  }

  let rec mergesort = list => {
    if (length(list) <= 1) {
      list
    } else {
      let middle = length(list) / 2
      let (left, right) = part(middle, list)
      merge(mergesort(left), mergesort(right), [])
    }
  }

  mergesort(list)
}

/**
 * A mutable linked list implementation.
 *
 * @since v0.6.0
 */
provide module Mutable {
  abstract record rec Node<a> {
    mut value: a,
    mut next: Option<Node<a>>,
    mut prev: Option<Node<a>>,
  }

  abstract record List<a> {
    mut length: Number,
    mut head: Option<Node<a>>,
    mut tail: Option<Node<a>>,
  }

  /**
   * Creates a new empty list.
   *
   * @returns The new list
   *
   * @since v0.6.0
   */
  provide let make = () => {
    { length: 0, head: None, tail: None }
  }

  /**
   * Computes the length of the input list.
   *
   * @param list: The list to inspect
   * @returns The number of elements in the list
   *
   * @since v0.6.0
   */
  provide let length = list => {
    list.length
  }

  /**
   * Adds an element to the end of the list.
   * 
   * @param value: The value to add to the list
   * @param list: The list to add the value to
   * 
   * @since v0.6.0
   */
  provide let addLast = (value, list) => {
    let node = Some({ value, next: None, prev: list.tail })
    match (list.tail) {
      Some(tail) => tail.next = node,
      None => void,
    }
    list.tail = node
    if (list.head == None) {
      list.head = node
    }
    list.length += 1
  }

  /**
   * Adds an element to the beginning of the list.
   * 
   * @param value: The value to add to the list
   * @param list: The list to add the value to
   * 
   * @since v0.6.0
   */
  provide let addFirst = (value, list) => {
    let node = Some({ value, next: list.head, prev: None })
    match (list.head) {
      Some(head) => head.prev = node,
      None => void,
    }
    list.head = node
    if (list.tail == None) {
      list.tail = node
    }
    list.length += 1
  }

  /**
   * Removes the element at the end of the list.
   * 
   * @param list: The list to remove the last element of
   * 
   * @since v0.6.0
   */
  provide let removeLast = list => {
    match (list.tail) {
      Some(tail) => {
        list.tail = tail.prev
        match (list.tail) {
          Some(newTail) => newTail.next = None,
          None => list.head = None,
        }
        list.length -= 1
      },
      None => void,
    }
  }

  /**
   * Removes the element at the beginning of the list.
   * 
   * @param list: The list to remove the first element of
   * 
   * @since v0.6.0
   */
  provide let removeFirst = list => {
    match (list.head) {
      Some(head) => {
        list.head = head.next
        match (list.head) {
          Some(newHead) => newHead.prev = None,
          None => list.tail = None,
        }
        list.length -= 1
      },
      None => void,
    }
  }

  /**
   * Creates a new list of the specified length where each element is
   * initialized with the result of an initializer function. The initializer
   * is called with the index of each list element.
   *
   * @param length: The length of the new list
   * @param fn: The initializer function to call with each index, where the value returned will be used to initialize the element
   * @returns The new list
   *
   * @example
   * let list = List.Mutable.init(5, n => n + 3)
   * assert list = List.Mutable.fromList([3, 4, 5, 6, 7])
   *
   * @since v0.6.0
   */
  provide let init = (length, fn) => {
    let list = make()
    for (let mut i = 0; i < length; i += 1) {
      addLast(fn(i), list)
    }
    list
  }

  /**
   * Provides `Some(element)` containing the first element of the input list
   * or `None` if the list is empty.
   *
   * @param list: The list to access
   * @returns `Some(firstElement)` if the list has elements or `None` otherwise
   *
   * @since v0.6.0
   */
  provide let first = list => {
    match (list.head) {
      None => None,
      Some({ value, _ }) => Some(value),
    }
  }

  /**
   * Provides `Some(element)` containing the last element of the input list
   * or `None` if the list is empty.
   *
   * @param list: The list to access
   * @returns `Some(lastElement)` if the list has elements or `None` otherwise
   *
   * @since v0.6.0
   */
  provide let last = list => {
    match (list.tail) {
      None => None,
      Some({ value, _ }) => Some(value),
    }
  }

  /**
   * Provides `Some(element)` containing the element in the list at the specified index
   * or `None` if the index is out-of-bounds or the list is empty.
   *
   * @param index: The index to access
   * @param list: The list to access
   * @returns `Some(element)` if the list contains an element at the index or `None` otherwise
   *
   * @since v0.6.0
   */
  provide let nth = (index, list) => {
    let (getNext, first, startN) = if (index < list.length / 2) {
      (node => node.next, list.head, index)
    } else {
      (node => node.prev, list.tail, list.length - index - 1)
    }
    let rec nthInner = (node, n) => {
      if (n < 0) {
        None
      } else {
        match (node) {
          None => None,
          Some({ value, _ } as node) => {
            if (n == 0) {
              Some(value)
            } else {
              nthInner(getNext(node), n - 1)
            }
          },
        }
      }
    }
    nthInner(first, startN)
  }

  /**
   * Updates the element at the given index in the list.
   * 
   * @param index: The index of the element to update
   * @param value: The value to update the element to
   * @param list: The list to update
   * 
   * @since v0.6.0
   */
  provide let set = (index, value, list) => {
    let (getNext, first, startN) = if (index < list.length / 2) {
      (node => node.next, list.head, index)
    } else {
      (node => node.prev, list.tail, list.length - index - 1)
    }
    let rec setInner = (node, n) => {
      if (n >= 0) {
        match (node) {
          None => {
            if (n != 0) {
              fail "set index is out-of-bounds"
            }
          },
          Some(node) => {
            if (n == 0) {
              node.value = value
            } else {
              setInner(getNext(node), n - 1)
            }
          },
        }
      }
    }
    setInner(first, startN)
  }

  /**
   * Inserts a new value into a list at the specified index.
   *
   * @param index: The index to update
   * @param value: The value to insert
   * @param list: The list to update
   * @returns The new list
   *
   * @throws Failure(String): When `index` is negative
   * @throws Failure(String): When `index` is more than 0 and greater than the list size
   *
   * @since v0.6.0
   */
  provide let insert = (index, value, list) => {
    if (index == 0) {
      addFirst(value, list)
    } else if (index == list.length) {
      addLast(value, list)
    } else {
      let (getNext, getPrev, setNext, setPrev, makeNode, first, startN) = if (
        index <
        list.length / 2
      ) {
        (
          node => node.next,
          node => node.prev,
          (node, val) => node.next = val,
          (node, val) => node.prev = val,
          (value, next, prev) => Some({ value, next, prev }),
          list.head,
          index,
        )
      } else {
        (
          node => node.prev,
          node => node.next,
          (node, val) => node.prev = val,
          (node, val) => node.next = val,
          (value, prev, next) => Some({ value, next, prev }),
          list.tail,
          list.length - index,
        )
      }
      let rec insertInner = (nodeOpt, n) => {
        if (n < 0) {
          fail "insert index is out-of-bounds"
        } else {
          match (nodeOpt) {
            None => fail "insert index is out-of-bounds",
            Some(node) => {
              if (n == 0) {
                let prev = getPrev(node)
                let newNodeOpt = makeNode(value, nodeOpt, prev)
                match (prev) {
                  Some(prev) => setNext(prev, newNodeOpt),
                  _ => void,
                }
                setPrev(node, newNodeOpt)
              } else {
                insertInner(getNext(node), n - 1)
              }
            },
          }
        }
      }
      insertInner(first, startN)
      list.length += 1
    }
  }

  /**
   * Removes the element at the specified index from the list.
   * 
   * @param index: The index of the element to remove from the list
   * @param list: The list to remove the element from
   * 
   * @since v0.6.0
   */
  provide let remove = (index, list) => {
    let (getNext, getPrev, setNext, setPrev, setHead, setTail, first, startN) =
      if (index < list.length / 2) {
        (
          node => node.next,
          node => node.prev,
          (node, val) => node.next = val,
          (node, val) => node.prev = val,
          newHead => list.head = newHead,
          newTail => list.tail = newTail,
          list.head,
          index,
        )
      } else {
        (
          node => node.prev,
          node => node.next,
          (node, val) => node.prev = val,
          (node, val) => node.next = val,
          newTail => list.tail = newTail,
          newHead => list.head = newHead,
          list.tail,
          list.length - index - 1,
        )
      }
    let rec removeInner = (nodeOpt, n) => {
      if (n < 0) {
        fail "remove index is out-of-bounds"
      } else {
        match (nodeOpt) {
          None => fail "remove index is out-of-bounds",
          Some(node) => {
            if (n == 0) {
              let next = getNext(node)
              let prev = getPrev(node)
              match (prev) {
                Some(prev) => setNext(prev, next),
                _ => setHead(next),
              }
              match (next) {
                Some(next) => setPrev(next, prev),
                _ => setTail(prev),
              }
            } else {
              removeInner(getNext(node), n - 1)
            }
          },
        }
      }
    }
    removeInner(first, startN)
    list.length -= 1
  }

  /**
   * Combines all elements of a list using a reducer function,
   * starting from the "head", or left side, of the list.
   *
   * In `List.Mutable.reduce(fn, initial, list)`, `fn` is called with
   * an accumulator and each element of the list, and returns
   * a new accumulator. The final value is the last accumulator
   * returned. The accumulator starts with value `initial`.
   *
   * @param fn: The reducer function to call on each element, where the value returned will be the next accumulator value
   * @param initial: The initial value to use for the accumulator on the first iteration
   * @param list: The list to iterate
   * @returns The final accumulator returned from `fn`
   *
   * @example
   * let list = List.Mutable.fromList([1, 2, 3])
   * assert List.Mutable.reduce((a, b) => a + b, 0, list) == 6
   *
   * @since v0.6.0
   */
  provide let reduce = (fn, initial, list) => {
    let rec reduceInner = (acc, node) => {
      match (node) {
        None => acc,
        Some({ value, next, _ }) => reduceInner(fn(acc, value), next),
      }
    }
    reduceInner(initial, list.head)
  }

  /**
   * Combines all elements of a list using a reducer function,
   * starting from the "end", or right side, of the list.
   *
   * In `List.Mutable.reduceRight(fn, initial, list)`, `fn` is called with
   * each element of the list and an accumulator, and returns
   * a new accumulator. The final value is the last accumulator
   * returned. The accumulator starts with value `initial`.
   *
   * @param fn: The reducer function to call on each element, where the value returned will be the next accumulator value
   * @param initial: The initial value to use for the accumulator on the first iteration
   * @param list: The list to iterate
   * @returns The final accumulator returned from `fn`
   *
   * @example
   * let list = List.Mutable.fromList(["baz", "bar", "foo"])
   * assert List.Mutable.reduceRight((a, b) => b ++ a, "", list) == "foobarbaz"
   *
   * @since v0.6.0
   */
  provide let reduceRight = (fn, initial, list) => {
    let rec reduceRightInner = (acc, node) => {
      match (node) {
        None => acc,
        Some({ value, prev, _ }) => reduceRightInner(fn(value, acc), prev),
      }
    }
    reduceRightInner(initial, list.tail)
  }

  /**
   * Produces a new list initialized with the results of a mapper function
   * called on each element of the input list.
   *
   * @param fn: The mapper function to call on each element, where the value returned will be used to initialize the element in the new list
   * @param list: The list to iterate
   * @returns The new list with mapped values
   *
   * @since v0.6.0
   */
  provide let map = (fn, list) => {
    let rec mapInner = (oldNode, newPrev) => {
      match (oldNode) {
        Some({ value, next, _ }) => {
          let newNode = { value: fn(value), prev: newPrev, next: None }
          let newNodeOpt = Some(newNode)
          let (newNext, newTail) = mapInner(next, newNodeOpt)
          newNode.next = newNext
          (newNodeOpt, newTail)
        },
        None => (None, newPrev),
      }
    }

    let (newHead, newTail) = mapInner(list.head, None)
    { length: list.length, head: newHead, tail: newTail }
  }

  /**
   * Iterates a list, calling an iterator function on each element.
   *
   * @param fn: The iterator function to call with each element
   * @param list: The list to iterate
   *
   * @since v0.6.0
   */
  provide let forEach = (fn, list) => {
    let rec forEachInner = node => {
      match (node) {
        None => void,
        Some({ value, next, _ }) => {
          fn(value)
          forEachInner(next)
        },
      }
    }
    forEachInner(list.head)
  }

  /**
   * Appends all of the elements from the second list into the first list.
   *
   * @param dest: The list to append to
   * @param toAppend: The list containing elements to append
   *
   * @since v0.6.0
   */
  provide let append = (dest, toAppend) => {
    forEach(val => addLast(val, dest), toAppend)
  }

  /**
   * Combines two lists together into the first list. This function is more
   * efficient than `append` for joining two lists, but mutates the second
   * list in the process, making it equivalent to the first list.
   *
   * @param list1: The first list
   * @param list2: The second list
   *
   * @since v0.6.0
   */
  provide let combine = (list1, list2) => {
    match ((list1.tail, list2.head)) {
      (None, None) => void,
      (None, Some(_)) => {
        list1.tail = list2.tail
        list1.head = list2.head
        list1.length = list2.length
      },
      (Some(_), None) => {
        list2.tail = list1.tail
        list2.head = list1.head
        list2.length = list1.length
      },
      (Some(tail1), Some(head2)) => {
        tail1.next = list2.head
        head2.prev = list1.tail

        let length = list1.length + list2.length
        list1.length = length
        list2.length = length
        list1.tail = list2.tail
        list2.head = list1.head
      },
    }
  }

  /**
   * Produces a new list by calling a function on each element
   * of the input list. Each iteration produces an intermediate
   * list, which are all appended to produce a "flattened" list
   * of all results.
   *
   * @param fn: The function to be called on each element, where the value returned will be a list that gets appended to the new list
   * @param list: The list to iterate
   * @returns The new list
   *
   * @since v0.6.0
   */
  provide let flatMap = (fn, list) => {
    let newList = make()
    forEach(x => append(newList, fn(x)), list)
    newList
  }

  /**
   * Converts the input immutable list to a mutable list.
   *
   * @param list: The list to convert
   * @returns The mutable list containing all elements from the immutable list
   *
   * @since v0.6.0
   */
  provide let fromList = list => {
    let rec fromListInner = (list, newPrev, length) => {
      match (list) {
        [] => (None, newPrev, length),
        [first, ...rest] => {
          let newNode = { value: first, prev: newPrev, next: None }
          let newNodeOpt = Some(newNode)
          let (newNext, newTail, newLength) = fromListInner(
            rest,
            newNodeOpt,
            length + 1
          )
          newNode.next = newNext
          (newNodeOpt, newTail, newLength)
        },
      }
    }

    let (newHead, newTail, newLength) = fromListInner(list, None, 0)
    { length: newLength, head: newHead, tail: newTail }
  }

  /**
   * Converts the input mutable list to an immutable list.
   *
   * @param list: The list to convert
   * @returns The immutable list containing all elements from the mutable list
   *
   * @since v0.6.0
   */
  provide let toList = list => {
    reduceRight((e, l) => [e, ...l], [], list)
  }

  /**
   * Produces a new list by calling a function on each element of
   * the input list and only including it in the result list if the element satisfies
   * the condition.
   *
   * @param fn: The function to call on each element, where the returned value indicates if the element satisfies the condition
   * @param list: The list to iterate
   * @returns The new list containing elements where `fn` returned `true`
   *
   * @since v0.6.0
   */
  provide let filter = (fn, list) => {
    fromList(reduceRight((x, arr) => if (fn(x)) [x, ...arr] else arr, [], list))
  }

  /**
   * Flattens nested lists.
   *
   * @param list: The list to flatten
   * @returns A new list containing all nested list elements combined
   *
   * @example
   * let list1 = List.Mutable.fromList([1, 2])
   * let list2 = List.Mutable.fromList([3, 4])
   * let list = List.Mutable.fromList([list1, list2])
   * assert List.Mutable.flatten(list) == List.Mutable.fromList([1, 2, 3, 4])
   *
   * @since v0.6.0
   */
  provide let flatten = list => {
    let flattened = make()
    forEach(l => append(flattened, l), list)
    flattened
  }

  /**
   * Checks if the value is an element of the input list.
   * Uses the generic `==` structural equality operator.
   *
   * @param search: The value to compare
   * @param list: The list to inspect
   * @returns `true` if the value exists in the list or `false` otherwise
   *
   * @since v0.6.0
   */
  provide let contains = (search, list) => {
    reduce((acc, x) => acc || x == search, false, list)
  }

  /**
   * Checks that the given condition is satisfied for all
   * elements in the input list.
   *
   * @param fn: The function to call on each element, where the returned value indicates if the element satisfies the condition
   * @param list: The list to check
   * @returns `true` if all elements satify the condition or `false` otherwise
   *
   * @since v0.6.0
   */
  provide let every = (fn, list) => {
    reduce((acc, x) => acc && fn(x), true, list)
  }

  /**
   * Checks that the given condition is satisfied **at least
   * once** by an element in the input list.
   *
   * @param fn: The function to call on each element, where the returned value indicates if the element satisfies the condition
   * @param list: The list to iterate
   * @returns `true` if one or more elements satify the condition or `false` otherwise
   *
   * @since v0.6.0
   */
  provide let some = (fn, list) => {
    reduce((acc, x) => acc || fn(x), false, list)
  }

  /**
   * Finds the first element in a list that satifies the given condition.
   *
   * @param fn: The function to call on each element, where the returned value indicates if the element satisfies the condition
   * @param list: The list to search
   * @returns `Some(element)` containing the first value found or `None` otherwise
   *
   * @since v0.6.0
   */
  provide let find = (fn, list) => {
    reduce((acc, x) => if (acc == None && fn(x)) Some(x) else acc, None, list)
  }

  /**
   * Finds the first index in a list where the element satifies the given condition.
   *
   * @param fn: The function to call on each element, where the returned value indicates if the element satisfies the condition
   * @param list: The list to search
   * @returns `Some(index)` containing the index of the first element found or `None` otherwise
   *
   * @since v0.6.0
   */
  provide let findIndex = (fn, list) => {
    let mut i = -1
    reduce((acc, x) => {
      i += 1
      if (acc == None && fn(x)) Some(i) else acc
    }, None, list)
  }

  /**
   * Counts the number of elements in a list that satisfy the given condition.
   *
   * @param fn: The function to call on each element, where the returned value indicates if the element satisfies the condition
   * @param list: The list to iterate
   * @returns The total number of elements that satisfy the condition
   *
   * @since v0.6.0
   */
  provide let count = (fn, list) => {
    reduce((acc, x) => if (fn(x)) acc + 1 else acc, 0, list)
  }

  /**
   * Rotates list elements by the specified amount to the left, such that `n`th
   * element becomes the first in the list.
   *
   * If value is negative, list elements will be rotated by the
   * specified amount to the right. See examples.
   *
   * @param count: The number of elements to rotate by
   * @param list: The list to be rotated
   *
   * @example
   * let list = List.Mutable.fromList([1, 2, 3, 4, 5])
   * List.Mutable.rotate(2, list)
   * assert list == List.Mutable.fromList([3, 4, 5, 1, 2])
   * @example
   * let list = List.Mutable.fromList([1, 2, 3, 4, 5])
   * List.Mutable.rotate(-1, list)
   * assert list == List.Mutable.fromList([5, 1, 2, 3, 4])
   * @example
   * let list = List.Mutable.fromList([1, 2, 3, 4, 5])
   * List.Mutable.rotate(-7, list)
   * assert list == List.Mutable.fromList([4, 5, 1, 2, 3])
   *
   * @since v0.6.0
   */
  provide let rotate = (n, list) => {
    if (list.length > 0) {
      let places = n % list.length
      for (let mut i = 0; i < places; i += 1) {
        match (list.head) {
          Some({ value, _ }) => {
            addLast(value, list)
            removeFirst(list)
          },
          _ => fail "Impossible: rotate list head None on nonempty list",
        }
      }
    }
  }

  /**
   * Produces a new list with any duplicates removed.
   * Uses the generic `==` structural equality operator.
   *
   * @param list: The list to filter
   * @returns The new list with only unique values
   *
   * @since v0.6.0
   */
  provide let unique = list => {
    // TODO(#1651): improve performance
    fromList(unique(toList(list)))
  }

  /**
   * Produces a new list filled with tuples of elements from both given lists.
   * The first tuple will contain the first item of each list, the second tuple
   * will contain the second item of each list, and so on.
   *
   * Calling this function with lists of different sizes will cause the returned
   * list to have the length of the smaller list.
   *
   * @param list1: The list to provide values for the first tuple element
   * @param list2: The list to provide values for the second tuple element
   * @returns The new list containing indexed pairs of `(a, b)`
   *
   * @example
   * let list1 = List.Mutable.fromList([1, 2, 3])
   * let list2 = List.Mutable.fromList([4, 5, 6])
   * assert List.Mutable.zip(list1, list2) == List.Mutable.fromList([(1, 4), (2, 5), (3, 6)])
   * @example
   * let list1 = List.Mutable.fromList([1, 2, 3])
   * let list2 = List.Mutable.fromList([4, 5])
   * assert List.Mutable.zip(list1, list2) == List.Mutable.fromList([(1, 4), (2, 5)])
   *
   * @since v0.6.0
   */
  provide let zip = (list1, list2) => {
    fromList(zip(toList(list1), toList(list2)))
  }

  /**
   * Produces a new list filled with elements defined by applying a function on
   * pairs from both given lists. The first element will contain the result of
   * applying the function to the first elements of each list, the second element
   * will contain the result of applying the function to the second elements of
   * each list, and so on.
   *
   * Calling this function with lists of different sizes will cause the returned
   * list to have the length of the smaller list.
   *
   * @param fn: The function to apply to pairs of elements
   * @param list1: The list whose elements will each be passed to the function as the first argument
   * @param list2: The list whose elements will each be passed to the function as the second argument
   * @returns The new list containing elements derived from applying the function to pairs of input list elements
   *
   * @example
   * let list1 = List.Mutable.fromList([1, 2, 3])
   * let list2 = List.Mutable.fromList([4, 5, 6])
   * assert List.Mutable.zipWith((a, b) => a + b, list1, list2) == List.Mutable.fromList([5, 7, 9])
   * @example
   * let list1 = List.Mutable.fromList([1, 2, 3])
   * let list2 = List.Mutable.fromList([4, 5])
   * assert List.Mutable.zipWith((a, b) => a * b, list1, list2) == List.Mutable.fromList([4, 10])
   *
   * @since v0.6.0
   */
  provide let zipWith = (fn, list1, list2) => {
    fromList(zipWith(fn, toList(list1), toList(list2)))
  }

  /**
   * Produces two lists by splitting apart a list of tuples.
   *
   * @param list: The list of tuples to split
   * @returns An list containing all elements from the first tuple element, and a list containing all elements from the second tuple element
   *
   * @since v0.6.0
   */
  provide let unzip = list => {
    let (list1, list2) = unzip(toList(list))
    (fromList(list1), fromList(list2))
  }

  /**
   * Combines two lists into a Cartesian product of tuples containing
   * all ordered pairs `(a, b)`.
   *
   * @param list1: The list to provide values for the first tuple element
   * @param list2: The list to provide values for the second tuple element
   * @returns The new list containing all pairs of `(a, b)`
   *
   * @since v0.6.0
   */
  provide let product = (list1, list2) => {
    fromList(reduceRight((x1, list) => {
      reduceRight((x2, list) => [(x1, x2), ...list], list, list2)
    }, [], list1))
  }

  /**
   * Provides the subset of a list given zero-based start index and amount of elements
   * to include.
   *
   * @param start: The index of the list where the subset will begin (inclusive)
   * @param length: The amount of elements to be included in the subset
   * @param list: The input list
   * @returns The subset of the list
   *
   * @throws Failure(String): When `start` is negative
   * @throws Failure(String): When `length` is negative
   *
   * @since v0.6.0
   */
  provide let sub = (start, length, list) => {
    fromList(sub(start, length, toList(list)))
  }

  /**
   * Reverses the elements in the list.
   * 
   * @param list: The list to reverse
   * 
   * @since v0.6.0
   */
  provide let reverse = list => {
    let rec reverseInner = node => {
      match (node) {
        None => void,
        Some(node) => {
          let next = node.next
          node.next = node.prev
          node.prev = next
          reverseInner(next)
        },
      }
    }
    reverseInner(list.head)
    let head = list.head
    list.head = list.tail
    list.tail = head
  }

  /**
   * Sorts the list.
   *
   * Ordering is calculated using a comparator function which takes two array elements and must return 0 if both are equal, a positive number if the first is greater, and a negative number if the first is smaller.
   * @param compare: The comparator function used to indicate sort order
   * @param list: The list to be sorted
   * 
   * @since v0.6.0
   */
  provide let sort = (compare=compare, list) => {
    let { head, tail, length } = fromList(sort(compare=compare, toList(list)))
    list.head = head
    list.tail = tail
    list.length = length
  }

  /**
   * Combine the given list of strings into one string with the specified
   * separator inserted between each item.
   *
   * @param separator: The separator to insert between elements
   * @param list: The list to combine
   * @returns The combined elements with the separator between each
   *
   * @since v0.6.0
   */
  provide let join = (separator, list) => {
    // TODO(#728): Improve performance here with buffer approach
    let iter = (acc, str) => {
      match (acc) {
        None => Some(str),
        Some(prev) => Some(prev ++ separator ++ str),
      }
    }
    match (reduce(iter, None, list)) {
      None => "",
      Some(s) => s,
    }
  }

  /**
   * Produces a shallow copy of the input list.
   *
   * @param list: The list to copy
   * @returns The new list containing the elements from the input
   *
   * @since v0.6.0
   */
  provide let copy = list => {
    map(identity, list)
  }

  /**
   * Clears the provided list.
   *
   * @param list: The list to clear
   *
   * @since v0.6.0
   */
  provide let clear = list => {
    list.head = None
    list.tail = None
    list.length = 0
  }
}
