/**
 * @module Queue: An immutable queue implementation. A queue is a FIFO (first-in-first-out) data structure where new values are added to the end and retrieved or removed from the beginning.
 * @example import Queue from "queue"
 * @since v0.2.0
 */
import List from "list"

record Queue<a> { forwards: List<a>, backwards: List<a> }

/**
 * @section Values: Functions for working with queues.
 */

/**
 * Creates an empty queue.
 * 
 * @returns An empty queue
 */
export let make = () => {
  { forwards: [], backwards: [] }
}

/**
 * Checks if the given queue contains any elements.
 * 
 * @param queue: The queue to check
 * @returns `true` if the given queue is empty or `false` otherwise
 */
export let isEmpty = queue => {
  match (queue) {
    { forwards: [], backwards: [] } => true,
    _ => false,
  }
}

/**
 * Returns the element on the top of the queue.
 * 
 * @param queue: The queue to peek into
 * @returns The element on the top of the queue, if the queue is empty it returns `None`
 * @returns `Some(item)` containing the element on the top of the queue, if the queue is empty returns `None`
 */
export let peek = queue => {
  match (queue) {
    { forwards: [], backwards: [] } => None,
    { forwards, backwards } => List.head(forwards),
  }
}

/**
 * Pushes a value to the end of the queue.
 * 
 * @param value: The value to queue
 * @param queue: The queue to append the value too
 * @returns The new queue
 */
export let push = (value, queue) => {
  match (queue) {
    { forwards: [], backwards: [] } => { forwards: [value], backwards: [] },
    { forwards, backwards } => { forwards, backwards: [value, ...backwards] },
  }
}

/**
 * Pops a value off the front of the queue.
 * 
 * @param queue: The queue to pop from
 * @returns The new queue
 */
export let pop = queue => {
  match (queue) {
    { forwards: [], backwards: [] } => queue,
    { forwards: [head], backwards: [] } => { forwards: [], backwards: [] },
    { forwards: [head], backwards } =>
      {
        forwards: List.reverse(backwards),
        backwards: [],
      },
    { forwards: [head, ...ftail], backwards } => { forwards: ftail, backwards },
  }
}

/**
 * Get the length of the provided queue.
 * 
 * @param queue: The queue to determine the size of.
 * @returns The size of the queue
 */
export let size = queue => {
  match (queue) {
    { forwards: [], backwards: [] } => 0,
    { forwards, backwards: [] } => List.length(forwards),
    { forwards: [], backwards } => List.length(backwards),
    { forwards, backwards } => List.length(forwards) + List.length(backwards),
  }
}
