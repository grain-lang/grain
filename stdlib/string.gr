/**
 * Utilities for working with strings.
 *
 * @example from "string" include String
 *
 * @since v0.2.0
 * @history v0.1.0: Originally named `strings`
 * @history v0.2.0: Renamed to `string`
 */
module String

from "char" include Char
from "runtime/unsafe/wasmi32" include WasmI32
from "runtime/unsafe/wasmref" include WasmRef
from "runtime/unsafe/memory" include Memory
from "runtime/exception" include Exception
from "runtime/unsafe/conv" include Conv
from "runtime/dataStructures" include DataStructures
use DataStructures.{
  untagSimpleNumber,
  tagSimpleNumber,
  tagChar,
  untagChar,
  allocateArray,
  allocateString,
  allocateBytes,
  stringSize,
  bytesSize,
  getStringArrayRef,
  getBytesArrayRef,
  getCompoundValueArrayRef,
}
from "runtime/utf8" include Utf8
use Utf8.{
  isLeadingByte,
  utf8ByteCount,
  usvEncodeLength,
  getCodePoint,
  writeUtf8CodePoint,
}
from "runtime/unsafe/tags" include Tags

// Helpers
@unsafe
let convSimpleNumber = (x: Number, err: String) => {
  if (WasmRef.isRefI31(WasmRef.fromGrain(x))) {
    untagSimpleNumber(x)
  } else {
    throw InvalidArgument(err)
  }
}

/**
 * Byte encodings
 */
provide enum Encoding {
  UTF8,
  UTF16_BE,
  UTF16_LE,
  UTF32_BE,
  UTF32_LE,
}

exception MalformedUnicode

/**
 * Concatenate two strings.
 *
 * @param str1: The beginning string
 * @param str2: The ending string
 * @returns The combined string
 *
 * @example String.concat("Foo", "Bar") == "FooBar"
 *
 * @since v0.2.0
 */
provide let concat = (++)

/**
 * Returns the character length of the input string.
 *
 * @param string: The string to inspect
 * @returns The number of characters in the string
 *
 * @example String.length("Hello world") == 11
 *
 * @since v0.1.0
 */
@unsafe
provide let length = (string: String) => {
  use WasmI32.{ (+), ltU as (<) }
  let stringPtr = WasmRef.fromGrain(string)
  let size = stringSize(stringPtr)

  let stringPtr = getStringArrayRef(stringPtr)

  let mut len = 0n

  for (let mut i = 0n; i < size; i += 1n) {
    let byte = WasmRef.arrayI8GetU(stringPtr, i)
    if (isLeadingByte(byte)) len += 1n
  }

  Conv.wasmI32ToNumber(len)
}

/**
 * Returns the byte length of the input string.
 *
 * @param string: The string to inspect
 * @returns The number of bytes in the string
 *
 * @example String.byteLength("ðŸŒ¾") == 4
 *
 * @since v0.1.0
 */
@unsafe
provide let byteLength = (string: String) => {
  let stringPtr = WasmRef.fromGrain(string)
  Conv.wasmI32ToNumber(stringSize(stringPtr))
}

/**
 * Determines if the string contains no characters.
 *
 * @param string: The string to inspect
 * @returns `true` if the string is empty and `false` otherwise
 *
 * @since v0.6.0
 */
@unsafe
provide let isEmpty = (string: String) => {
  use WasmI32.{ (==) }
  let strPtr = WasmRef.fromGrain(string)
  stringSize(strPtr) == 0n
}

/**
 * Finds the first position of a substring in the input string.
 *
 * @param search: The substring to find
 * @param string: The string to inspect
 * @returns `Some(position)` containing the starting position of the substring if found or `None` otherwise
 *
 * @example String.indexOf("world", "Hello world") == Some(6)
 *
 * @since v0.3.0
 */
@unsafe
provide let indexOf = (search: String, string: String) => {
  use WasmI32.{ (+), (-), ltU as (<), gtU as (>), (==) }
  let searchPtr = WasmRef.fromGrain(search)
  let stringPtr = WasmRef.fromGrain(string)

  let size = stringSize(stringPtr)
  let psize = stringSize(searchPtr)

  if (psize > size) {
    return None
  }
  let ptr = getStringArrayRef(stringPtr)
  let pptr = getStringArrayRef(searchPtr)
  let end = size - psize + 1n

  for (let mut i = 0n; i < end;) {
    if (Memory.compareArrayI8(ptr, i, pptr, 0n, psize) == 0n) {
      return Some(tagSimpleNumber(i))
    }
    let byte = WasmRef.arrayI8GetU(ptr, 0n)
    i += utf8ByteCount(byte)
  }

  return None
}

/**
 * Finds the last position of a substring in the input string.
 *
 * @param search: The substring to find
 * @param string: The string to inspect
 * @returns `Some(position)` containing the starting position of the substring if found or `None` otherwise
 *
 * @example String.lastIndexOf("world", "Hello world world") == Some(12)
 *
 * @since v0.5.3
 */
@unsafe
provide let lastIndexOf = (search: String, string: String) => {
  use WasmI32.{ (-), gtU as (>), geU as (>=), (==) }

  let searchPtr = WasmRef.fromGrain(search)
  let stringPtr = WasmRef.fromGrain(string)
  let searchSize = stringSize(searchPtr)
  let stringSize = stringSize(stringPtr)
  if (searchSize > stringSize) {
    return None
  }
  // The last possible index in the string given the length of the search
  let lastIndex = stringSize - searchSize

  let searchPtr = getStringArrayRef(searchPtr)
  let stringPtr = getStringArrayRef(stringPtr)
  for (let mut i = lastIndex; i >= 0n; i -= 1n) {
    let byte = WasmRef.arrayI8GetU(stringPtr, i)
    // We're not at the start of a codepoint, so move on
    if (!isLeadingByte(byte)) continue
    if (Memory.compareArrayI8(stringPtr, i, searchPtr, 0n, searchSize) == 0n) {
      return Some(tagSimpleNumber(i))
    }
  }

  return None
}

@unsafe
let charAtHelp = (position, string: String) => {
  if (length(string) <= position || position < 0) {
    fail "Invalid offset: " ++ toString(position)
  }
  // Implementation is similar to explodeHelp, but doesn't perform unneeded memory allocations
  use WasmI32.{ (+), ltU as (<), (==) }
  let stringPtr = WasmRef.fromGrain(string)
  let size = stringSize(stringPtr)
  let position = untagSimpleNumber(position)
  let mut ptr = getStringArrayRef(stringPtr)
  let mut counter = 0n
  for (let mut i = 0n; i < size;) {
    if (counter == position) {
      return getCodePoint(ptr, i)
    }
    let byte = WasmRef.arrayI8GetU(ptr, i)
    i += utf8ByteCount(byte)
    counter += 1n
  }

  fail "charAt: should be impossible (please report)"
}

/**
 * Get the Unicode code point at the position in the input string.
 *
 * @param position: The position to check
 * @param string: The string to search
 * @returns The character code at the provided position
 *
 * @throws MalformedUnicode: When the `string` is malformed
 * @throws Failure(String): When the `position` is out of bounds
 *
 * @example String.charCodeAt(5, "Hello world") == 32
 *
 * @since v0.5.3
 */
@unsafe
provide let charCodeAt = (position, string: String) => {
  tagSimpleNumber(charAtHelp(position, string))
}

/**
 * Get the character at the position in the input string.
 *
 * @param position: The position to check
 * @param string: The string to search
 * @returns The character at the provided position
 *
 * @throws MalformedUnicode: When the `string` is malformed
 * @throws Failure(String): When the `position` is out of bounds
 *
 * @example String.charAt(5, "Hello world") == ' '
 *
 * @since v0.4.0
 */
@unsafe
provide let charAt = (position, string: String) => {
  tagChar(charAtHelp(position, string))
}

@unsafe
let explodeHelp = (s: String, chars) => {
  use WasmI32.{ (+), ltU as (<), (==) }

  let sPtr = WasmRef.fromGrain(s)
  let size = stringSize(sPtr)
  let len = untagSimpleNumber(length(s))

  let mut ptr = getStringArrayRef(sPtr)
  let mut offset = 0n

  let arr = allocateArray(len, WasmRef.fromGrain(void))
  let mut arrIdx = 0n

  while (offset < size) {
    let byte = WasmRef.arrayI8GetU(ptr, offset)
    let n = utf8ByteCount(byte)

    let c = if (chars) {
      WasmRef.fromGrain(tagChar(getCodePoint(ptr, offset)))
    } else {
      let sPtr = allocateString(n)
      Memory.copyRefArrayI8(getStringArrayRef(sPtr), 0n, ptr, 0n, n)
      sPtr
    }

    WasmRef.arrayAnySet(getCompoundValueArrayRef(arr), arrIdx, c)
    arrIdx += 1n
    offset += n
  }

  arr
}

/**
 * Split a string into its Unicode characters.
 *
 * @param string: The string to split
 * @returns An array containing all characters in the string
 *
 * @throws MalformedUnicode: When the `string` is malformed
 *
 * @example String.explode("Hello") == [> 'H', 'e', 'l', 'l', 'o']
 *
 * @since v0.3.0
 */
@unsafe
provide let explode = string => {
  WasmRef.toGrain(explodeHelp(string, true)): Array<Char>
}

/**
 * Create a string from an array of characters.
 *
 * @param arr: The array to combine
 * @returns A string representation of the array of characters
 *
 * @example String.implode([> 'H', 'e', 'l', 'l', 'o']) == "Hello"
 *
 * @since v0.3.0
 */
@unsafe
provide let implode = (arr: Array<Char>) => {
  use WasmI32.{
    (+),
    (-),
    (*),
    (&),
    (|),
    (<<),
    (>>>),
    ltU as (<),
    gtU as (>),
    leU as (<=),
  }

  let arrLength = WasmRef.arrayLen(
    getCompoundValueArrayRef(WasmRef.fromGrain(arr))
  )

  let mut stringByteLength = 0n

  for (let mut i = 0n; i < arrLength; i += 1n) {
    let usv = untagChar(arr[tagSimpleNumber(i)])
    stringByteLength += usvEncodeLength(usv)
  }

  let str = allocateString(stringByteLength)
  let strArray = getStringArrayRef(str)
  let mut offset = 0n

  for (let mut i = 0n; i < arrLength; i += 1n) {
    let usv = untagChar(arr[tagSimpleNumber(i)])
    offset += writeUtf8CodePoint(strArray, offset, usv)
  }

  WasmRef.toGrain(str): String
}

// Helper to get the length in constant time without depending on Array
primitive arrayLength = "@array.length"

/**
 * Create a string that is the given string reversed.
 *
 * @param string: The string to reverse
 * @returns A string whose characters are in the reverse order of the given string
 *
 * @example String.reverse("olleH") == "Hello"
 *
 * @since v0.4.5
 */
provide let reverse = string => {
  let mut arr = explode(string)
  let len = arrayLength(arr)
  let halfLen = len / 2
  for (let mut i = 0; i < halfLen; i += 1) {
    let lastIdx = len - i - 1
    let last = arr[lastIdx]
    let first = arr[i]
    arr[i] = last
    arr[lastIdx] = first
  }
  implode(arr)
}

/**
 * Split a string by the given separator.
 *
 * @param separator: The separator to split on
 * @param string: The string to split
 * @returns An array of substrings from the initial string
 *
 * @throws MalformedUnicode: When the `string` is malformed
 *
 * @example String.split(" ", "Hello world") == [> "Hello", "world"]
 */
@unsafe
provide let split = (separator: String, string: String) => {
  use WasmI32.{ (+), (-), (&), (<<), ltU as (<), gtU as (>), (==) }

  let stringPtr = WasmRef.fromGrain(string)
  let separatorPtr = WasmRef.fromGrain(separator)
  let size = stringSize(stringPtr)
  let psize = stringSize(separatorPtr)

  if (psize == 0n) {
    WasmRef.toGrain(explodeHelp(string, false)): Array<String>
  } else if (psize > size) {
    [> string]
  } else {
    let stringPtr = getStringArrayRef(stringPtr)
    let mut offset = 0n
    let mut pptr = getStringArrayRef(separatorPtr)
    let end = offset + size - psize + 1n

    let mut numStrings = 1n

    while (offset < end) {
      if (Memory.compareArrayI8(stringPtr, offset, pptr, 0n, psize) == 0n) {
        numStrings += 1n
      }
      let byte = WasmRef.arrayI8GetU(stringPtr, offset)
      offset += utf8ByteCount(byte)
    }

    offset = 0n
    let mut last = 0n
    let arr = allocateArray(numStrings, WasmRef.fromGrain(void))
    let wasmArray = getCompoundValueArrayRef(arr)
    let mut arrIdx = 0n

    while (offset < end) {
      if (Memory.compareArrayI8(stringPtr, offset, pptr, 0n, psize) == 0n) {
        let strSize = offset - last
        let str = allocateString(strSize)
        Memory.copyRefArrayI8(
          getStringArrayRef(str),
          0n,
          stringPtr,
          last,
          strSize
        )
        WasmRef.arrayAnySet(wasmArray, arrIdx, str)
        arrIdx += 1n
        offset += psize
        last = offset
        continue
      }
      let byte = WasmRef.arrayI8GetU(stringPtr, offset)
      offset += utf8ByteCount(byte)
    }

    // Grab last string
    let strSize = size - last
    let lastStr = allocateString(strSize)
    Memory.copyRefArrayI8(
      getStringArrayRef(lastStr),
      0n,
      stringPtr,
      last,
      strSize
    )
    WasmRef.arrayAnySet(wasmArray, arrIdx, lastStr)

    WasmRef.toGrain(arr): Array<String>
  }
}

/**
 * Get a portion of a string.
 *
 * @param start: The start position of the substring
 * @param end: The end position of the substring, exclusive
 * @param string: The input string
 * @returns The substring from the initial string
 *
 * @throws InvalidArgument(String): When the `start` index is not an integer
 * @throws InvalidArgument(String): When the `to` index is not an integer
 * @throws IndexOutOfBounds: When `start` is out of bounds
 * @throws IndexOutOfBounds: When `end` is out of bounds
 * @throws InvalidArgument(String): When `start` is greater than `end`
 *
 * @example String.slice(0, end=5, "Hello world") == "Hello"
 * @example String.slice(0, "Hello world") == "Hello world"
 *
 * @since v0.1.0
 * @history v0.6.0: Default `end` to the String length
 */
@unsafe
provide let slice = (start: Number, end=length(string), string: String) => {
  use WasmI32.{ (+), (-), (<), (>), (==) }

  let stringPtr = WasmRef.fromGrain(string)
  let len = untagSimpleNumber(length(string))
  let size = stringSize(stringPtr)

  let mut start = convSimpleNumber(start, "Invalid start index")
  let mut to = convSimpleNumber(end, "Invalid end index")

  if (start < 0n) {
    start += len
  }
  if (to < 0n) {
    to += len
  }

  if (start > len || to > len) {
    throw IndexOutOfBounds
  }

  if (to < start) {
    throw InvalidArgument("Start index exceeds end index")
  }

  let mut ptr = getStringArrayRef(stringPtr)
  let mut begin = 0n
  let mut end = 0n

  let mut idx = 0n
  for (let mut i = 0n; i < size; i += 1n) {
    let byte = WasmRef.arrayI8GetU(ptr, i)
    if (isLeadingByte(byte)) {
      if (idx == start) {
        begin = i
      }
      if (idx == to) {
        end = i
        break
      }
      idx += 1n
    }
  }
  if (to == len) {
    end = size
  }
  if (start == to) {
    begin = end
  }

  let newSize = end - begin
  let newString = allocateString(newSize)

  Memory.copyRefArrayI8(getStringArrayRef(newString), 0n, ptr, begin, newSize)

  WasmRef.toGrain(newString): String
}

/**
 * Check if a string contains a substring.
 *
 * @param search: The substring to check
 * @param string: The string to search
 * @returns `true` if the input string contains the search value or `false` otherwise
 *
 * @example String.contains("world", "Hello world") == true
 *
 * @since v0.1.0
 */
@unsafe
provide let contains = (search: String, string: String) => {
  // "Not So Naive" string search algorithm
  // searching phase in O(nm) time complexity
  // slightly (by coefficient) sub-linear in the average case
  // http://igm.univ-mlv.fr/~lecroq/string/node13.html#SECTION00130
  use WasmI32.{ (+), (-), ltU as (<), gtU as (>), leU as (<=), (==), (!=) }
  let pOrig = search
  let sOrig = string

  let stringPtr = WasmRef.fromGrain(string)
  let searchPtr = WasmRef.fromGrain(search)

  let n = stringSize(stringPtr)
  let m = stringSize(searchPtr)

  let stringPtr = getStringArrayRef(stringPtr)
  let searchPtr = getStringArrayRef(searchPtr)

  let mut j = 0n
  and k = 0n
  and ell = 0n

  if (m > n) {
    // Bail if pattern length is longer than input length
    return false
  }

  if (m < 2n) {
    // Handle very small patterns
    if (m == 0n) {
      return true
    }

    let pat = WasmRef.arrayI8GetU(searchPtr, 0n)
    while (j < n) {
      if (pat == WasmRef.arrayI8GetU(stringPtr, j)) {
        return true
      } else {
        j += 1n
      }
    }

    return false
  }

  // NSM preprocessing
  if (WasmRef.arrayI8GetU(searchPtr, 0n) == WasmRef.arrayI8GetU(searchPtr, 1n)) {
    k = 2n
    ell = 1n
  } else {
    k = 1n
    ell = 2n
  }

  // NSM searching
  while (j <= n - m) {
    if (
      WasmRef.arrayI8GetU(searchPtr, 1n)
      != WasmRef.arrayI8GetU(stringPtr, j + 1n)
    ) {
      j += k
    } else {
      if (
        Memory.compareArrayI8(searchPtr, 2n, stringPtr, j + 2n, m - 2n) == 0n
        && WasmRef.arrayI8GetU(searchPtr, 0n)
          == WasmRef.arrayI8GetU(stringPtr, j)
      ) {
        return true
      }
      j += ell
    }
  }

  return false
}

/**
 * Check if a string begins with another string.
 *
 * @param search: The string to compare to the start
 * @param string: The string to search
 * @returns `true` if the input string starts with the search value or `false` otherwise
 *
 * @example String.startsWith("Hello", "Hello world") == true
 *
 * @since v0.1.0
 */
@unsafe
provide let startsWith = (search: String, string: String) => {
  use WasmI32.{ (+), gtU as (>), (==) }
  let pOrig = search
  let sOrig = string

  let searchPtr = WasmRef.fromGrain(search)
  let stringPtr = WasmRef.fromGrain(string)

  let n = stringSize(stringPtr)
  let m = stringSize(searchPtr)

  let stringPtr = getStringArrayRef(stringPtr)
  let searchPtr = getStringArrayRef(searchPtr)

  // Bail if pattern length is longer than input length
  if (m > n) {
    false
  } else {
    Memory.compareArrayI8(searchPtr, 0n, stringPtr, 0n, m) == 0n
  }
}

/**
 * Check if a string ends with another string.
 *
 * @param search: The string to compare to the end
 * @param string: The string to search
 * @returns `true` if the input string ends with the search value or `false` otherwise
 *
 * @example String.endsWith("world", "Hello world") == true
 *
 * @since v0.1.0
 */
@unsafe
provide let endsWith = (search: String, string: String) => {
  use WasmI32.{ (+), (-), gtU as (>), (==) }

  let searchPtr = WasmRef.fromGrain(search)
  let stringPtr = WasmRef.fromGrain(string)

  let n = stringSize(stringPtr)
  let m = stringSize(searchPtr)

  let stringPtr = getStringArrayRef(stringPtr)
  let searchPtr = getStringArrayRef(searchPtr)

  // Bail if pattern length is longer than input length
  if (m > n) {
    false
  } else {
    Memory.compareArrayI8(searchPtr, 0n, stringPtr, n - m, m) == 0n
  }
}

/**
 * Replaces the first appearance of the search pattern in the string with the replacement value.
 *
 * @param searchPattern: The string to replace
 * @param replacement: The replacement
 * @param string: The string to change
 * @returns A new string with the first occurrence of the search pattern replaced
 *
 * @example String.replaceFirst("ðŸŒ¾", "ðŸŒŽ", "Hello ðŸŒ¾ðŸŒ¾") == "Hello ðŸŒŽðŸŒ¾"
 *
 * @since v0.5.4
 */
@unsafe
provide let replaceFirst = (
  searchPattern: String,
  replacement: String,
  string: String,
) => {
  use WasmI32.{ (+), (-), gtU as (>), ltU as (<), (==) }

  let patternPtr = WasmRef.fromGrain(searchPattern)
  let stringPtr = WasmRef.fromGrain(string)
  let replacementPtr = WasmRef.fromGrain(replacement)

  let patternLen = stringSize(patternPtr)
  let stringLen = stringSize(stringPtr)
  let replacementLen = stringSize(replacementPtr)
  // Bail if search str is longer than the string
  if (stringLen < patternLen) {
    return string
  }
  let patternPtr = getStringArrayRef(patternPtr)
  let stringPtr = getStringArrayRef(stringPtr)
  let replacementPtr = getStringArrayRef(replacementPtr)

  // Search for an instance of the string
  let mut foundIndex = -1n
  let stringEnd = stringLen - patternLen + 1n
  for (let mut i = 0n; i < stringEnd; i += 1n) {
    // check for match
    foundIndex += 1n
    if (Memory.compareArrayI8(stringPtr, i, patternPtr, 0n, patternLen) == 0n) {
      // Create the new string
      let str = allocateString(stringLen - patternLen + replacementLen)
      let strPtr = getStringArrayRef(str)
      Memory.copyRefArrayI8(strPtr, 0n, stringPtr, 0n, foundIndex)
      Memory.copyRefArrayI8(
        strPtr,
        foundIndex,
        replacementPtr,
        0n,
        replacementLen
      )
      Memory.copyRefArrayI8(
        strPtr,
        foundIndex + replacementLen,
        stringPtr,
        foundIndex + patternLen,
        stringLen - foundIndex
      )
      // Copy over the str
      return WasmRef.toGrain(str): String
    }
  }

  return string
}

/**
 * Replaces the last appearance of the search pattern in the string with the replacement value.
 *
 * @param searchPattern: The string to replace
 * @param replacement: The replacement
 * @param string: The string to change
 * @returns A new string with the last occurrence of the search pattern replaced
 *
 * @example String.replaceLast("ðŸŒ¾", "ðŸŒŽ", "Hello ðŸŒ¾ðŸŒ¾") == "Hello ðŸŒ¾ðŸŒŽ"
 *
 * @since v0.5.4
 */
@unsafe
provide let replaceLast = (
  searchPattern: String,
  replacement: String,
  string: String,
) => {
  use WasmI32.{ (+), (-), geU as (>=), ltU as (<), (==) }

  let patternPtr = WasmRef.fromGrain(searchPattern)
  let stringPtr = WasmRef.fromGrain(string)
  let replacementPtr = WasmRef.fromGrain(replacement)

  let patternLen = stringSize(patternPtr)
  let stringLen = stringSize(stringPtr)
  let replacementLen = stringSize(replacementPtr)

  // Bail if search str is longer than the string
  if (stringLen < patternLen) {
    return string
  }
  let patternPtr = getStringArrayRef(patternPtr)
  let stringPtr = getStringArrayRef(stringPtr)
  let replacementPtr = getStringArrayRef(replacementPtr)

  let mut found = false
  // Search for an instance of the string
  let stringEnd = stringLen - patternLen
  let mut foundIndex = stringLen - patternLen + 1n
  for (let mut i = stringEnd; i >= 0n; i -= 1n) {
    // check for match
    foundIndex -= 1n
    if (Memory.compareArrayI8(stringPtr, i, patternPtr, 0n, patternLen) == 0n) {
      // Create the new string
      let str = allocateString(stringLen - patternLen + replacementLen)
      let strPtr = getStringArrayRef(str)
      Memory.copyRefArrayI8(strPtr, 0n, stringPtr, 0n, foundIndex)
      Memory.copyRefArrayI8(
        strPtr,
        foundIndex,
        replacementPtr,
        0n,
        replacementLen
      )
      Memory.copyRefArrayI8(
        strPtr,
        foundIndex + replacementLen,
        stringPtr,
        foundIndex + patternLen,
        stringLen - foundIndex
      )
      // Copy over the str
      return WasmRef.toGrain(str): String
    }
  }

  return string
}

/**
 * Replaces every appearance of the search pattern in the string with the replacement value.
 *
 * @param searchPattern: The string to replace
 * @param replacement: The replacement
 * @param string: The string to change
 * @returns A new string with each occurrence of the search pattern replaced
 *
 * @example String.replaceAll("ðŸŒ¾", "ðŸŒŽ", "Hello ðŸŒ¾ðŸŒ¾") == "Hello ðŸŒŽðŸŒŽ"
 *
 * @since v0.5.4
 */
@unsafe
provide let replaceAll = (
  searchPattern: String,
  replacement: String,
  string: String,
) => {
  use WasmI32.{ (+), (-), (*), geU as (>=), ltU as (<), (==) }

  let patternPtr = WasmRef.fromGrain(searchPattern)
  let stringPtr = WasmRef.fromGrain(string)
  let replacementPtr = WasmRef.fromGrain(replacement)

  let patternLen = stringSize(patternPtr)
  let stringLen = stringSize(stringPtr)
  let replacementLen = stringSize(replacementPtr)

  // Bail if search str is longer than the string
  if (stringLen < patternLen) {
    string
  } else {
    let patternPtr = getStringArrayRef(patternPtr)
    let stringPtr = getStringArrayRef(stringPtr)
    let replacementPtr = getStringArrayRef(replacementPtr)

    let mut found = false
    // Search for an instance of the string
    let stringEnd = stringLen - patternLen
    let mut foundIndex = stringLen - patternLen + 1n
    let mut foundIndexes = []
    let mut foundCount = 0n
    for (let mut i = stringEnd; i >= 0n; i -= 1n) {
      // check for match
      foundIndex -= 1n
      if (Memory.compareArrayI8(stringPtr, i, patternPtr, 0n, patternLen) == 0n) {
        found = true
        foundCount += 1n
        foundIndexes = [tagSimpleNumber(foundIndex), ...foundIndexes]
        foundIndex -= patternLen - 1n
        i -= patternLen - 1n
      }
    }
    if (found) {
      // Create the new string
      let str = allocateString(
        stringLen - (patternLen - replacementLen) * foundCount
      )
      let strPtr = getStringArrayRef(str)
      let mut strOffset = 0n
      let mut lastIndex = 0n
      while (true) {
        match (foundIndexes) {
          [idx, ...rest] => {
            let index = untagSimpleNumber(idx)
            // Copy the part before
            Memory.copyRefArrayI8(
              strPtr,
              strOffset,
              stringPtr,
              lastIndex,
              index - lastIndex
            )
            strOffset += index - lastIndex
            // Copy the part after
            Memory.copyRefArrayI8(
              strPtr,
              strOffset,
              replacementPtr,
              0n,
              replacementLen
            )
            strOffset += replacementLen
            lastIndex = index + patternLen
            foundIndexes = rest
          },
          [] => break,
        }
      }
      // Copy remaining string
      Memory.copyRefArrayI8(
        strPtr,
        strOffset,
        stringPtr,
        lastIndex,
        stringLen - lastIndex
      )
      WasmRef.toGrain(str): String
    } else {
      string
    }
  }
}

// String->Byte encoding and helper functions:

let _START_NAME = "start"
let _SIZE_NAME = "size"
let _OFFSET_NAME = "offset"

@unsafe
let grainToWasmNumber = (num, name) => {
  use WasmI32.{ (<) }
  let _num = convSimpleNumber(num, name ++ " argument must be an integer")
  if (_num < 0n) {
    throw InvalidArgument(name ++ " argument must be non-negative")
  }
  _num
}

@unsafe
let utf16Length = (s: String) => {
  use WasmI32.{ (+), (<<), ltU as (<), (==) }

  let sPtr = WasmRef.fromGrain(s)
  let size = stringSize(sPtr)
  let len = untagSimpleNumber(length(s))

  let ptr = getStringArrayRef(sPtr)
  let mut count = 0n // <- number of UTF-16 code words

  for (let mut i = 0n; i < size;) {
    let byte = WasmRef.arrayI8GetU(ptr, i)
    let n = utf8ByteCount(byte)
    if (n == 4n) {
      count += 2n
    } else {
      count += 1n
    }
    i += n
  }

  // multiply by two to get number of bytes
  tagSimpleNumber(count << 1n)
}

let encodedLength = (s: String, encoding) => {
  match (encoding) {
    UTF32_BE => length(s) * 4,
    UTF32_LE => length(s) * 4,
    UTF16_BE => utf16Length(s),
    UTF16_LE => utf16Length(s),
    UTF8 => byteLength(s),
  }
}

@unsafe
let encodeAtHelp = (
  string: String,
  encoding: Encoding,
  includeBom: Bool,
  dest: Bytes,
  destPos: Number,
) => {
  use WasmI32.{ (+), (-), (&), (>>>), ltU as (<), (>), leU as (<=), (==) }
  let stringPtr = WasmRef.fromGrain(string)
  let byteSize = stringSize(stringPtr)
  let len = untagSimpleNumber(length(string))

  let ptr = getStringArrayRef(stringPtr)

  let bytes = WasmRef.fromGrain(dest)
  let destSize = bytesSize(bytes)
  let bytes = getBytesArrayRef(bytes)
  let mut bytesIdx = grainToWasmNumber(destPos, _OFFSET_NAME)

  if (includeBom) {
    match (encoding) {
      UTF8 => {
        if (bytesIdx + 3n > destSize) {
          throw IndexOutOfBounds
        }
        WasmRef.arrayI8Set(bytes, bytesIdx, 0xEFn)
        WasmRef.arrayI8Set(bytes, bytesIdx + 1n, 0xBBn)
        WasmRef.arrayI8Set(bytes, bytesIdx + 2n, 0xBFn)
        bytesIdx += 3n
      },
      UTF16_BE => {
        if (bytesIdx + 2n > destSize) {
          throw IndexOutOfBounds
        }
        WasmRef.arrayI8Set(bytes, bytesIdx, 0xFEn)
        WasmRef.arrayI8Set(bytes, bytesIdx + 1n, 0xFFn)
        bytesIdx += 2n
      },
      UTF16_LE => {
        if (bytesIdx + 2n > destSize) {
          throw IndexOutOfBounds
        }
        WasmRef.arrayI8Set(bytes, bytesIdx, 0xFFn)
        WasmRef.arrayI8Set(bytes, bytesIdx + 1n, 0xFEn)
        bytesIdx += 2n
      },
      UTF32_BE => {
        if (bytesIdx + 4n > destSize) {
          throw IndexOutOfBounds
        }
        WasmRef.arrayI8Set(bytes, bytesIdx, 0n)
        WasmRef.arrayI8Set(bytes, bytesIdx + 1n, 0n)
        WasmRef.arrayI8Set(bytes, bytesIdx + 2n, 0xFEn)
        WasmRef.arrayI8Set(bytes, bytesIdx + 3n, 0xFFn)
        bytesIdx += 4n
      },
      UTF32_LE => {
        if (bytesIdx + 4n > destSize) {
          throw IndexOutOfBounds
        }
        WasmRef.arrayI8Set(bytes, bytesIdx, 0xFFn)
        WasmRef.arrayI8Set(bytes, bytesIdx + 1n, 0xFEn)
        WasmRef.arrayI8Set(bytes, bytesIdx + 2n, 0n)
        WasmRef.arrayI8Set(bytes, bytesIdx + 3n, 0n)
        bytesIdx += 4n
      },
    }
  }

  match (encoding) {
    UTF8 => {
      // Optimization: since internally strings in Grain are UTF8 encoded, when
      // the target encoding is UTF8 as well, then copy the entire memory range
      // in bulk. No need to iterate individual characters.
      if (bytesIdx + byteSize > destSize) {
        throw IndexOutOfBounds
      }
      Memory.copyRefArrayI8(bytes, bytesIdx, ptr, 0n, byteSize)
    },
    _ => {
      for (let mut i = 0n; i < byteSize;) {
        let byte = WasmRef.arrayI8GetU(ptr, i)
        // number of bytes spanning this UTF-8-encoded scalar value
        let n = utf8ByteCount(byte)
        match (encoding) {
          UTF8 => {
            // With the optimization above for bulk memory copy, this match
            // should never occur for the UTF8 case.
            if (bytesIdx + n > destSize) {
              throw IndexOutOfBounds
            }
            Memory.copyRefArrayI8(bytes, bytesIdx, ptr, i, n)
            bytesIdx += n
          },
          UTF16_BE => {
            let codePoint = getCodePoint(ptr, i)
            if (codePoint <= 0xFFFFn) {
              // <hi><lo>
              if (bytesIdx + 2n > destSize) {
                throw IndexOutOfBounds
              }
              WasmRef.arrayI8Set(bytes, bytesIdx, (codePoint & 0xff00n) >>> 8n)
              WasmRef.arrayI8Set(bytes, bytesIdx + 1n, codePoint & 0xffn)
              bytesIdx += 2n
            } else {
              // https://en.wikipedia.org/wiki/UTF-16#Code_points_from_U+010000_to_U+10FFFF
              if (bytesIdx + 4n > destSize) {
                throw IndexOutOfBounds
              }
              let uPrime = codePoint - 0x10000n
              let w1 = ((uPrime & 0b11111111110000000000n) >>> 10n) + 0xD800n // High surrogate
              let w2 = (uPrime & 0b00000000001111111111n) + 0xDC00n // Low surrogate
              WasmRef.arrayI8Set(bytes, bytesIdx, (w1 & 0xff00n) >>> 8n)
              WasmRef.arrayI8Set(bytes, bytesIdx + 1n, w1 & 0xffn)
              WasmRef.arrayI8Set(bytes, bytesIdx + 2n, (w2 & 0xff00n) >>> 8n)
              WasmRef.arrayI8Set(bytes, bytesIdx + 3n, w2 & 0xffn)
              bytesIdx += 4n
            }
          },
          UTF16_LE => {
            let codePoint = getCodePoint(ptr, i)
            if (codePoint <= 0xFFFFn) {
              if (bytesIdx + 2n > destSize) {
                throw IndexOutOfBounds
              }
              // <lo><hi>
              WasmRef.arrayI8Set(bytes, bytesIdx, codePoint & 0xffn)
              WasmRef.arrayI8Set(
                bytes,
                bytesIdx + 1n,
                (codePoint & 0xff00n) >>> 8n
              )
              bytesIdx += 2n
            } else {
              // https://en.wikipedia.org/wiki/UTF-16#Code_points_from_U+010000_to_U+10FFFF
              if (bytesIdx + 4n > destSize) {
                throw IndexOutOfBounds
              }
              let uPrime = codePoint - 0x10000n
              let w1 = ((uPrime & 0b11111111110000000000n) >>> 10n) + 0xD800n // High surrogate
              let w2 = (uPrime & 0b00000000001111111111n) + 0xDC00n // Low surrogate
              WasmRef.arrayI8Set(bytes, bytesIdx, w1 & 0xffn)
              WasmRef.arrayI8Set(bytes, bytesIdx + 1n, (w1 & 0xff00n) >>> 8n)
              WasmRef.arrayI8Set(bytes, bytesIdx + 2n, w2 & 0xffn)
              WasmRef.arrayI8Set(bytes, bytesIdx + 3n, (w2 & 0xff00n) >>> 8n)
              bytesIdx += 4n
            }
          },
          UTF32_BE => {
            if (bytesIdx + 4n > destSize) {
              throw IndexOutOfBounds
            }
            let codePoint = getCodePoint(ptr, i)
            WasmRef.arrayI8Set(
              bytes,
              bytesIdx,
              (codePoint & 0xff000000n) >>> 24n
            )
            WasmRef.arrayI8Set(
              bytes,
              bytesIdx + 1n,
              (codePoint & 0xff0000n) >>> 16n
            )
            WasmRef.arrayI8Set(
              bytes,
              bytesIdx + 2n,
              (codePoint & 0xff00n) >>> 8n
            )
            WasmRef.arrayI8Set(bytes, bytesIdx + 3n, codePoint & 0xffn)
            bytesIdx += 4n
          },
          UTF32_LE => {
            if (bytesIdx + 4n > destSize) {
              throw IndexOutOfBounds
            }
            let codePoint = getCodePoint(ptr, i)
            WasmRef.arrayI8Set(bytes, bytesIdx, codePoint & 0xffn)
            WasmRef.arrayI8Set(
              bytes,
              bytesIdx + 1n,
              (codePoint & 0xff00n) >>> 8n
            )
            WasmRef.arrayI8Set(
              bytes,
              bytesIdx + 2n,
              (codePoint & 0xff0000n) >>> 16n
            )
            WasmRef.arrayI8Set(
              bytes,
              bytesIdx + 3n,
              (codePoint & 0xff000000n) >>> 24n
            )
            bytesIdx += 4n
          },
        }
        i += n
      }
    },
  }

  dest
}

/**
 * Encodes the given string into a byte sequence at the supplied position using the encoding scheme provided.
 *
 * @param string: The input string
 * @param encoding: The encoding to use
 * @param dest: The byte sequence that will be copied
 * @param destPos: The location in the byte sequence to write the output
 * @param includeBom: Whether or not to include a byte order marker (false by default)
 * @returns A copy of the input bytes with the encoded string replaced at the given position
 *
 * @throws InvalidArgument(String): When `destPos` is not an integer
 * @throws InvalidArgument(String): When `destPos` is negative
 *
 * @since v0.4.0
 * @history v0.6.0: Added `includeBom` default argument
 */
provide let encodeAt = (string, encoding, dest, destPos, includeBom=false) => {
  encodeAtHelp(string, encoding, includeBom, dest, destPos)
}

@unsafe
let encodeHelp = (string: String, encoding: Encoding, includeBom: Bool) => {
  let size = encodedLength(string, encoding) + (if (includeBom) {
    match (encoding) {
      UTF8 => 3,
      UTF16_LE => 2,
      UTF16_BE => 2,
      UTF32_LE => 4,
      UTF32_BE => 4,
    }
  } else {
    0
  })
  let bytes = WasmRef.toGrain(allocateBytes(untagSimpleNumber(size)))
  encodeAtHelp(string, encoding, includeBom, bytes, 0)
}

/**
 * Encodes the given string using the given encoding scheme.
 *
 * @param string: The input string
 * @param encoding: The encoding to use
 * @param includeBom: Whether or not to include a byte order marker (false by default)
 * @returns The byte representation of the string in the given encoding
 *
 * @since v0.4.0
 * @history v0.6.0: Added `includeBom` default argument
 */
provide let encode = (string: String, encoding: Encoding, includeBom=false) => {
  encodeHelp(string, encoding, includeBom)
}

// Byte->String decoding and helper functions:

@unsafe
let bytesHaveBom = (bytes: Bytes, encoding: Encoding, start: WasmI32) => {
  use WasmI32.{ (+), geU as (>=), (==) }
  let ptr = WasmRef.fromGrain(bytes)
  let bytesSize = bytesSize(ptr)
  let ptr = getBytesArrayRef(ptr)
  match (encoding) {
    UTF8 => {
      bytesSize >= 3n
        && WasmRef.arrayI8GetU(ptr, start) == 0xEFn
        && WasmRef.arrayI8GetU(ptr, start + 1n) == 0xBBn
        && WasmRef.arrayI8GetU(ptr, start + 2n) == 0xBFn
    },
    UTF16_BE => {
      bytesSize >= 2n
        && WasmRef.arrayI8GetU(ptr, start) == 0xFEn
        && WasmRef.arrayI8GetU(ptr, start + 1n) == 0xFFn
    },
    UTF16_LE => {
      bytesSize >= 2n
        && WasmRef.arrayI8GetU(ptr, start) == 0xFFn
        && WasmRef.arrayI8GetU(ptr, start + 1n) == 0xFEn
    },
    UTF32_BE => {
      bytesSize >= 4n
        && WasmRef.arrayI8GetU(ptr, start) == 0x00n
        && WasmRef.arrayI8GetU(ptr, start + 1n) == 0x00n
        && WasmRef.arrayI8GetU(ptr, start + 2n) == 0xFEn
        && WasmRef.arrayI8GetU(ptr, start + 3n) == 0xFFn
    },
    UTF32_LE => {
      bytesSize >= 4n
        && WasmRef.arrayI8GetU(ptr, start) == 0xFFn
        && WasmRef.arrayI8GetU(ptr, start + 1n) == 0xFEn
        && WasmRef.arrayI8GetU(ptr, start + 2n) == 0x00n
        && WasmRef.arrayI8GetU(ptr, start + 3n) == 0x00n
    },
  }
}

@unsafe
let decodedLength = (
  bytes: Bytes,
  encoding: Encoding,
  start: WasmI32,
  size: WasmI32,
) => {
  use WasmI32.{
    (+),
    (-),
    (&),
    (|),
    (>>>),
    (<<),
    ltU as (<),
    gtU as (>),
    geU as (>=),
    leU as (<=),
    (==),
    (!=),
  }
  let ptr = WasmRef.fromGrain(bytes)
  let bytesSize = {
    let tmp = bytesSize(ptr) - start
    if (size < tmp) {
      size
    } else {
      tmp
    }
  }
  let ptr = getBytesArrayRef(ptr)
  match (encoding) {
    UTF8 => bytesSize,
    UTF16_BE => {
      let mut count = 0n
      for (let mut i = start; i < bytesSize;) {
        let codeWord = WasmRef.arrayI8GetU(ptr, i) << 8n
          | WasmRef.arrayI8GetU(ptr, i + 1n)
        let codeWord = if (codeWord >= 0xD800n && codeWord <= 0xDBFFn) {
          // high surrogate. need to check that next character is low srurrogate
          let ret = if (i + 2n >= bytesSize) {
            throw MalformedUnicode
          } else {
            let nextCodeWord = WasmRef.arrayI8GetU(ptr, i + 2n) << 8n
              | WasmRef.arrayI8GetU(ptr, i + 3n)
            if (nextCodeWord < 0xDC00n || nextCodeWord > 0xDFFFn) {
              // high surrogate without low surrogate
              throw MalformedUnicode
            } else {
              let w1 = (codeWord & 0x03FFn) << 10n
              let w2 = nextCodeWord & 0x03FFn
              w1 + w2 + 0x10000n
            }
          }
          // no problems, so go past both code words
          i += 4n
          ret
        } else {
          i += 2n
          codeWord
        }
        count += usvEncodeLength(codeWord)
      }
      count
    },
    UTF16_LE => {
      let mut count = 0n
      for (let mut i = start; i < bytesSize;) {
        let codeWord = WasmRef.arrayI8GetU(ptr, i + 1n) << 8n
          | WasmRef.arrayI8GetU(ptr, i)
        let codeWord = if (codeWord >= 0xD800n && codeWord <= 0xDBFFn) {
          // high surrogate. need to check that next character is low srurrogate
          let ret = if (i + 2n >= bytesSize) {
            throw MalformedUnicode
          } else {
            let nextCodeWord = WasmRef.arrayI8GetU(ptr, i + 3n) << 8n
              | WasmRef.arrayI8GetU(ptr, i + 2n)
            if (nextCodeWord < 0xDC00n || nextCodeWord > 0xDFFFn) {
              // high surrogate without low surrogate
              throw MalformedUnicode
            } else {
              let w1 = (codeWord & 0x03FFn) << 10n
              let w2 = nextCodeWord & 0x03FFn
              w1 + w2 + 0x10000n
            }
          }
          // no problems, so go past both code words
          i += 4n
          ret
        } else {
          i += 2n
          codeWord
        }
        count += usvEncodeLength(codeWord)
      }
      count
    },
    UTF32_BE => {
      // if not divisible by four, not proper UTF-32 sequence
      if ((bytesSize & 0b11n) != 0n) {
        throw MalformedUnicode
      }
      let mut count = 0n
      for (let mut i = start; i < bytesSize;) {
        let codeWord = WasmRef.arrayI8GetU(ptr, i) << 24n
          | WasmRef.arrayI8GetU(ptr, i + 1n) << 16n
          | WasmRef.arrayI8GetU(ptr, i + 2n) << 8n
          | WasmRef.arrayI8GetU(ptr, i + 3n)
        i += 4n
        count += usvEncodeLength(codeWord)
      }
      count
    },
    UTF32_LE => {
      // if not divisible by four, not proper UTF-32 sequence
      if ((bytesSize & 0b11n) != 0n) {
        throw MalformedUnicode
      }
      let end = start + bytesSize
      let mut ptr = start
      let mut count = 0n
      while (ptr < end) {
        let codeWord = WasmI32.load8U(ptr, 3n) << 24n
          | WasmI32.load8U(ptr, 2n) << 16n
          | WasmI32.load8U(ptr, 1n) << 8n
          | WasmI32.load8U(ptr, 0n)
        ptr += 4n
        count += usvEncodeLength(codeWord)
      }
      count
    },
  }
}

@unsafe
let decodeRangeHelp = (
  bytes: Bytes,
  encoding: Encoding,
  skipBom: Bool,
  start: Number,
  size: Number,
) => {
  use WasmI32.{
    (+),
    (-),
    (&),
    (|),
    (>>>),
    (<<),
    ltU as (<),
    geU as (>=),
    leU as (<=),
    (==),
  }
  let start = grainToWasmNumber(start, _START_NAME)
  let size = grainToWasmNumber(size, _SIZE_NAME)
  let hasBom = bytesHaveBom(bytes, encoding, start)
  let stringSize = decodedLength(bytes, encoding, start, size)
  let stringSize = if (skipBom && hasBom) stringSize - 3n else stringSize
  let str = allocateString(stringSize)
  let mut bytesPtr = WasmRef.fromGrain(bytes)
  let bytesSize = {
    let tmp = WasmI32.load(bytesPtr, _BYTES_LEN_OFFSET) - start
    if (size < tmp) {
      size
    } else {
      tmp
    }
  }
  bytesPtr += _BYTES_DATA_OFFSET + start
  let mut strPtr = str + _STR_DATA_OFFSET
  let mut bomRead = false
  if (skipBom && hasBom) {
    bytesPtr += match (encoding) {
      UTF8 => 3n,
      UTF16_LE => 2n,
      UTF16_BE => 2n,
      UTF32_LE => 4n,
      UTF32_BE => 4n,
    }
  }
  let result = if (stringSize == 0n) {
    WasmRef.toGrain(str): String
  } else {
    match (encoding) {
      UTF8 => {
        Memory.copy(strPtr, bytesPtr, stringSize)
      },
      UTF16_BE => {
        // NOTE: Because the size check passed, we know the string is well-formed
        let end = bytesPtr + bytesSize
        while (bytesPtr < end) {
          let w1 = WasmI32.load8U(bytesPtr, 0n) << 8n
            | WasmI32.load8U(bytesPtr, 1n)
          let codeWord = if (w1 >= 0xD800n && w1 <= 0xDBFFn) {
            // high surrogate. next character is low srurrogate
            let w1 = (w1 & 0x03FFn) << 10n
            let w2 = (
              WasmI32.load8U(bytesPtr, 2n) << 8n
              | WasmI32.load8U(bytesPtr, 3n)
            )
              & 0x03FFn
            let codeWord = w1 + w2 + 0x10000n
            // no problems, so go past both code words
            bytesPtr += 4n
            codeWord
          } else {
            bytesPtr += 2n
            w1
          }
          strPtr += writeUtf8CodePoint(strPtr, codeWord)
        }
      },
      UTF16_LE => {
        // NOTE: Because the size check passed, we know the string is well-formed
        let end = bytesPtr + bytesSize
        while (bytesPtr < end) {
          let w1 = WasmI32.load8U(bytesPtr, 1n) << 8n
            | WasmI32.load8U(bytesPtr, 0n)
          let codeWord = if (w1 >= 0xD800n && w1 <= 0xDBFFn) {
            // high surrogate. next character is low srurrogate
            let w1 = (w1 & 0x03FFn) << 10n
            let w2 = (
              WasmI32.load8U(bytesPtr, 3n) << 8n
              | WasmI32.load8U(bytesPtr, 2n)
            )
              & 0x03FFn
            //let uPrime = codePoint - 0x10000n
            //let w1 = ((uPrime & 0b11111111110000000000n) >>> 10n) + 0xD800n // High surrogate
            //let w2 = (uPrime & 0b00000000001111111111n) + 0xDC00n // Low surrogate
            let codeWord = w1 + w2 + 0x10000n
            // no problems, so go past both code words
            bytesPtr += 4n
            codeWord
          } else {
            bytesPtr += 2n
            w1
          }
          strPtr += writeUtf8CodePoint(strPtr, codeWord)
        }
      },
      UTF32_BE => {
        let end = bytesPtr + bytesSize
        while (bytesPtr < end) {
          let codeWord = WasmI32.load8U(bytesPtr, 0n) << 24n
            | WasmI32.load8U(bytesPtr, 1n) << 16n
            | WasmI32.load8U(bytesPtr, 2n) << 8n
            | WasmI32.load8U(bytesPtr, 3n)
          bytesPtr += 4n
          strPtr += writeUtf8CodePoint(strPtr, codeWord)
        }
      },
      UTF32_LE => {
        let end = bytesPtr + bytesSize
        while (bytesPtr < end) {
          let codeWord = WasmI32.load8U(bytesPtr, 3n) << 24n
            | WasmI32.load8U(bytesPtr, 2n) << 16n
            | WasmI32.load8U(bytesPtr, 1n) << 8n
            | WasmI32.load8U(bytesPtr, 0n)
          bytesPtr += 4n
          strPtr += writeUtf8CodePoint(strPtr, codeWord)
        }
      },
    }
    WasmRef.toGrain(str): String
  }

  ignore(bytes)

  result
}

/**
 * Decodes the given byte sequence of the specified range into a string using the encoding scheme provided.
 *
 * @param bytes: The input bytes
 * @param encoding: The encoding to use
 * @param start: The byte offset to begin decoding from
 * @param size: The maximum number of bytes to decode
 * @param keepBom: Whether or not to include a byte order marker (false by default)
 * @returns The decoded string
 *
 * @throws InvalidArgument(String): When `start` is not an integer
 * @throws InvalidArgument(String): When `start` is negative
 * @throws InvalidArgument(String): When `size` is not an integer
 * @throws InvalidArgument(String): When `size` is negative
 *
 * @since v0.4.0
 * @history v0.6.0: Added `keepBom` default argument
 */
provide let decodeRange = (
  bytes: Bytes,
  encoding: Encoding,
  start: Number,
  size: Number,
  keepBom=false,
) => {
  decodeRangeHelp(bytes, encoding, !keepBom, start, size)
}

@unsafe
let decodeHelp = (bytes: Bytes, encoding: Encoding, skipBom: Bool) => {
  let bytesPtr = WasmRef.fromGrain(bytes)
  let bytesSize = WasmI32.load(bytesPtr, 4n)
  let result = decodeRangeHelp(
    bytes,
    encoding,
    skipBom,
    0,
    tagSimpleNumber(bytesSize)
  )
  ignore(bytes)
  result
}

/**
 * Decodes the given byte sequence into a string using the given encoding scheme.
 *
 * @param bytes: The input bytes
 * @param encoding: The encoding to use
 * @param keepBom: Whether or not to include a byte order marker (false by default)
 * @returns The decoded string
 *
 * @since v0.4.0
 * @history v0.6.0: Added `keepBom` default argument
 */
provide let decode = (bytes: Bytes, encoding: Encoding, keepBom=false) => {
  decodeHelp(bytes, encoding, !keepBom)
}

/**
 * Iterates over Unicode code points in a string.
 *
 * @param fn: The iterator function
 * @param str: The string to iterate
 *
 * @example String.forEachCodePoint(print, "Hello world")
 *
 * @since v0.4.0
 */
@unsafe
provide let forEachCodePoint = (fn: Number => Void, str: String) => {
  use WasmI32.{ (+), ltU as (<) }

  let strPtr = WasmRef.fromGrain(str)

  let byteSize = rawByteLength(strPtr)

  let mut ptr = strPtr + _STR_DATA_OFFSET
  let end = ptr + byteSize

  while (ptr < end) {
    let byte = WasmI32.load8U(ptr, 0n)
    let codePointByteCount = utf8ByteCount(byte)

    // Note that even if up to 4 bytes are needed to represent Unicode
    // codepoints, this doesn't mean 32 bits. The highest allowed code point is
    // 0x10FFFF and it should not change in future versions of Unicode. This
    // means no more than 21 bits are necessary to represent a code point and
    // thus we can use Grain's "simple" numbers that hold up to 31 bits and
    // avoid heap allocations. `getCodePoint` will throw
    // MalformedUnicode exception for values exceeding this limit.
    let codePoint = getCodePoint(ptr)
    fn(tagSimpleNumber(codePoint))

    ptr += codePointByteCount
  }

  ignore(str)

  void
}

/**
 * Iterates over Unicode code points in a string. This is the same as
 * `forEachCodePoint`, but provides the code point's index in the string
 * as the second argument to the iterator function.
 *
 * @param fn: The iterator function
 * @param str: The string to iterate
 *
 * @example String.forEachCodePointi((codepoint, index) => print((codepoint, index)), "Hello world")
 *
 * @since v0.4.0
 */
@unsafe
provide let forEachCodePointi = (fn: (Number, Number) => Void, str: String) => {
  use WasmI32.{ (+), ltU as (<), (==) }

  let strPtr = WasmRef.fromGrain(str)

  let byteSize = rawByteLength(strPtr)

  let mut ptr = strPtr + _STR_DATA_OFFSET
  let end = ptr + byteSize

  let mut idx = 0n
  while (ptr < end) {
    let byte = WasmI32.load8U(ptr, 0n)
    let codePointByteCount = utf8ByteCount(byte)

    // Note that even if up to 4 bytes are needed to represent Unicode
    // codepoints, this doesn't mean 32 bits. The highest allowed code point is
    // 0x10FFFF and it should not change in future versions of Unicode. This
    // means no more than 21 bits are necessary to represent a code point and
    // thus we can use Grain's "simple" numbers that hold up to 31 bits and
    // avoid heap allocations. `getCodePoint` will throw
    // MalformedUnicode exception for values exceeding this limit.
    let codePoint = getCodePoint(ptr)
    fn(tagSimpleNumber(codePoint), tagSimpleNumber(idx))

    ptr += codePointByteCount
    idx += 1n
  }

  ignore(str)

  void
}

/**
 * Iterates over Unicode characters in a string.
 *
 * @param fn: The iterator function
 * @param str: The string to iterate
 *
 * @example String.forEachChar(print, "Hello world")
 *
 * @since v0.6.5
 */
@unsafe
provide let forEachChar = (fn: Char => Void, str: String) => {
  use WasmI32.{ (+), ltU as (<), (==) }

  let strPtr = WasmRef.fromGrain(str)

  let byteSize = rawByteLength(strPtr)

  let mut ptr = strPtr + _STR_DATA_OFFSET
  let end = ptr + byteSize

  while (ptr < end) {
    let byte = WasmI32.load8U(ptr, 0n)
    let codePointByteCount = utf8ByteCount(byte)

    // Note that even if up to 4 bytes are needed to represent Unicode
    // codepoints, this doesn't mean 32 bits. The highest allowed code point is
    // 0x10FFFF and it should not change in future versions of Unicode. This
    // means no more than 21 bits are necessary to represent a code point and
    // thus we can use Grain's "simple" numbers that hold up to 31 bits and
    // avoid heap allocations. `getCodePoint` will throw
    // MalformedUnicode exception for values exceeding this limit.
    let codePoint = getCodePoint(ptr)
    fn(tagChar(codePoint))

    ptr += codePointByteCount
  }
  void
}

/**
 * Iterates over Unicode characters in a string. This is the same as
 * `forEachChar`, but provides the characters's index in the string
 * as the second argument to the iterator function.
 *
 * @param fn: The iterator function
 * @param str: The string to iterate
 *
 * @example String.forEachChari((char, index) => print((char, index)), "Hello world")
 *
 * @since v0.6.5
 */
@unsafe
provide let forEachChari = (fn: (Char, Number) => Void, str: String) => {
  use WasmI32.{ (+), ltU as (<), (==) }

  let strPtr = WasmRef.fromGrain(str)

  let byteSize = rawByteLength(strPtr)

  let mut ptr = strPtr + _STR_DATA_OFFSET
  let end = ptr + byteSize

  let mut idx = 0n
  while (ptr < end) {
    let byte = WasmI32.load8U(ptr, 0n)
    let codePointByteCount = utf8ByteCount(byte)

    // Note that even if up to 4 bytes are needed to represent Unicode
    // codepoints, this doesn't mean 32 bits. The highest allowed code point is
    // 0x10FFFF and it should not change in future versions of Unicode. This
    // means no more than 21 bits are necessary to represent a code point and
    // thus we can use Grain's "simple" numbers that hold up to 31 bits and
    // avoid heap allocations. `getCodePoint` will throw
    // MalformedUnicode exception for values exceeding this limit.
    let codePoint = getCodePoint(ptr)
    fn(tagChar(codePoint), tagSimpleNumber(idx))

    ptr += codePointByteCount
    idx += 1n
  }
  void
}

/**
 * Builds a new string by mapping Unicode characters.
 *
 * @param fn: The mapping function
 * @param str: The string to map
 *
 * @example assert String.map((c) => 'a', "Hello world") == "aaaaaaaaaaa"
 *
 * @since v0.6.5
 */
provide let map = (fn: Char => Char, str: String) => {
  let chars = explode(str)
  let arrLen = arrayLength(chars)
  for (let mut i = 0; i < arrLen; i += 1) {
    chars[i] = fn(chars[i])
  }
  implode(chars)
}

/**
 * Builds a new string by mapping Unicode characters. This is the same as
 * `mapChar`, but provides the characters's index in the string
 * as the second argument to the mapping function.
 *
 * @param fn: The mapping function
 * @param str: The string to map
 *
 * @example assert String.mapi((char, index) => String.charAt(0, toString(index)), "Hello world") == "01234567891"
 *
 * @since v0.6.5
 */
provide let mapi = (fn: (Char, Number) => Char, str: String) => {
  let chars = explode(str)
  let arrLen = arrayLength(chars)
  for (let mut i = 0; i < arrLen; i += 1) {
    chars[i] = fn(chars[i], i)
  }
  implode(chars)
}

@unsafe
let trimString = (stringPtr: WasmI32, byteLength: WasmI32, fromEnd: Bool) => {
  use WasmI32.{ (+), (-), (*), (>>>), ltU as (<), (==), (!=) }
  let mut i = 0n
  and offset = 1n
  if (fromEnd) {
    i = byteLength - 1n
    offset = -1n
  }
  let mut count = 0n
  for (; i < byteLength; i += offset) {
    // Get the byte, not necessarily a full UTF-8 codepoint
    let byte = WasmI32.load8U(stringPtr, i)
    // TODO(#661): Use unicode whitespace property and unicode line terminator
    if (!fromEnd) {
      if (
        byte == 0xEFn
        && // Check for the first BOM byte
        // Check for the full BOM codepoint, 0xEFBBBF. Bytes are reversed because wasm is little-endian
        WasmI32.load(stringPtr, i - 1n) >>> 8n == 0xBFBBEFn
      ) {
        i += 2n
        count += 3n
        continue
      }
    } else {
      if (
        byte == 0xBFn
        && // Check for the last BOM byte
        // Check for the full BOM codepoint, 0xEFBBBF. Bytes are reversed because wasm is little-endian
        WasmI32.load(stringPtr, i - 3n) >>> 8n == 0xBFBBEFn
      ) {
        i -= 2n
        count += 3n
        continue
      }
    }
    if (
      byte != 0x20n
      && // Space
      byte != 0x0Dn
      && // LF
      byte != 0x0An
      && // CR
      byte != 0x09n
      && // Tab
      byte != 0x0Bn
      && // LINE TABULATION
      byte != 0x0Cn
      && // FORM FEED (FF)
      byte != 0xA0n // No Break Space
    ) {
      break
    }
    count += 1n
  }
  count
}
/**
 * Trims the beginning of a stringâ€”removing any leading whitespace characters.
 *
 * @param string: The string to be trimmed
 * @returns The trimmed string
 *
 * @example String.trimStart("   Hello World") == "Hello World"
 *
 * @since v0.4.2
 */
@unsafe
provide let trimStart = (string: String) => {
  use WasmI32.{ (-), (+) }
  let mut stringPtr = WasmRef.fromGrain(string)
  let byteLength = rawByteLength(stringPtr)
  stringPtr += _STR_DATA_OFFSET
  let count = trimString(stringPtr, byteLength, false)
  let str = allocateString(byteLength - count)
  Memory.copy(str + _STR_DATA_OFFSET, stringPtr + count, byteLength - count)
  ignore(string)
  WasmRef.toGrain(str): String
}
/**
 * Trims the end of a stringâ€”removing any trailing whitespace characters.
 *
 * @param string: The string to be trimmed
 * @returns The trimmed string
 *
 * @example String.trimEnd("Hello World   ") == "Hello World"
 *
 * @since v0.4.2
 */
@unsafe
provide let trimEnd = (string: String) => {
  use WasmI32.{ (-), (+) }
  let mut stringPtr = WasmRef.fromGrain(string)
  let byteLength = rawByteLength(stringPtr)
  stringPtr += _STR_DATA_OFFSET
  let count = trimString(stringPtr, byteLength, true)
  let str = allocateString(byteLength - count)
  Memory.copy(str + _STR_DATA_OFFSET, stringPtr, byteLength - count)
  ignore(string)
  WasmRef.toGrain(str): String
}
/**
 * Trims a stringâ€”removing all leading and trailing whitespace characters.
 *
 * @param string: The string to be trimmed
 * @returns The trimmed string
 *
 * @example String.trim("   Hello World   ") == "Hello World"
 *
 * @since v0.4.2
 */
@unsafe
provide let trim = (string: String) => {
  use WasmI32.{ (-), (+), (==) }
  let mut stringPtr = WasmRef.fromGrain(string)
  let byteLength = rawByteLength(stringPtr)
  stringPtr += _STR_DATA_OFFSET
  let startCount = trimString(stringPtr, byteLength, false)
  if (startCount == byteLength) return ""
  let endCount = trimString(stringPtr, byteLength, true)
  let str = allocateString(byteLength - startCount - endCount)
  Memory.copy(
    str + _STR_DATA_OFFSET,
    stringPtr + startCount,
    byteLength - startCount - endCount
  )
  ignore(string)
  return WasmRef.toGrain(str): String
}

/**
 * Converts all ASCII uppercase characters in the string to lowercase.
 *
 * @param string: The string to convert
 * @returns The lowercased string
 *
 * @example assert String.toAsciiLowercase("aBc123") == "abc123"
 *
 * @since v0.6.0
 */
provide let toAsciiLowercase = string => {
  let chars = explode(string)
  let len = arrayLength(chars)
  for (let mut i = 0; i < len; i += 1) {
    chars[i] = Char.Ascii.toLowercase(chars[i])
  }
  implode(chars)
}

/**
 * Converts all ASCII lowercase characters in the string to uppercase.
 *
 * @param string: The string to convert
 * @returns The uppercased string
 *
 * @example assert String.toAsciiUppercase("aBc123") == "ABC123"
 *
 * @since v0.6.0
 */
provide let toAsciiUppercase = string => {
  let chars = explode(string)
  let len = arrayLength(chars)
  for (let mut i = 0; i < len; i += 1) {
    chars[i] = Char.Ascii.toUppercase(chars[i])
  }
  implode(chars)
}

/**
 * Produces a new string by repeating a substring a given number of times.
 *
 * @param count: The number of times to repeat the string
 * @param string: The string to repeat
 * @returns A string containing the repeated input string
 *
 * @throws InvalidArgument(String): When the `count` is not an integer
 * @throws InvalidArgument(String): When the `count` is negative
 *
 * @example assert String.repeat(5, "=") == "====="
 * @example assert String.repeat(0, ".") == ""
 *
 * @since v0.6.7
 */
@unsafe
provide let repeat = (count, string: String) => {
  use WasmI32.{ (+), (*), (<), (&), (!=) }
  let rawCount = convSimpleNumber(count, "Invalid count value")
  if (rawCount < 0n) {
    throw InvalidArgument("Invalid count must be a positive integer or zero")
  }
  let stringPtr = WasmRef.fromGrain(string)
  let byteLength = rawByteLength(stringPtr)
  let stringPtr = stringPtr + _STR_DATA_OFFSET
  let newStringPtr = allocateString(byteLength * rawCount)
  let strContentPtr = newStringPtr + _STR_DATA_OFFSET
  for (let mut i = 0n; i < rawCount; i += 1n) {
    Memory.copy(strContentPtr + byteLength * i, stringPtr, byteLength)
  }
  ignore(string)
  return WasmRef.toGrain(newStringPtr): String
}
