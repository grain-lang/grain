import WasmI32 from "runtime/unsafe/wasmi32"
import Memory from "runtime/unsafe/memory"
import Exception from "runtime/exception"
import { tagSimpleNumber, allocateArray, allocateChar, allocateString, allocateBytes } from "runtime/dataStructures"

// Concatenate two strings.
// @param str1: String - The first string
// @param str2: String - The second string
// @returns String
export let concat = (++)

// Get the character length of a string.
// @param input: String - The string to check
// @returns Number
@disableGC
export let rec length = (s: String) => {
  let s = WasmI32.fromGrain(s)
  let size = WasmI32.load(s, 4n)

  let mut len = 0n
  let mut ptr = WasmI32.add(s, 8n)
  let end = WasmI32.add(ptr, size)

  while (WasmI32.ltU(ptr, end)) {
    let byte = WasmI32.load8U(ptr, 0n)
    if (WasmI32.ne(WasmI32.and(byte, 0xC0n), 0x80n)) {
      len = WasmI32.add(len, 1n)
    }
    ptr = WasmI32.add(ptr, 1n)
  }

  let ret = tagSimpleNumber(len)
  Memory.decRef(WasmI32.fromGrain(length))
  Memory.decRef(WasmI32.fromGrain(s))
  ret
}

// @disableGC-safe wrapper
@disableGC
let wasmSafeLength = (s: String) => {
  Memory.incRef(WasmI32.fromGrain(length))
  Memory.incRef(WasmI32.fromGrain(s))
  length(s)
}

// Get the byte length of a string.
// @param input: String - The string to check
// @returns Number
@disableGC
export let rec byteLength = (s: String) => {
  let s = WasmI32.fromGrain(s)
  let ret = tagSimpleNumber(WasmI32.load(s, 4n))
  Memory.decRef(WasmI32.fromGrain(byteLength))
  Memory.decRef(WasmI32.fromGrain(s))
  ret
}


// @disableGC-safe wrapper
@disableGC
let wasmSafeByteLength = (s: String) => {
  Memory.incRef(WasmI32.fromGrain(byteLength))
  Memory.incRef(WasmI32.fromGrain(s))
  byteLength(s)
}

// Find the start index of a substring.
// @param sub: String - The substring to find
// @param input: String - The string to check
// @returns Option<Number>
@disableGC
export let rec indexOf = (p: String, s: String) => {
  let p = WasmI32.fromGrain(p)
  let s = WasmI32.fromGrain(s)

  let size = WasmI32.load(s, 4n)
  let psize = WasmI32.load(p, 4n)

  let (>) = WasmI32.gtU
  let (<) = WasmI32.ltU
  let (==) = WasmI32.eq
  let (+) = WasmI32.add
  let (-) = WasmI32.sub
  let (&) = WasmI32.and

  let ret = if (psize > size) {
    let none = None
    Memory.incRef(WasmI32.fromGrain(none))
    none
  } else {
    let mut idx = 0n
    let mut ptr = s + 8n
    let mut pptr = p + 8n
    let end = ptr + size - psize + 1n

    let mut result = -1n

    while (ptr < end) {
      if (Memory.compare(ptr, pptr, psize) == 0n) {
        result = idx
        break
      }
      idx += 1n
      let byte = WasmI32.load8U(ptr, 0n)
      if ((byte & 0x80n) == 0x00n) {
        ptr += 1n
      } else if ((byte & 0xF0n) == 0xF0n) {
        ptr += 4n
      } else if ((byte & 0xE0n) == 0xE0n) {
        ptr += 3n
      } else {
        ptr += 2n
      }
    }

    if (result == -1n) {
      let none = None
      Memory.incRef(WasmI32.fromGrain(none))
      none
    } else {
      Memory.incRef(WasmI32.fromGrain(Some))
      Some(tagSimpleNumber(result))
    }
  }
  Memory.decRef(WasmI32.fromGrain(p))
  Memory.decRef(WasmI32.fromGrain(s))
  Memory.decRef(WasmI32.fromGrain(indexOf))
  ret
}

@disableGC
export let rec charAt = (idx, s: String) => {
  Memory.incRef(WasmI32.fromGrain((<=)))
  if (wasmSafeLength(s) <= idx || {Memory.incRef(WasmI32.fromGrain((<))); idx < 0}) {
    Memory.incRef(WasmI32.fromGrain((++)))
    Memory.incRef(WasmI32.fromGrain(toString))
    fail ("Invalid offset: " ++ toString(idx))
  }
  // Implementation is similar to explodeHelp, but doesn't perform unneeded memory allocations
  let (>>>) = WasmI32.shrU
  let (+) = WasmI32.add
  let (&) = WasmI32.and
  let (<) = WasmI32.ltU
  let (==) = WasmI32.eq
  let size = WasmI32.fromGrain(wasmSafeByteLength(s)) >>> 1n
  let len = WasmI32.fromGrain(wasmSafeLength(s)) >>> 1n
  let idx = WasmI32.fromGrain(idx) >>> 1n
  let s = WasmI32.fromGrain(s)
  let mut ptr = s + 8n;
  let end = ptr + size;
  let mut counter = 0n;
  let mut result = 0n
  while (ptr < end) {
    let byte = WasmI32.load8U(ptr, 0n)
    let n = if ((byte & 0x80n) == 0x00n) {
      1n
    } else if ((byte & 0xF0n) == 0xF0n) {
      4n
    } else if ((byte & 0xE0n) == 0xE0n) {
      3n
    } else {
      2n
    }
    if (counter == idx) {
      let c = allocateChar()
      Memory.copy(c + 4n, ptr, n)
      result = c
      break
    }
    counter += 1n
    ptr += n
  }
  if (result == 0n) {
    fail "charAt: should be impossible (please report)"
  }
  let ret = WasmI32.toGrain(result): Char
  Memory.decRef(WasmI32.fromGrain(s))
  Memory.decRef(WasmI32.fromGrain(charAt))
  ret
}

@disableGC
let explodeHelp = (s: String, chars) => {
  let (>>>) = WasmI32.shrU
  let (+) = WasmI32.add
  let (&) = WasmI32.and
  let (<) = WasmI32.ltU
  let (==) = WasmI32.eq

  let size = WasmI32.fromGrain(wasmSafeByteLength(s)) >>> 1n
  let len = WasmI32.fromGrain(wasmSafeLength(s)) >>> 1n

  let s = WasmI32.fromGrain(s)

  let mut ptr = s + 8n
  let end = ptr + size

  let arr = allocateArray(len)
  let mut arrIdx = 0n

  while (ptr < end) {
    let byte = WasmI32.load8U(ptr, 0n)
    let n = if ((byte & 0x80n) == 0x00n) {
      1n
    } else if ((byte & 0xF0n) == 0xF0n) {
      4n
    } else if ((byte & 0xE0n) == 0xE0n) {
      3n
    } else {
      2n
    }

    let c = if (chars) {
      let c = allocateChar()
      Memory.copy(c + 4n, ptr, n)
      c
    } else {
      let s = allocateString(n)
      Memory.copy(s + 8n, ptr, n)
      s
    }

    WasmI32.store(arr + arrIdx, c, 8n)
    arrIdx += 4n
    ptr += n
  }

  arr
}

// Split a string into its UTF-8 characters
// @param input: String - The string to split
// @returns Array<Char>
@disableGC
export let explode = (str) => {
  WasmI32.toGrain(explodeHelp(str, true)): Array<Char>
}

// Create a string from an array of characters
// @param input: Array<Char> - The array to implode
// @returns String
@disableGC
export let rec implode = (arr: Array<Char>) => {
  let (+) = WasmI32.add
  let (==) = WasmI32.eq
  let (<) = WasmI32.ltU
  let (<<) = WasmI32.shl
  let (&) = WasmI32.and

  let arr = WasmI32.fromGrain(arr)

  let arrLength = WasmI32.load(arr, 4n)

  let mut stringByteLength = 0n

  for (let mut i = 0n; i < arrLength; i += 1n) {
    let char = WasmI32.load(arr + (i << 2n), 8n)
    let byte = WasmI32.load8U(char, 4n)

    let n = if ((byte & 0x80n) == 0x00n) {
      1n
    } else if ((byte & 0xF0n) == 0xF0n) {
      4n
    } else if ((byte & 0xE0n) == 0xE0n) {
      3n
    } else {
      2n
    }

    stringByteLength += n
  }

  let str = allocateString(stringByteLength)
  let mut offset = 8n

  for (let mut i = 0n; i < arrLength; i += 1n) {
    let char = WasmI32.load(arr + (i << 2n), 8n)
    let byte = WasmI32.load8U(char, 4n)

    let n = if ((byte & 0x80n) == 0x00n) {
      1n
    } else if ((byte & 0xF0n) == 0xF0n) {
      4n
    } else if ((byte & 0xE0n) == 0xE0n) {
      3n
    } else {
      2n
    }

    Memory.copy(str + offset, char + 4n, n)
    offset += n
  }

  let ret = WasmI32.toGrain(str): String
  Memory.decRef(WasmI32.fromGrain(arr))
  Memory.decRef(WasmI32.fromGrain(implode))
  ret
}

// Split a string by the given sequence
// @param sequence: String - The sequence to split on
// @param input: String - The string to split
// @returns Array<String>
@disableGC
export let rec split = (p: String, s: String) => {
  let (+) = WasmI32.add
  let (-) = WasmI32.sub
  let (==) = WasmI32.eq
  let (<) = WasmI32.ltU
  let (>) = WasmI32.gtU
  let (<<) = WasmI32.shl
  let (>>) = WasmI32.shrS
  let (&) = WasmI32.and

  let size = WasmI32.fromGrain(wasmSafeByteLength(s)) >> 1n
  let psize = WasmI32.fromGrain(wasmSafeByteLength(p)) >> 1n

  let ret = if (psize == 0n) {
    WasmI32.toGrain(explodeHelp(s, false)): Array<String>
  } else if (psize > size) {
    let s = WasmI32.fromGrain(s)
    let ptr = allocateArray(1n)
    WasmI32.store(ptr, Memory.incRef(s), 8n)
    WasmI32.toGrain(ptr): Array<String>
  } else {
    let s = WasmI32.fromGrain(s)
    let p = WasmI32.fromGrain(p)

    let mut ptr = s + 8n
    let mut pptr = p + 8n
    let end = ptr + size - psize + 1n

    let mut numStrings = 1n

    while (ptr < end) {
      if (Memory.compare(ptr, pptr, psize) == 0n) {
        numStrings += 1n
      }
      let byte = WasmI32.load8U(ptr, 0n)
      if ((byte & 0x80n) == 0x00n) {
        ptr += 1n
      } else if ((byte & 0xF0n) == 0xF0n) {
        ptr += 4n
      } else if ((byte & 0xE0n) == 0xE0n) {
        ptr += 3n
      } else {
        ptr += 2n
      }
    }

    ptr = s + 8n
    let mut last = ptr
    let arr = allocateArray(numStrings)
    let mut arrIdx = 0n

    while (ptr < end) {
      if (Memory.compare(ptr, pptr, psize) == 0n) {
        let strSize = ptr - last
        let str = allocateString(strSize)
        Memory.copy(str + 8n, last, strSize)
        WasmI32.store(arr + arrIdx, str, 8n)
        arrIdx += 4n
        ptr += psize
        last = ptr
        continue
      }
      let byte = WasmI32.load8U(ptr, 0n)
      if ((byte & 0x80n) == 0x00n) {
        ptr += 1n
      } else if ((byte & 0xF0n) == 0xF0n) {
        ptr += 4n
      } else if ((byte & 0xE0n) == 0xE0n) {
        ptr += 3n
      } else {
        ptr += 2n
      }
    }

    // Grab last string
    let strSize = s + 8n + size - last
    let lastStr = allocateString(strSize)
    Memory.copy(lastStr + 8n, last, strSize)
    WasmI32.store(arr + arrIdx, lastStr, 8n)

    WasmI32.toGrain(arr): Array<String>
  }
  Memory.decRef(WasmI32.fromGrain(p))
  Memory.decRef(WasmI32.fromGrain(s))
  Memory.decRef(WasmI32.fromGrain(split))
  ret
}

// Get a portion of a string.
// @param from: Number - The start index of the substring
// @param to: Number - The end index of the substring
// @param input: String - The input string
// @returns String
@disableGC
export let rec slice = (start: Number, to: Number, s: String) => {
  let (+) = WasmI32.add
  let (-) = WasmI32.sub
  let (==) = WasmI32.eq
  let (!=) = WasmI32.ne
  let (<) = WasmI32.ltS
  let (>) = WasmI32.gtS
  let (<<) = WasmI32.shl
  let (>>) = WasmI32.shrS
  let (&) = WasmI32.and
  let startOrig = start
  let toOrig = to

  let len = WasmI32.fromGrain(wasmSafeLength(s)) >> 1n
  let size = WasmI32.fromGrain(wasmSafeByteLength(s)) >> 1n

  let s = WasmI32.fromGrain(s)

  let mut start = WasmI32.fromGrain(start)
  if ((start & 1n) != 1n) {
    throw InvalidArgument("Invalid start index")
  }
  start = start >> 1n

  let mut to = WasmI32.fromGrain(to)
  if ((to & 1n) != 1n) {
    throw InvalidArgument("Invalid end index")
  }
  to = to >> 1n

  if (start < 0n) {
    start += len
  }
  if (to < 0n) {
    to += len
  }

  if (start > len || to > len) {
    throw Exception.IndexOutOfBounds
  }

  if (to < start) {
    throw InvalidArgument("Start index exceeds end index")
  }

  let mut ptr = s + 8n
  let mut begin = ptr
  let mut end = ptr
  let stop = ptr + size

  let mut idx = 0n
  while (ptr < stop) {
    let byte = WasmI32.load8U(ptr, 0n)
    if ((byte & 0xC0n) != 0x80n) {
      if (idx == start) {
        begin = ptr
      }
      if (idx == to) {
        end = ptr
        break
      }
      idx += 1n
    }
    ptr += 1n
  }
  if (to == len) {
    end = s + 8n + size
  }
  if (start == to) {
    begin = end
  }

  let newSize = end - begin
  let newString = allocateString(newSize)

  Memory.copy(newString + 8n, begin, newSize)

  let ret = WasmI32.toGrain(newString): String
  Memory.decRef(WasmI32.fromGrain(startOrig))
  Memory.decRef(WasmI32.fromGrain(toOrig))
  Memory.decRef(WasmI32.fromGrain(s))
  Memory.decRef(WasmI32.fromGrain(slice))
  ret
}

// Check if a string contains a substring.
// @param pattern: String - The substring to check
// @param input: String - The input string
// @returns Bool
@disableGC
export let rec contains = (p: String, s: String) => {
  // "Not So Naive" string search algorithm
  // searching phase in O(nm) time complexity
  // slightly (by coefficient) sub-linear in the average case
  // http://igm.univ-mlv.fr/~lecroq/string/node13.html#SECTION00130

  let (+) = WasmI32.add
  let (-) = WasmI32.sub
  let (==) = WasmI32.eq
  let (!=) = WasmI32.ne
  let (<) = WasmI32.ltU
  let (<=) = WasmI32.leU
  let (>) = WasmI32.gtU
  let (>>) = WasmI32.shrS
  let pOrig = p
  let sOrig = s

  let n = WasmI32.fromGrain(wasmSafeByteLength(s)) >> 1n
  let m = WasmI32.fromGrain(wasmSafeByteLength(p)) >> 1n

  let mut s = WasmI32.fromGrain(s)
  let mut p = WasmI32.fromGrain(p)

  s += 8n
  p += 8n

  let mut j = 0n, k = 0n, ell = 0n

  let ret = if (m > n) {
    // Bail if pattern length is longer than input length
    false
  } else if (m < 2n) {
    // Handle very small patterns
    if (m == 0n) {
      true
    } else {
      let pat = WasmI32.load8U(p, 0n)
      let mut result = false
      while (j < n) {
        if (pat == WasmI32.load8U(s + j, 0n)) {
          result = true
          break
        } else {
          j += 1n
        }
      }
      result
    }
  } else {
    // NSM preprocessing
    if (WasmI32.load8U(p, 0n) == WasmI32.load8U(p, 1n)) {
      k = 2n
      ell = 1n
    } else {
      k = 1n
      ell = 2n
    }

    let mut result = false
    // NSM searching
    while (j <= n - m) {
      if (WasmI32.load8U(p, 1n) != WasmI32.load8U(s + j, 1n)) {
        j += k
      } else {
        if (Memory.compare(p + 2n, s + j + 2n, m - 2n) == 0n && WasmI32.load8U(p, 0n) == WasmI32.load8U(s + j, 0n)) {
          result = true
          break
        }
        j += ell
      }
    }
    result
  }
  Memory.decRef(WasmI32.fromGrain(pOrig))
  Memory.decRef(WasmI32.fromGrain(sOrig))
  Memory.decRef(WasmI32.fromGrain(contains))
  ret
}

// Check if a string begins with another string.
// @param pattern: String - The substring to check
// @param input: String - The input string
// @returns Bool
@disableGC
export let rec startsWith = (p: String, s: String) => {
  let (+) = WasmI32.add
  let (>) = WasmI32.gtU
  let (==) = WasmI32.eq
  let pOrig = p
  let sOrig = s

  let mut p = WasmI32.fromGrain(p)
  let mut s = WasmI32.fromGrain(s)

  let n = WasmI32.load(s, 4n)
  let m = WasmI32.load(p, 4n)

  s += 8n
  p += 8n

  // Bail if pattern length is longer than input length
  let ret = if (m > n) {
    false
  } else {
    Memory.compare(p, s, m) == 0n
  }
  Memory.decRef(WasmI32.fromGrain(pOrig))
  Memory.decRef(WasmI32.fromGrain(sOrig))
  Memory.decRef(WasmI32.fromGrain(startsWith))
  ret
}

// Check if a string ends with another string.
// @param pattern: String - The substring to check
// @param input: String - The input string
// @returns Bool
@disableGC
export let rec endsWith = (p: String, s: String) => {
  let (+) = WasmI32.add
  let (-) = WasmI32.sub
  let (>) = WasmI32.gtU
  let (==) = WasmI32.eq
  let pOrig = p
  let sOrig = s

  let mut p = WasmI32.fromGrain(p)
  let mut s = WasmI32.fromGrain(s)

  let n = WasmI32.load(s, 4n)
  let m = WasmI32.load(p, 4n)

  s += 8n
  p += 8n

  // Bail if pattern length is longer than input length
  let ret = if (m > n) {
    false
  } else {
    Memory.compare(p, s + n - m, m) == 0n
  }
  Memory.decRef(WasmI32.fromGrain(pOrig))
  Memory.decRef(WasmI32.fromGrain(sOrig))
  Memory.decRef(WasmI32.fromGrain(endsWith))
  ret
}

export enum Encoding {
  UTF8,
  UTF16_BE,
  UTF16_LE,
  UTF32_BE,
  UTF32_LE,
}

// String->Byte encoding and helper functions:

// these are globals to avoid memory leaks
let _START_NAME = "start"
let _SIZE_NAME = "size"
let _OFFSET_NAME = "offset"

@disableGC
let grainToWasmNumber = (num, name) => {
  let num = WasmI32.fromGrain(num)
  if (WasmI32.eqz(WasmI32.and(num, 1n))) {
    Memory.incRef(WasmI32.fromGrain(name))
    Memory.incRef(WasmI32.fromGrain((++)))
    let str = " argument must be an integer"
    Memory.incRef(WasmI32.fromGrain(str))
    Memory.incRef(WasmI32.fromGrain(Exception.InvalidArgument))
    throw Exception.InvalidArgument(name ++ str)
  }
  let num = WasmI32.shrS(num, 1n)
  if (WasmI32.ltS(num, 0n)) {
    Memory.incRef(WasmI32.fromGrain(name))
    Memory.incRef(WasmI32.fromGrain((++)))
    let str = " argument must be non-negative"
    Memory.incRef(WasmI32.fromGrain(str))
    Memory.incRef(WasmI32.fromGrain(Exception.InvalidArgument))
    throw Exception.InvalidArgument(name ++ str)
  }
  num
}

@disableGC
let utf16Length = (s: String) => {
  let (>>>) = WasmI32.shrU
  let (<<) = WasmI32.shl
  let (+) = WasmI32.add
  let (&) = WasmI32.and
  let (<) = WasmI32.ltU
  let (==) = WasmI32.eq

  let size = WasmI32.fromGrain(wasmSafeByteLength(s)) >>> 1n
  let len = WasmI32.fromGrain(wasmSafeLength(s)) >>> 1n

  let s = WasmI32.fromGrain(s)

  let mut ptr = s + 8n
  let end = ptr + size
  let mut size = 0n // <- number of UTF-16 code words

  while (ptr < end) {
    let byte = WasmI32.load8U(ptr, 0n)
    let n = if ((byte & 0x80n) == 0x00n) {
      1n
    } else if ((byte & 0xF0n) == 0xF0n) {
      4n
    } else if ((byte & 0xE0n) == 0xE0n) {
      3n
    } else {
      2n
    }
    if (n == 4n) {
      size += 2n
    } else {
      size += 1n
    }
    ptr += n
  }
  // multiply by two to get number of bytes
  tagSimpleNumber(size << 1n)
}

@disableGC
let encodedLength = (s: String, encoding) => {
  match(encoding) {
    UTF32_BE => {
      Memory.incRef(WasmI32.fromGrain((*)))
      wasmSafeLength(s) * 4
    },
    UTF32_LE => {
      Memory.incRef(WasmI32.fromGrain((*)))
      wasmSafeLength(s) * 4
    },
    UTF16_BE => utf16Length(s),
    UTF16_LE => utf16Length(s),
    UTF8 => wasmSafeByteLength(s),
  }
}

exception MalformedUnicode

@disableGC
let getCodePoint = (ptr: WasmI32) => {
  // Algorithm from https://encoding.spec.whatwg.org/#utf-8-decoder
  let (+) = WasmI32.add
  let (==) = WasmI32.eq
  let (>=) = WasmI32.geU
  let (<=) = WasmI32.leU
  let (<<) = WasmI32.shl
  let (&) = WasmI32.and
  let (|) = WasmI32.or

  let mut codePoint = 0n
  let mut bytesSeen = 0n
  let mut bytesNeeded = 0n
  let mut lowerBoundary = 0x80n
  let mut upperBoundary = 0xBFn

  let mut offset = 0n

  let mut result = 0n

  while (true) {
    let byte = WasmI32.load8U(ptr + offset, 0n)
    offset += 1n
    if (bytesNeeded == 0n) {
      if (byte >= 0x00n && byte <= 0x7Fn) {
        result = byte
        break
      } else if (byte >= 0xC2n && byte <= 0xDFn) {
        bytesNeeded = 1n
        codePoint = byte & 0x1Fn
      } else if (byte >= 0xE0n && byte <= 0xEFn) {
        if (byte == 0xE0n) lowerBoundary = 0xA0n
        if (byte == 0xEDn) upperBoundary = 0x9Fn
        bytesNeeded = 2n
        codePoint = byte & 0xFn
      } else if (byte >= 0xF0n && byte <= 0xF4n) {
        if (byte == 0xF0n) lowerBoundary = 0x90n
        if (byte == 0xF4n) upperBoundary = 0x8Fn
        bytesNeeded = 3n
        codePoint = byte & 0x7n
      } else {
        throw MalformedUnicode
      }
      continue
    }
    Memory.incRef(WasmI32.fromGrain((!)))
    if (!(lowerBoundary <= byte && byte <= upperBoundary)) {
      throw MalformedUnicode
    }
    lowerBoundary = 0x80n
    upperBoundary = 0xBFn
    codePoint = (codePoint << 6n) | (byte & 0x3Fn)
    bytesSeen += 1n
    if (bytesSeen == bytesNeeded) {
      result = codePoint
      break
    }
  }
  result: WasmI32
}

let _BYTES_SIZE_OFFSET = 4n;
let _BYTES_OFFSET = 8n;

// Encodes the given string using the given encoding scheme
// @param s: String - The input string
// @param encoding: Encoding - The encoding to use
// @param includeBom: Bool - Whether to include the byte-order marker in the encoded output
// @param dest: Bytes - The bytes object to write the encoded output into
// @param destPos: Number - The location in the byte array to write the output
// @returns Bytes - Returns `dest`
@disableGC
let rec encodeAtHelp = (s: String, encoding: Encoding, includeBom: Bool, dest: Bytes, destPos: Number) => {
  let (>>>) = WasmI32.shrU
  let (-) = WasmI32.sub
  let (&) = WasmI32.and
  let (<) = WasmI32.ltU
  let (>) = WasmI32.gtS
  let (<=) = WasmI32.leU
  let (==) = WasmI32.eq
  let (+) = WasmI32.add
  let byteSize = WasmI32.fromGrain(wasmSafeByteLength(s)) >>> 1n
  let len = WasmI32.fromGrain(wasmSafeLength(s)) >>> 1n

  let s = WasmI32.fromGrain(s)

  let mut ptr = s + 8n
  let end = ptr + byteSize

  let bytes = WasmI32.fromGrain(dest)
  let mut bytesIdx = grainToWasmNumber(destPos, _OFFSET_NAME)

  let destSize = WasmI32.load(bytes, _BYTES_SIZE_OFFSET)

  if (includeBom) {
    match(encoding) {
      UTF8 => {
        if ((bytesIdx + 3n) > destSize) {
          throw Exception.IndexOutOfBounds
        }
        WasmI32.store8(bytes + bytesIdx, 0xEFn, _BYTES_OFFSET)
        WasmI32.store8(bytes + bytesIdx + 1n, 0xBBn, _BYTES_OFFSET)
        WasmI32.store8(bytes + bytesIdx + 2n, 0xBFn, _BYTES_OFFSET)
        bytesIdx += 3n
      },
      UTF16_BE => {
        if ((bytesIdx + 2n) > destSize) {
          throw Exception.IndexOutOfBounds
        }
        WasmI32.store8(bytes + bytesIdx, 0xFEn, _BYTES_OFFSET)
        WasmI32.store8(bytes + bytesIdx + 1n, 0xFFn, _BYTES_OFFSET)
        bytesIdx += 2n
      },
      UTF16_LE => {
        if ((bytesIdx + 2n) > destSize) {
          throw Exception.IndexOutOfBounds
        }
        WasmI32.store8(bytes + bytesIdx, 0xFFn, _BYTES_OFFSET)
        WasmI32.store8(bytes + bytesIdx + 1n, 0xFEn, _BYTES_OFFSET)
        bytesIdx += 2n
      },
      UTF32_BE => {
        if ((bytesIdx + 4n) > destSize) {
          throw Exception.IndexOutOfBounds
        }
        WasmI32.store8(bytes + bytesIdx, 0n, _BYTES_OFFSET)
        WasmI32.store8(bytes + bytesIdx + 1n, 0n, _BYTES_OFFSET)
        WasmI32.store8(bytes + bytesIdx + 2n, 0xFEn, _BYTES_OFFSET)
        WasmI32.store8(bytes + bytesIdx + 3n, 0xFFn, _BYTES_OFFSET)
        bytesIdx += 4n
      },
      UTF32_LE => {
        if ((bytesIdx + 4n) > destSize) {
          throw Exception.IndexOutOfBounds
        }
        WasmI32.store8(bytes + bytesIdx, 0xFFn, _BYTES_OFFSET)
        WasmI32.store8(bytes + bytesIdx + 1n, 0xFEn, _BYTES_OFFSET)
        WasmI32.store8(bytes + bytesIdx + 2n, 0n, _BYTES_OFFSET)
        WasmI32.store8(bytes + bytesIdx + 3n, 0n, _BYTES_OFFSET)
        bytesIdx += 4n
      }
    }
  }

  match(encoding) {
    UTF8 => {
      // Optimization: since internally strings in Grain are UTF8 encoded, when
      // the target encoding is UTF8 as well, then copy the entire memory range
      // in bulk. No need to iterate individual characters.
      if ((bytesIdx + byteSize) > destSize) {
        throw Exception.IndexOutOfBounds
      }
      Memory.copy(bytes + bytesIdx + _BYTES_OFFSET, ptr, byteSize)
    },
    _ => {
      while (ptr < end) {
        let byte = WasmI32.load8U(ptr, 0n)
        // number of bytes spanning this UTF-8-encoded scalar value
        let n = if ((byte & 0x80n) == 0x00n) {
          1n
        } else if ((byte & 0xF0n) == 0xF0n) {
          4n
        } else if ((byte & 0xE0n) == 0xE0n) {
          3n
        } else {
          2n
        }
        match(encoding) {
          UTF8 => {
            // With the optimization above for bulk memory copy, this match
            // should never occur for the UTF8 case.
            if ((bytesIdx + n) > destSize) {
              throw Exception.IndexOutOfBounds
            }
            Memory.copy(bytes + bytesIdx + _BYTES_OFFSET, ptr, n);
            bytesIdx += n
          },
          UTF16_BE => {
            let codePoint = getCodePoint(ptr)
            if (codePoint <= 0xFFFFn) {
              // <hi><lo>
              if ((bytesIdx + 2n) > destSize) {
                throw Exception.IndexOutOfBounds
              }
              WasmI32.store8(bytes + bytesIdx, (codePoint & 0xff00n) >>> 8n, _BYTES_OFFSET)
              WasmI32.store8(bytes + bytesIdx + 1n, codePoint & 0xffn, _BYTES_OFFSET)
              bytesIdx += 2n
            } else {
              // https://en.wikipedia.org/wiki/UTF-16#Code_points_from_U+010000_to_U+10FFFF
              if ((bytesIdx + 4n) > destSize) {
                throw Exception.IndexOutOfBounds
              }
              let uPrime = codePoint - 0x10000n
              let w1 = ((uPrime & 0b11111111110000000000n) >>> 10n) + 0xD800n // High surrogate
              let w2 = (uPrime & 0b00000000001111111111n) + 0xDC00n // Low surrogate
              WasmI32.store8(bytes + bytesIdx, (w1 & 0xff00n) >>> 8n, _BYTES_OFFSET)
              WasmI32.store8(bytes + bytesIdx + 1n, w1 & 0xffn, _BYTES_OFFSET)
              WasmI32.store8(bytes + bytesIdx + 2n, (w2 & 0xff00n) >>> 8n, _BYTES_OFFSET)
              WasmI32.store8(bytes + bytesIdx + 3n, w2 & 0xffn, _BYTES_OFFSET)
              bytesIdx += 4n
            }
          },
          UTF16_LE => {
            let codePoint = getCodePoint(ptr)
            if (codePoint <= 0xFFFFn) {
              if ((bytesIdx + 2n) > destSize) {
                throw Exception.IndexOutOfBounds
              }
              // <lo><hi>
              WasmI32.store8(bytes + bytesIdx, codePoint & 0xffn, _BYTES_OFFSET)
              WasmI32.store8(bytes + bytesIdx + 1n, (codePoint & 0xff00n) >>> 8n, _BYTES_OFFSET)
              bytesIdx += 2n
            } else {
              // https://en.wikipedia.org/wiki/UTF-16#Code_points_from_U+010000_to_U+10FFFF
              if ((bytesIdx + 4n) > destSize) {
                throw Exception.IndexOutOfBounds
              }
              let uPrime = codePoint - 0x10000n
              let w1 = ((uPrime & 0b11111111110000000000n) >>> 10n) + 0xD800n // High surrogate
              let w2 = (uPrime & 0b00000000001111111111n) + 0xDC00n // Low surrogate
              WasmI32.store8(bytes + bytesIdx, w1 & 0xffn, _BYTES_OFFSET)
              WasmI32.store8(bytes + bytesIdx + 1n, (w1 & 0xff00n) >>> 8n, _BYTES_OFFSET)
              WasmI32.store8(bytes + bytesIdx + 2n, w2 & 0xffn, _BYTES_OFFSET)
              WasmI32.store8(bytes + bytesIdx + 3n, (w2 & 0xff00n) >>> 8n, _BYTES_OFFSET)
              bytesIdx += 4n
            }
          },
          UTF32_BE => {
            if ((bytesIdx + 4n) > destSize) {
              throw Exception.IndexOutOfBounds
            }
            let codePoint = getCodePoint(ptr)
            WasmI32.store8(bytes + bytesIdx, (codePoint & 0xff000000n) >>> 24n, _BYTES_OFFSET)
            WasmI32.store8(bytes + bytesIdx + 1n, (codePoint & 0xff0000n) >>> 16n, _BYTES_OFFSET)
            WasmI32.store8(bytes + bytesIdx + 2n, (codePoint & 0xff00n) >>> 8n, _BYTES_OFFSET)
            WasmI32.store8(bytes + bytesIdx + 3n, codePoint & 0xffn, _BYTES_OFFSET)
            bytesIdx += 4n
          },
          UTF32_LE => {
            if ((bytesIdx + 4n) > destSize) {
              throw Exception.IndexOutOfBounds
            }
            let codePoint = getCodePoint(ptr)
            WasmI32.store8(bytes + bytesIdx, codePoint & 0xffn, _BYTES_OFFSET)
            WasmI32.store8(bytes + bytesIdx + 1n, (codePoint & 0xff00n) >>> 8n, _BYTES_OFFSET)
            WasmI32.store8(bytes + bytesIdx + 2n, (codePoint & 0xff0000n) >>> 16n, _BYTES_OFFSET)
            WasmI32.store8(bytes + bytesIdx + 3n, (codePoint & 0xff000000n) >>> 24n, _BYTES_OFFSET)
            bytesIdx += 4n
          },
        };
        ptr += n
      }
    }
  }

  let ret = WasmI32.toGrain(bytes): Bytes
  Memory.decRef(WasmI32.fromGrain(s))
  Memory.decRef(WasmI32.fromGrain(encoding))
  Memory.decRef(WasmI32.fromGrain(includeBom))
  Memory.decRef(WasmI32.fromGrain(dest))
  Memory.decRef(WasmI32.fromGrain(destPos))
  Memory.decRef(WasmI32.fromGrain(encodeAtHelp))
  ret
}

// Encodes the given string using the given encoding scheme
// @param s: String - The input string
// @param encoding: Encoding - The encoding to use
// @param dest: Bytes - The bytes object to write the encoded output into
// @param destPos: Number - The location in the byte array to write the output
// @returns Bytes - Returns `dest`
export let encodeAt = (s, encoding, dest, destPos) => {
  encodeAtHelp(s, encoding, false, dest, destPos)
}

// Encodes the given string using the given encoding scheme
// @param s: String - The input string
// @param encoding: Encoding - The encoding to use
// @param dest: Bytes - The bytes object to write the encoded output into
// @param destPos: Number - The location in the byte array to write the output
// @returns Bytes - Returns `dest`
export let encodeAtWithBom = (s, encoding, dest, destPos) => {
  encodeAtHelp(s, encoding, true, dest, destPos)
}

// Encodes the given string using the given encoding scheme
// @param s: String - The input string
// @param encoding: Encoding - The encoding to use
// @param includeBom: Bool - Whether to include the byte-order marker in the encoded output
// @returns Bytes
@disableGC
let rec encodeHelp = (s: String, encoding: Encoding, includeBom: Bool) => {
  Memory.incRef(WasmI32.fromGrain((+)))
  let size = encodedLength(s, encoding) + if (includeBom) {
    match(encoding) {
      UTF8 => 3,
      UTF16_LE => 2,
      UTF16_BE => 2,
      UTF32_LE => 4,
      UTF32_BE => 4,
    }
  } else 0
  let (>>>) = WasmI32.shrU
  let bytes = WasmI32.toGrain(allocateBytes(WasmI32.fromGrain(size) >>> 1n))
  Memory.incRef(WasmI32.fromGrain(encodeAtHelp))
  Memory.incRef(WasmI32.fromGrain(s))
  Memory.incRef(WasmI32.fromGrain(encoding))
  Memory.incRef(WasmI32.fromGrain(includeBom))
  Memory.incRef(WasmI32.fromGrain(bytes))
  let ret = encodeAtHelp(s, encoding, includeBom, bytes, 0)
  Memory.decRef(WasmI32.fromGrain(s))
  Memory.decRef(WasmI32.fromGrain(encoding))
  Memory.decRef(WasmI32.fromGrain(includeBom))
  Memory.decRef(WasmI32.fromGrain(encodeHelp))
  ret
}

// Encodes the given string using the given encoding scheme. A byte-order marker
// will not be included in the output.
// @param s: String - The input string
// @param encoding: Encoding - The encoding to use
// @returns Bytes
export let encode = (s: String, encoding: Encoding) => {
  encodeHelp(s, encoding, false)
}

// Encodes the given string using the given encoding scheme, including a byte-order marker
// @param s: String - The input string
// @param encoding: Encoding - The encoding to use
// @returns Bytes
export let encodeWithBom = (s: String, encoding: Encoding) => {
  encodeHelp(s, encoding, true)
}

// Byte->String decoding and helper functions:

@disableGC
let writeUtf8CodePoint = (ptr, codePoint) => {
  let (>>>) = WasmI32.shrU
  let (-) = WasmI32.sub
  let (&) = WasmI32.and
  let (|) = WasmI32.or
  let (+) = WasmI32.add
  let (<) = WasmI32.ltU
  let (<=) = WasmI32.leU
  let (==) = WasmI32.eq
  if (codePoint <= 0x007Fn) {
    WasmI32.store8(ptr, codePoint, 0n)
    1n
  } else if (codePoint <= 0x07FFn) {
    let high = ((codePoint >>> 6n) & 0x1Fn) | 0xC0n
    let low = (codePoint & 0x3Fn) | 0x08n
    WasmI32.store8(ptr, high, 0n)
    WasmI32.store8(ptr + 1n, low, 0n)
    2n
  } else if (codePoint <= 0xFFFFn) {
    let high = ((codePoint >>> 12n) & 0x0Fn) | 0xE0n
    let mid = ((codePoint >>> 6n) & 0x3Fn) | 0x80n
    let low = (codePoint & 0x3Fn) | 0x80n
    WasmI32.store8(ptr, high, 0n)
    WasmI32.store8(ptr + 1n, mid, 0n)
    WasmI32.store8(ptr + 2n, low, 0n)
    3n
  } else {
    let high = ((codePoint >>> 18n) & 0x07n) | 0xF0n
    let mid1 = ((codePoint >>> 12n) & 0x3Fn) | 0x80n
    let mid2 = ((codePoint >>> 6n) & 0x3Fn) | 0x80n
    let low = (codePoint & 0x3Fn) | 0x80n
    WasmI32.store8(ptr, high, 0n)
    WasmI32.store8(ptr + 1n, mid1, 0n)
    WasmI32.store8(ptr + 2n, mid2, 0n)
    WasmI32.store8(ptr + 3n, low, 0n)
    4n
  }
}

@disableGC
let bytesHaveBom = (bytes: Bytes, encoding: Encoding, start: WasmI32) => {
  let (+) = WasmI32.add
  let (==) = WasmI32.eq
  let (>=) = WasmI32.geU
  let ptr = WasmI32.fromGrain(bytes)
  let bytesSize = WasmI32.load(ptr, 4n)
  let ptr = ptr + start
  match (encoding) {
    UTF8 => {
      bytesSize >= 3n && WasmI32.load8U(ptr, _BYTES_OFFSET) == 0xEFn && WasmI32.load8U(ptr + 1n, _BYTES_OFFSET) == 0xBBn && WasmI32.load8U(ptr + 2n, _BYTES_OFFSET) == 0xBFn
    },
    UTF16_BE => {
      bytesSize >= 2n && WasmI32.load8U(ptr, _BYTES_OFFSET) == 0xFEn && WasmI32.load8U(ptr + 1n, _BYTES_OFFSET) == 0xFFn
    },
    UTF16_LE => {
      bytesSize >= 2n && WasmI32.load8U(ptr, _BYTES_OFFSET) == 0xFFn && WasmI32.load8U(ptr + 1n, _BYTES_OFFSET) == 0xFEn
    },
    UTF32_BE => {
      bytesSize >= 4n && WasmI32.load8U(ptr, _BYTES_OFFSET) == 0x00n  && WasmI32.load8U(ptr + 1n, _BYTES_OFFSET) == 0x00n && WasmI32.load8U(ptr + 2n, _BYTES_OFFSET) == 0xFEn && WasmI32.load8U(ptr + 3n, _BYTES_OFFSET) == 0xFFn
    },
    UTF32_LE => {
      bytesSize >= 4n && WasmI32.load8U(ptr, _BYTES_OFFSET) == 0xFFn && WasmI32.load8U(ptr + 1n, _BYTES_OFFSET) == 0xFEn && WasmI32.load8U(ptr + 2n, _BYTES_OFFSET) == 0x00n  && WasmI32.load8U(ptr + 3n, _BYTES_OFFSET) == 0x00n
    }
  }
}

@disableGC
let decodedLength = (bytes: Bytes, encoding: Encoding, start: WasmI32, size: WasmI32) => {
  let (+) = WasmI32.add
  let (-) = WasmI32.sub
  let (==) = WasmI32.eq
  let (!=) = WasmI32.ne
  let (<) = WasmI32.ltU
  let (>) = WasmI32.gtU
  let (|) = WasmI32.or
  let (&) = WasmI32.and
  let (>>>) = WasmI32.shrU
  let (<<) = WasmI32.shl
  let (>=) = WasmI32.geU
  let (<=) = WasmI32.leU
  let ptr = WasmI32.fromGrain(bytes)
  let bytesSize = {
    let tmp = WasmI32.load(ptr, 4n) - start
    if (size < tmp) {
      size
    } else {
      tmp
    }
  }
  let start = ptr + _BYTES_OFFSET + start
  match(encoding) {
    UTF8 => bytesSize,
    UTF16_BE => {
      let end = start + bytesSize
      let mut ptr = start
      let mut count = 0n
      while (ptr < end) {
        let codeWord = (WasmI32.load8U(ptr, 0n) << 8n) | (WasmI32.load8U(ptr, 1n))
        let codeWord = if (codeWord >= 0xD800n && codeWord <= 0xDBFFn) {
          // high surrogate. need to check that next character is low srurrogate
          let ret = if (ptr + 2n >= end) {
            throw MalformedUnicode
          } else {
            let nextCodeWord = (WasmI32.load8U(ptr, 2n) << 8n) | (WasmI32.load8U(ptr, 3n))
            if (nextCodeWord < 0xDC00n || nextCodeWord > 0xDFFFn) {
              // high surrogate without low surrogate
              throw MalformedUnicode
            } else {
              let w1 = (codeWord & 0x03FFn) << 10n
              let w2 = nextCodeWord & 0x03FFn
              w1 + w2 + 0x10000n
            }
          }
          // no problems, so go past both code words
          ptr += 4n
          ret
        } else {
          ptr += 2n
          codeWord
        }
        if (codeWord <= 0x007Fn) {
          count += 1n
        } else if (codeWord <= 0x07FFn) {
          count += 2n
        } else if (codeWord <= 0xFFFFn) {
          count += 3n
        } else {
          count += 4n
        }
      }
      count
    },
    UTF16_LE => {
      let end = start + bytesSize
      let mut ptr = start
      let mut count = 0n
      while (ptr < end) {
        let codeWord = (WasmI32.load8U(ptr, 1n) << 8n) | (WasmI32.load8U(ptr, 0n))
        let codeWord = if (codeWord >= 0xD800n && codeWord <= 0xDBFFn) {
          // high surrogate. need to check that next character is low srurrogate
          let ret = if (ptr + 2n >= end) {
            throw MalformedUnicode
          } else {
            let nextCodeWord = (WasmI32.load8U(ptr, 3n) << 8n) | (WasmI32.load8U(ptr, 2n))
            if (nextCodeWord < 0xDC00n || nextCodeWord > 0xDFFFn) {
              // high surrogate without low surrogate
              throw MalformedUnicode
            } else {
              let w1 = (codeWord & 0x03FFn) << 10n
              let w2 = nextCodeWord & 0x03FFn
              w1 + w2 + 0x10000n
            }
          }
          // no problems, so go past both code words
          ptr += 4n
          ret
        } else {
          ptr += 2n
          codeWord
        }
        if (codeWord <= 0x007Fn) {
          count += 1n
        } else if (codeWord <= 0x07FFn) {
          count += 2n
        } else if (codeWord <= 0xFFFFn) {
          count += 3n
        } else {
          count += 4n
        }
      }
      count
    },
    UTF32_BE => {
      // if not divisible by four, not proper UTF-32 sequence
      if ((bytesSize & 0b11n) != 0n) {
        throw MalformedUnicode
      }
      let end = start + bytesSize
      let mut ptr = start
      let mut count = 0n
      while (ptr < end) {
        let codeWord = (WasmI32.load8U(ptr, 0n) << 24n) | (WasmI32.load8U(ptr, 1n) << 16n) | (WasmI32.load8U(ptr, 2n) << 8n) | (WasmI32.load8U(ptr, 3n))
        ptr += 4n
        if (codeWord <= 0x007Fn) {
          count += 1n
        } else if (codeWord <= 0x07FFn) {
          count += 2n
        } else if (codeWord <= 0xFFFFn) {
          count += 3n
        } else {
          count += 4n
        }
      }
      count
    },
    UTF32_LE => {
      // if not divisible by four, not proper UTF-32 sequence
      if ((bytesSize & 0b11n) != 0n) {
        throw MalformedUnicode
      }
      let end = start + bytesSize
      let mut ptr = start
      let mut count = 0n
      while (ptr < end) {
        let codeWord = (WasmI32.load8U(ptr, 3n) << 24n) | (WasmI32.load8U(ptr, 2n) << 16n) | (WasmI32.load8U(ptr, 1n) << 8n) | (WasmI32.load8U(ptr, 0n))
        ptr += 4n
        if (codeWord <= 0x007Fn) {
          count += 1n
        } else if (codeWord <= 0x07FFn) {
          count += 2n
        } else if (codeWord <= 0xFFFFn) {
          count += 3n
        } else {
          count += 4n
        }
      }
      count
    }
  }
}

// Decodes the given byte sequence into a string using the given encoding scheme
// @param bytes: Bytes - The input bytes
// @param encoding: Encoding - The encoding to use
// @param skipBom: Bool - Whether to include the byte-order marker (if present) in the decoded output
// @param start: Number - The byte offset to begin decoding from
// @param size: Number - The maximum number of bytes to decode
// @returns String
@disableGC
let rec decodeRangeHelp = (bytes: Bytes, encoding: Encoding, skipBom: Bool, start: Number, size: Number) => {
  let (+) = WasmI32.add
  let (-) = WasmI32.sub
  let (<) = WasmI32.ltU
  let (|) = WasmI32.or
  let (&) = WasmI32.and
  let (>>>) = WasmI32.shrU
  let (<<) = WasmI32.shl
  let (>=) = WasmI32.geU
  let (<=) = WasmI32.leU
  let (==) = WasmI32.eq
  let start = grainToWasmNumber(start, _START_NAME)
  let size = grainToWasmNumber(size, _SIZE_NAME)
  let hasBom = bytesHaveBom(bytes, encoding, start)
  let stringSize = decodedLength(bytes, encoding, start, size)
  let stringSize = if (skipBom && hasBom) (stringSize - 3n) else stringSize
  let str = allocateString(stringSize)
  let mut bytesPtr = WasmI32.fromGrain(bytes)
  let bytesSize = {
    let tmp = WasmI32.load(bytesPtr, 4n) - start
    if (size < tmp) {
      size
    } else {
      tmp
    }
  }
  bytesPtr += _BYTES_OFFSET + start
  let mut strPtr = str + 8n
  let mut bomRead = false
  if (skipBom && hasBom) {
    bytesPtr += match(encoding) {
      UTF8 => 3n,
      UTF16_LE => 2n,
      UTF16_BE => 2n,
      UTF32_LE => 4n,
      UTF32_BE => 4n,
    }
  }
  let ret = if (stringSize == 0n) {
    WasmI32.toGrain(str) : String
  } else {
    match(encoding) {
      UTF8 => {
        Memory.copy(strPtr, bytesPtr, stringSize)
      },
      UTF16_BE => {
        // NOTE: Because the size check passed, we know the string is well-formed
        let end = bytesPtr + bytesSize
        while (bytesPtr < end) {
          let w1 = (WasmI32.load8U(bytesPtr, 0n) << 8n) | (WasmI32.load8U(bytesPtr, 1n))
          let codeWord = if (w1 >= 0xD800n && w1 <= 0xDBFFn) {
            // high surrogate. next character is low srurrogate
            let w1 = (w1 & 0x03FFn) << 10n
            let w2 = ((WasmI32.load8U(bytesPtr, 2n) << 8n) | (WasmI32.load8U(bytesPtr, 3n))) & 0x03FFn
            let codeWord = w1 + w2 + 0x10000n
            // no problems, so go past both code words
            bytesPtr += 4n
            codeWord
          } else {
            bytesPtr += 2n
            w1
          }
          strPtr += writeUtf8CodePoint(strPtr, codeWord)
        }
      },
      UTF16_LE => {
        // NOTE: Because the size check passed, we know the string is well-formed
        let end = bytesPtr + bytesSize
        while (bytesPtr < end) {
          let w1 = (WasmI32.load8U(bytesPtr, 1n) << 8n) | (WasmI32.load8U(bytesPtr, 0n))
          let codeWord = if (w1 >= 0xD800n && w1 <= 0xDBFFn) {
            // high surrogate. next character is low srurrogate
            let w1 = (w1 & 0x03FFn) << 10n
            let w2 = ((WasmI32.load8U(bytesPtr, 3n) << 8n) | (WasmI32.load8U(bytesPtr, 2n))) & 0x03FFn
            //let uPrime = codePoint - 0x10000n
            //let w1 = ((uPrime & 0b11111111110000000000n) >>> 10n) + 0xD800n // High surrogate
            //let w2 = (uPrime & 0b00000000001111111111n) + 0xDC00n // Low surrogate
            let codeWord = w1 + w2 + 0x10000n
            // no problems, so go past both code words
            bytesPtr += 4n
            codeWord
          } else {
            bytesPtr += 2n
            w1
          }
          strPtr += writeUtf8CodePoint(strPtr, codeWord)
        }
      },
      UTF32_BE => {
        let end = bytesPtr + bytesSize
        while (bytesPtr < end) {
          let codeWord = (WasmI32.load8U(bytesPtr, 0n) << 24n) | (WasmI32.load8U(bytesPtr, 1n) << 16n) | (WasmI32.load8U(bytesPtr, 2n) << 8n) | (WasmI32.load8U(bytesPtr, 3n))
          bytesPtr += 4n
          strPtr += writeUtf8CodePoint(strPtr, codeWord)
        }
      },
      UTF32_LE => {
        let end = bytesPtr + bytesSize
        while (bytesPtr < end) {
          let codeWord = (WasmI32.load8U(bytesPtr, 3n) << 24n) | (WasmI32.load8U(bytesPtr, 2n) << 16n) | (WasmI32.load8U(bytesPtr, 1n) << 8n) | (WasmI32.load8U(bytesPtr, 0n))
          bytesPtr += 4n
          strPtr += writeUtf8CodePoint(strPtr, codeWord)
        }
      }
    }
    WasmI32.toGrain(str) : String
  }
  // bytes: Bytes, encoding: Encoding, skipBom: Bool, start: Number, size: Number
  Memory.decRef(WasmI32.fromGrain(bytes))
  Memory.decRef(WasmI32.fromGrain(encoding))
  Memory.decRef(WasmI32.fromGrain(skipBom))
  Memory.decRef(WasmI32.fromGrain(decodeRangeHelp))
  ret
}

// Decodes the given byte sequence into a string using the given encoding scheme, skipping
// the byte-order marker, if it's present.
// @param bytes: Bytes - The input bytes
// @param encoding: Encoding - The encoding to use
// @param start: Number - The byte offset to begin decoding from
// @param size: Number - The maximum number of bytes to decode
// @returns String
export let decodeRange = (bytes: Bytes, encoding: Encoding, start: Number, size: Number) => {
  decodeRangeHelp(bytes, encoding, true, start, size)
}

// Decodes the given byte sequence into a string using the given encoding scheme, including
// the byte-order marker, if it's present.
// @param bytes: Bytes - The input bytes
// @param encoding: Encoding - The encoding to use
// @param start: Number - The byte offset to begin decoding from
// @param size: Number - The maximum number of bytes to decode
// @returns String
export let decodeRangeKeepBom = (bytes: Bytes, encoding: Encoding, start: Number, size: Number) => {
  decodeRangeHelp(bytes, encoding, false, start, size)
}

// Decodes the given byte sequence into a string using the given encoding scheme
// @param bytes: Bytes - The input bytes
// @param encoding: Encoding - The encoding to use
// @param skipBom: Bool - Whether to include the byte-order marker (if present) in the decoded output
// @returns String
@disableGC
let rec decodeHelp = (bytes: Bytes, encoding: Encoding, skipBom: Bool) => {
  let bytesPtr = WasmI32.fromGrain(bytes)
  let bytesSize = WasmI32.load(bytesPtr, 4n)
  Memory.incRef(WasmI32.fromGrain(decodeRangeHelp))
  Memory.incRef(WasmI32.fromGrain(bytes))
  Memory.incRef(WasmI32.fromGrain(encoding))
  let ret = decodeRangeHelp(bytes, encoding, skipBom, 0, tagSimpleNumber(bytesSize))
  Memory.incRef(WasmI32.fromGrain(bytes))
  Memory.incRef(WasmI32.fromGrain(encoding))
  Memory.incRef(WasmI32.fromGrain(decodeHelp))
  ret
}

// Decodes the given byte sequence into a string using the given encoding scheme,
// skipping the byte-order marker, if it's present.
// @param bytes: Bytes - The input bytes
// @param encoding: Encoding - The encoding to use
// @returns String
export let decode = (bytes: Bytes, encoding: Encoding) => {
  decodeHelp(bytes, encoding, true)
}

// Decodes the given byte sequence into a string using the given encoding scheme,
// including the byte-order marker, if it's present
// @param bytes: Bytes - The input bytes
// @param encoding: Encoding - The encoding to use
// @returns String
export let decodeKeepBom = (bytes: Bytes, encoding: Encoding) => {
  decodeHelp(bytes, encoding, false)
}

/**
 * Iterates over Unicode code points in a string.
 *
 * @param fn: The iterator function
 * @param str: The string to iterate
 */
@disableGC
export let rec forEachCodePoint = (fn: (Number) -> Void, str: String) => {
  let (>>>) = WasmI32.shrU
  let (-) = WasmI32.sub
  let (&) = WasmI32.and
  let (<) = WasmI32.ltU
  let (<=) = WasmI32.leU
  let (==) = WasmI32.eq
  let (+) = WasmI32.add

  let strPtr = WasmI32.fromGrain(str)

  let byteSize = WasmI32.load(strPtr, 4n)

  let mut ptr = strPtr + 8n
  let end = ptr + byteSize

  let mut idx = 0n
  while (ptr < end) {
    let byte = WasmI32.load8U(ptr, 0n)
    let codePointByteCount = if ((byte & 0x80n) == 0x00n) {
      1n
    } else if ((byte & 0xF0n) == 0xF0n) {
      4n
    } else if ((byte & 0xE0n) == 0xE0n) {
      3n
    } else {
      2n
    }

    // Note that even if up to 4 bytes are needed to represent Unicode
    // codepoints, this doesn't mean 32 bits. The highest allowed code point is
    // 0x10FFFF and it should not change in future versions of Unicode. This
    // means no more than 21 bits are necessary to represent a code point and
    // thus we can use Grain's "simple" numbers that hold up to 31 bits and
    // avoid heap allocations. `getCodePoint` will throw
    // MalformedUnicode exception for values exceeding this limit.
    let codePoint = getCodePoint(ptr)
    Memory.incRef(WasmI32.fromGrain(fn))
    fn(tagSimpleNumber(codePoint))

    ptr += codePointByteCount
    idx += 1n
  }
  Memory.decRef(WasmI32.fromGrain(fn))
  Memory.decRef(WasmI32.fromGrain(str))
  Memory.decRef(WasmI32.fromGrain(forEachCodePoint))
  void
}

/**
 * Iterates over Unicode code points in a string. This is the same as
 * `forEachCodePoint`, but provides the code point's index in the string
 * as the second argument to the iterator function.
 *
 * @param fn: The iterator function
 * @param str: The string to iterate
 */
@disableGC
export let rec forEachCodePointi = (fn: (Number, Number) -> Void, str: String) => {
  let (>>>) = WasmI32.shrU
  let (-) = WasmI32.sub
  let (&) = WasmI32.and
  let (<) = WasmI32.ltU
  let (<=) = WasmI32.leU
  let (==) = WasmI32.eq
  let (+) = WasmI32.add

  let strPtr = WasmI32.fromGrain(str)

  let byteSize = WasmI32.load(strPtr, 4n)

  let mut ptr = strPtr + 8n
  let end = ptr + byteSize

  let mut idx = 0n
  while (ptr < end) {
    let byte = WasmI32.load8U(ptr, 0n)
    let codePointByteCount = if ((byte & 0x80n) == 0x00n) {
      1n
    } else if ((byte & 0xF0n) == 0xF0n) {
      4n
    } else if ((byte & 0xE0n) == 0xE0n) {
      3n
    } else {
      2n
    }

    // Note that even if up to 4 bytes are needed to represent Unicode
    // codepoints, this doesn't mean 32 bits. The highest allowed code point is
    // 0x10FFFF and it should not change in future versions of Unicode. This
    // means no more than 21 bits are necessary to represent a code point and
    // thus we can use Grain's "simple" numbers that hold up to 31 bits and
    // avoid heap allocations. `getCodePoint` will throw
    // MalformedUnicode exception for values exceeding this limit.
    let codePoint = getCodePoint(ptr)
    Memory.incRef(WasmI32.fromGrain(fn))
    fn(tagSimpleNumber(codePoint), tagSimpleNumber(idx))

    ptr += codePointByteCount
    idx += 1n
  }
  Memory.decRef(WasmI32.fromGrain(fn))
  Memory.decRef(WasmI32.fromGrain(str))
  Memory.decRef(WasmI32.fromGrain(forEachCodePointi))
  void
}
