/**
 * Utilities for working with strings.
 *
 * @example from "string" include String
 *
 * @since v0.2.0
 * @history v0.1.0: Originally named `strings`
 * @history v0.2.0: Renamed to `string`
 */
module String

from "char" include Char
from "runtime/unsafe/wasmi32" include WasmI32
from "runtime/unsafe/memory" include Memory
from "runtime/exception" include Exception
from "runtime/unsafe/conv" include Conv
from "runtime/dataStructures" include DataStructures
use DataStructures.{
  untagSimpleNumber,
  tagSimpleNumber,
  tagChar,
  untagChar,
  allocateArray,
  allocateString,
  allocateBytes,
}

/**
 * Byte encodings
 */
provide enum Encoding {
  UTF8,
  UTF16_BE,
  UTF16_LE,
  UTF32_BE,
  UTF32_LE,
}

exception MalformedUnicode

/**
 * Concatenate two strings.
 *
 * @param str1: The beginning string
 * @param str2: The ending string
 * @returns The combined string
 *
 * @example String.concat("Foo", "Bar") == "FooBar"
 *
 * @since v0.2.0
 */
provide let concat = (++)

/**
 * Returns the character length of the input string.
 *
 * @param string: The string to inspect
 * @returns The number of characters in the string
 *
 * @example String.length("Hello world") == 11
 *
 * @since v0.1.0
 */
@unsafe
provide let length = (string: String) => {
  use WasmI32.{ (+), (&), (!=) }
  let string = WasmI32.fromGrain(string)
  let size = WasmI32.load(string, 4n)

  let mut len = 0n
  let mut ptr = string + 8n
  let end = ptr + size

  while (WasmI32.ltU(ptr, end)) {
    let byte = WasmI32.load8U(ptr, 0n)
    if ((byte & 0xC0n) != 0x80n) {
      len += 1n
    }
    ptr += 1n
  }

  Conv.wasmI32ToNumber(len)
}

/**
 * Returns the byte length of the input string.
 *
 * @param string: The string to inspect
 * @returns The number of bytes in the string
 *
 * @example String.byteLength("ðŸŒ¾") == 4
 *
 * @since v0.1.0
 */
@unsafe
provide let byteLength = (string: String) => {
  let string = WasmI32.fromGrain(string)
  Conv.wasmI32ToNumber(WasmI32.load(string, 4n))
}

/**
 * Determines if the string contains no characters.
 *
 * @param string: The string to inspect
 * @returns `true` if the string is empty and `false` otherwise
 *
 * @since v0.6.0
 */
@unsafe
provide let isEmpty = (string: String) => {
  use WasmI32.{ (==) }
  let strPtr = WasmI32.fromGrain(string)
  WasmI32.load(strPtr, 4n) == 0n
}

/**
 * Finds the first position of a substring in the input string.
 *
 * @param search: The substring to find
 * @param string: The string to inspect
 * @returns `Some(position)` containing the starting position of the substring if found or `None` otherwise
 *
 * @example String.indexOf("world", "Hello world") == Some(6)
 *
 * @since v0.3.0
 */
@unsafe
provide let indexOf = (search: String, string: String) => {
  let search = WasmI32.fromGrain(search)
  let string = WasmI32.fromGrain(string)

  let size = WasmI32.load(string, 4n)
  let psize = WasmI32.load(search, 4n)
  use WasmI32.{ (+), (-), (&), ltU as (<), gtU as (>), (==) }

  if (psize > size) {
    return None
  }
  let mut idx = 0n
  let mut ptr = string + 8n
  let pptr = search + 8n
  let end = ptr + size - psize + 1n

  while (ptr < end) {
    if (Memory.compare(ptr, pptr, psize) == 0n) {
      return Some(tagSimpleNumber(idx))
    }
    idx += 1n
    let byte = WasmI32.load8U(ptr, 0n)
    if ((byte & 0x80n) == 0x00n) {
      ptr += 1n
    } else if ((byte & 0xF0n) == 0xF0n) {
      ptr += 4n
    } else if ((byte & 0xE0n) == 0xE0n) {
      ptr += 3n
    } else {
      ptr += 2n
    }
  }

  return None
}

/**
 * Finds the last position of a substring in the input string.
 *
 * @param search: The substring to find
 * @param string: The string to inspect
 * @returns `Some(position)` containing the starting position of the substring if found or `None` otherwise
 *
 * @example String.lastIndexOf("world", "Hello world world") == Some(12)
 *
 * @since v0.5.3
 */
@unsafe
provide let lastIndexOf = (search: String, string: String) => {
  // The last possible index in the string given the length of the search
  let lastIndex = length(string) - length(search)

  use WasmI32.{ (+), (-), (&), gtU as (>), geU as (>=), (==), (!=) }

  let search = WasmI32.fromGrain(search)
  let string = WasmI32.fromGrain(string)
  let searchSize = WasmI32.load(search, 4n)
  let stringSize = WasmI32.load(string, 4n)
  if (searchSize > stringSize) {
    return None
  }
  let mut stringIndex = untagSimpleNumber(lastIndex)
  let searchPtr = search + 8n
  let stringStartPtr = string + 8n
  for (
    let mut stringPtr = stringStartPtr + stringSize - searchSize;
    stringPtr >= stringStartPtr;
    stringPtr -= 1n
  ) {
    let byte = WasmI32.load8U(stringPtr, 0n)
    if ((byte & 0xC0n) == 0x80n) {
      // We're not at the start of a codepoint, so move on
      continue
    }
    if (Memory.compare(stringPtr, searchPtr, searchSize) == 0n) {
      return Some(tagSimpleNumber(stringIndex))
    }
    stringIndex -= 1n
  }

  return None
}

@unsafe
let getCodePoint = (ptr: WasmI32) => {
  // Algorithm from https://encoding.spec.whatwg.org/#utf-8-decoder
  use WasmI32.{ (+), (&), (|), (<<), leU as (<=), geU as (>=), (==) }

  let mut codePoint = 0n
  let mut bytesSeen = 0n
  let mut bytesNeeded = 0n
  let mut lowerBoundary = 0x80n
  let mut upperBoundary = 0xBFn

  let mut offset = 0n

  while (true) {
    let byte = WasmI32.load8U(ptr + offset, 0n)
    offset += 1n
    if (bytesNeeded == 0n) {
      if (byte >= 0x00n && byte <= 0x7Fn) {
        return byte
      } else if (byte >= 0xC2n && byte <= 0xDFn) {
        bytesNeeded = 1n
        codePoint = byte & 0x1Fn
      } else if (byte >= 0xE0n && byte <= 0xEFn) {
        if (byte == 0xE0n) lowerBoundary = 0xA0n
        if (byte == 0xEDn) upperBoundary = 0x9Fn
        bytesNeeded = 2n
        codePoint = byte & 0xFn
      } else if (byte >= 0xF0n && byte <= 0xF4n) {
        if (byte == 0xF0n) lowerBoundary = 0x90n
        if (byte == 0xF4n) upperBoundary = 0x8Fn
        bytesNeeded = 3n
        codePoint = byte & 0x7n
      } else {
        throw MalformedUnicode
      }
      continue
    }
    if (!(lowerBoundary <= byte && byte <= upperBoundary)) {
      throw MalformedUnicode
    }
    lowerBoundary = 0x80n
    upperBoundary = 0xBFn
    codePoint = codePoint << 6n | byte & 0x3Fn
    bytesSeen += 1n
    if (bytesSeen == bytesNeeded) {
      return codePoint
    }
  }
  return 0n
}

@unsafe
let charAtHelp = (position, string: String) => {
  if (length(string) <= position || position < 0) {
    fail "Invalid offset: " ++ toString(position)
  }
  // Implementation is similar to explodeHelp, but doesn't perform unneeded memory allocations
  use WasmI32.{ (+), (&), (>>>), ltU as (<), (==) }
  let size = WasmI32.fromGrain(byteLength(string)) >>> 1n
  let position = WasmI32.fromGrain(position) >>> 1n
  let string = WasmI32.fromGrain(string)
  let mut ptr = string + 8n
  let end = ptr + size
  let mut counter = 0n
  while (ptr < end) {
    if (counter == position) {
      return getCodePoint(ptr)
    }
    let byte = WasmI32.load8U(ptr, 0n)
    let n = if ((byte & 0x80n) == 0x00n) {
      1n
    } else if ((byte & 0xF0n) == 0xF0n) {
      4n
    } else if ((byte & 0xE0n) == 0xE0n) {
      3n
    } else {
      2n
    }
    counter += 1n
    ptr += n
  }

  fail "charAt: should be impossible (please report)"
}

/**
 * Get the Unicode code point at the position in the input string.
 *
 * @param position: The position to check
 * @param string: The string to search
 * @returns The character code at the provided position
 *
 * @throws MalformedUnicode: When the `string` is malformed
 * @throws Failure(String): When the `position` is out of bounds
 *
 * @example String.charCodeAt(5, "Hello world") == 32
 *
 * @since v0.5.3
 */
@unsafe
provide let charCodeAt = (position, string: String) => {
  tagSimpleNumber(charAtHelp(position, string))
}

/**
 * Get the character at the position in the input string.
 *
 * @param position: The position to check
 * @param string: The string to search
 * @returns The character at the provided position
 *
 * @throws MalformedUnicode: When the `string` is malformed
 * @throws Failure(String): When the `position` is out of bounds
 *
 * @example String.charAt(5, "Hello world") == ' '
 *
 * @since v0.4.0
 */
@unsafe
provide let charAt = (position, string: String) => {
  tagChar(charAtHelp(position, string))
}

@unsafe
let explodeHelp = (s: String, chars) => {
  use WasmI32.{ (+), (&), (>>>), ltU as (<), (==) }

  let size = WasmI32.fromGrain(byteLength(s)) >>> 1n
  let len = WasmI32.fromGrain(length(s)) >>> 1n

  let s = WasmI32.fromGrain(s)

  let mut ptr = s + 8n
  let end = ptr + size

  let arr = allocateArray(len)
  let mut arrIdx = 0n

  while (ptr < end) {
    let byte = WasmI32.load8U(ptr, 0n)
    let n = if ((byte & 0x80n) == 0x00n) {
      1n
    } else if ((byte & 0xF0n) == 0xF0n) {
      4n
    } else if ((byte & 0xE0n) == 0xE0n) {
      3n
    } else {
      2n
    }

    let c = if (chars) {
      WasmI32.fromGrain(tagChar(getCodePoint(ptr)))
    } else {
      let s = allocateString(n)
      Memory.copy(s + 8n, ptr, n)
      s
    }

    WasmI32.store(arr + arrIdx, c, 8n)
    arrIdx += 4n
    ptr += n
  }

  arr
}

/**
 * Split a string into its Unicode characters.
 *
 * @param string: The string to split
 * @returns An array containing all characters in the string
 *
 * @throws MalformedUnicode: When the `string` is malformed
 *
 * @example String.explode("Hello") == [> 'H', 'e', 'l', 'l', 'o']
 *
 * @since v0.3.0
 */
@unsafe
provide let explode = string => {
  WasmI32.toGrain(explodeHelp(string, true)): Array<Char>
}

/**
 * Create a string from an array of characters.
 *
 * @param arr: The array to combine
 * @returns A string representation of the array of characters
 *
 * @example String.implode([> 'H', 'e', 'l', 'l', 'o']) == "Hello"
 *
 * @since v0.3.0
 */
@unsafe
provide let implode = (arr: Array<Char>) => {
  use WasmI32.{
    (+),
    (-),
    (*),
    (&),
    (|),
    (<<),
    (>>>),
    ltU as (<),
    gtU as (>),
    leU as (<=),
  }

  let arrLength = WasmI32.load(WasmI32.fromGrain(arr), 4n)

  let mut stringByteLength = 0n

  for (let mut i = 0n; i < arrLength; i += 1n) {
    let usv = untagChar(arr[tagSimpleNumber(i)])

    let n = if (usv <= 0x7Fn) {
      1n
    } else if (usv <= 0x07FFn) {
      2n
    } else if (usv <= 0xFFFFn) {
      3n
    } else {
      4n
    }

    stringByteLength += n
  }

  let str = allocateString(stringByteLength)
  let mut offset = 8n

  for (let mut i = 0n; i < arrLength; i += 1n) {
    let usv = untagChar(arr[tagSimpleNumber(i)])

    if (usv < 0x7Fn) {
      WasmI32.store8(str + offset, usv, 0n)
      offset += 1n
    } else {
      let mut count = 0n
      let mut marker = 0n
      if (usv <= 0x07FFn) {
        count = 1n
        marker = 0xC0n
      } else if (usv <= 0xFFFFn) {
        count = 2n
        marker = 0xE0n
      } else {
        count = 3n
        marker = 0xF0n
      }
      WasmI32.store8(str + offset, (usv >>> (6n * count)) + marker, 0n)
      offset += 1n

      while (count > 0n) {
        let temp = usv >>> (6n * (count - 1n))
        WasmI32.store8(str + offset, 0x80n | temp & 0x3Fn, 0n)
        count -= 1n
        offset += 1n
      }
    }
  }

  WasmI32.toGrain(str): String
}

// Helper to get the length in constant time without depending on Array
primitive arrayLength = "@array.length"

/**
 * Create a string that is the given string reversed.
 *
 * @param string: The string to reverse
 * @returns A string whose characters are in the reverse order of the given string
 *
 * @example String.reverse("olleH") == "Hello"
 *
 * @since v0.4.5
 */
provide let reverse = string => {
  let mut arr = explode(string)
  let len = arrayLength(arr)
  let halfLen = len / 2
  for (let mut i = 0; i < halfLen; i += 1) {
    let lastIdx = len - i - 1
    let last = arr[lastIdx]
    let first = arr[i]
    arr[i] = last
    arr[lastIdx] = first
  }
  implode(arr)
}

/**
 * Split a string by the given separator.
 *
 * @param separator: The separator to split on
 * @param string: The string to split
 * @returns An array of substrings from the initial string
 *
 * @throws MalformedUnicode: When the `string` is malformed
 *
 * @example String.split(" ", "Hello world") == [> "Hello", "world"]
 */
@unsafe
provide let split = (separator: String, string: String) => {
  use WasmI32.{ (+), (-), (&), (<<), (>>), ltU as (<), gtU as (>), (==) }

  let size = WasmI32.fromGrain(byteLength(string)) >> 1n
  let psize = WasmI32.fromGrain(byteLength(separator)) >> 1n

  if (psize == 0n) {
    WasmI32.toGrain(explodeHelp(string, false)): Array<String>
  } else if (psize > size) {
    [> string]
  } else {
    let string = WasmI32.fromGrain(string)
    let separator = WasmI32.fromGrain(separator)

    let mut ptr = string + 8n
    let mut pptr = separator + 8n
    let end = ptr + size - psize + 1n

    let mut numStrings = 1n

    while (ptr < end) {
      if (Memory.compare(ptr, pptr, psize) == 0n) {
        numStrings += 1n
      }
      let byte = WasmI32.load8U(ptr, 0n)
      if ((byte & 0x80n) == 0x00n) {
        ptr += 1n
      } else if ((byte & 0xF0n) == 0xF0n) {
        ptr += 4n
      } else if ((byte & 0xE0n) == 0xE0n) {
        ptr += 3n
      } else {
        ptr += 2n
      }
    }

    ptr = string + 8n
    let mut last = ptr
    let arr = allocateArray(numStrings)
    let mut arrIdx = 0n

    while (ptr < end) {
      if (Memory.compare(ptr, pptr, psize) == 0n) {
        let strSize = ptr - last
        let str = allocateString(strSize)
        Memory.copy(str + 8n, last, strSize)
        WasmI32.store(arr + arrIdx, str, 8n)
        arrIdx += 4n
        ptr += psize
        last = ptr
        continue
      }
      let byte = WasmI32.load8U(ptr, 0n)
      if ((byte & 0x80n) == 0x00n) {
        ptr += 1n
      } else if ((byte & 0xF0n) == 0xF0n) {
        ptr += 4n
      } else if ((byte & 0xE0n) == 0xE0n) {
        ptr += 3n
      } else {
        ptr += 2n
      }
    }

    // Grab last string
    let strSize = string + 8n + size - last
    let lastStr = allocateString(strSize)
    Memory.copy(lastStr + 8n, last, strSize)
    WasmI32.store(arr + arrIdx, lastStr, 8n)

    WasmI32.toGrain(arr): Array<String>
  }
}

/**
 * Get a portion of a string.
 *
 * @param start: The start position of the substring
 * @param end: The end position of the substring, exclusive
 * @param string: The input string
 * @returns The substring from the initial string
 *
 * @throws InvalidArgument(String): When the `start` index is not an integer
 * @throws InvalidArgument(String): When the `to` index is not an integer
 * @throws IndexOutOfBounds: When `start` is out of bounds
 * @throws IndexOutOfBounds: When `end` is out of bounds
 * @throws InvalidArgument(String): When `start` is greater than `end`
 *
 * @example String.slice(0, end=5, "Hello world") == "Hello"
 * @example String.slice(0, "Hello world") == "Hello world"
 *
 * @since v0.1.0
 * @history v0.6.0: Default `end` to the String length
 */
@unsafe
provide let slice = (start: Number, end=length(string), string: String) => {
  use WasmI32.{ (+), (-), (&), (<<), (>>), (<), (>), (==), (!=) }

  let len = WasmI32.fromGrain(length(string)) >> 1n
  let size = WasmI32.fromGrain(byteLength(string)) >> 1n

  let string = WasmI32.fromGrain(string)

  let mut start = WasmI32.fromGrain(start)
  if ((start & 1n) != 1n) {
    throw InvalidArgument("Invalid start index")
  }
  start = start >> 1n

  let mut to = WasmI32.fromGrain(end)
  if ((to & 1n) != 1n) {
    throw InvalidArgument("Invalid end index")
  }
  to = to >> 1n

  if (start < 0n) {
    start += len
  }
  if (to < 0n) {
    to += len
  }

  if (start > len || to > len) {
    throw IndexOutOfBounds
  }

  if (to < start) {
    throw InvalidArgument("Start index exceeds end index")
  }

  let mut ptr = string + 8n
  let mut begin = ptr
  let mut end = ptr
  let stop = ptr + size

  let mut idx = 0n
  while (ptr < stop) {
    let byte = WasmI32.load8U(ptr, 0n)
    if ((byte & 0xC0n) != 0x80n) {
      if (idx == start) {
        begin = ptr
      }
      if (idx == to) {
        end = ptr
        break
      }
      idx += 1n
    }
    ptr += 1n
  }
  if (to == len) {
    end = string + 8n + size
  }
  if (start == to) {
    begin = end
  }

  let newSize = end - begin
  let newString = allocateString(newSize)

  Memory.copy(newString + 8n, begin, newSize)

  WasmI32.toGrain(newString): String
}

/**
 * Check if a string contains a substring.
 *
 * @param search: The substring to check
 * @param string: The string to search
 * @returns `true` if the input string contains the search value or `false` otherwise
 *
 * @example String.contains("world", "Hello world") == true
 *
 * @since v0.1.0
 */
@unsafe
provide let contains = (search: String, string: String) => {
  // "Not So Naive" string search algorithm
  // searching phase in O(nm) time complexity
  // slightly (by coefficient) sub-linear in the average case
  // http://igm.univ-mlv.fr/~lecroq/string/node13.html#SECTION00130
  use WasmI32.{
    (+),
    (-),
    (>>),
    ltU as (<),
    gtU as (>),
    leU as (<=),
    (==),
    (!=),
  }
  let pOrig = search
  let sOrig = string

  let n = WasmI32.fromGrain(byteLength(string)) >> 1n
  let m = WasmI32.fromGrain(byteLength(search)) >> 1n

  let mut string = WasmI32.fromGrain(string)
  let mut search = WasmI32.fromGrain(search)

  string += 8n
  search += 8n

  let mut j = 0n
  and k = 0n
  and ell = 0n

  if (m > n) {
    // Bail if pattern length is longer than input length
    return false
  }

  if (m < 2n) {
    // Handle very small patterns
    if (m == 0n) {
      return true
    }

    let pat = WasmI32.load8U(search, 0n)
    while (j < n) {
      if (pat == WasmI32.load8U(string + j, 0n)) {
        return true
      } else {
        j += 1n
      }
    }

    return false
  }

  // NSM preprocessing
  if (WasmI32.load8U(search, 0n) == WasmI32.load8U(search, 1n)) {
    k = 2n
    ell = 1n
  } else {
    k = 1n
    ell = 2n
  }

  // NSM searching
  while (j <= n - m) {
    if (WasmI32.load8U(search, 1n) != WasmI32.load8U(string + j, 1n)) {
      j += k
    } else {
      if (
        Memory.compare(search + 2n, string + j + 2n, m - 2n) == 0n &&
        WasmI32.load8U(search, 0n) == WasmI32.load8U(string + j, 0n)
      ) {
        return true
      }
      j += ell
    }
  }

  return false
}

/**
 * Check if a string begins with another string.
 *
 * @param search: The string to compare to the start
 * @param string: The string to search
 * @returns `true` if the input string starts with the search value or `false` otherwise
 *
 * @example String.startsWith("Hello", "Hello world") == true
 *
 * @since v0.1.0
 */
@unsafe
provide let startsWith = (search: String, string: String) => {
  use WasmI32.{ (+), gtU as (>), (==) }
  let pOrig = search
  let sOrig = string

  let mut search = WasmI32.fromGrain(search)
  let mut string = WasmI32.fromGrain(string)

  let n = WasmI32.load(string, 4n)
  let m = WasmI32.load(search, 4n)

  string += 8n
  search += 8n

  // Bail if pattern length is longer than input length
  if (m > n) {
    false
  } else {
    Memory.compare(search, string, m) == 0n
  }
}

/**
 * Check if a string ends with another string.
 *
 * @param search: The string to compare to the end
 * @param string: The string to search
 * @returns `true` if the input string ends with the search value or `false` otherwise
 *
 * @example String.endsWith("world", "Hello world") == true
 *
 * @since v0.1.0
 */
@unsafe
provide let endsWith = (search: String, string: String) => {
  use WasmI32.{ (+), (-), gtU as (>), (==) }
  let pOrig = search
  let sOrig = string

  let mut search = WasmI32.fromGrain(search)
  let mut string = WasmI32.fromGrain(string)

  let n = WasmI32.load(string, 4n)
  let m = WasmI32.load(search, 4n)

  string += 8n
  search += 8n

  // Bail if pattern length is longer than input length
  if (m > n) {
    false
  } else {
    Memory.compare(search, string + n - m, m) == 0n
  }
}

/**
 * Replaces the first appearance of the search pattern in the string with the replacement value.
 *
 * @param searchPattern: The string to replace
 * @param replacement: The replacement
 * @param string: The string to change
 * @returns A new string with the first occurrence of the search pattern replaced
 *
 * @example String.replaceFirst("ðŸŒ¾", "ðŸŒŽ", "Hello ðŸŒ¾ðŸŒ¾") == "Hello ðŸŒŽðŸŒ¾"
 *
 * @since v0.5.4
 */
@unsafe
provide let replaceFirst = (
  searchPattern: String,
  replacement: String,
  string: String,
) => {
  use WasmI32.{ (+), (-), gtU as (>), ltU as (<), (==) }

  let mut patternPtr = WasmI32.fromGrain(searchPattern)
  let mut stringPtr = WasmI32.fromGrain(string)
  let mut replacementPtr = WasmI32.fromGrain(replacement)

  let patternLen = WasmI32.load(patternPtr, 4n)
  let stringLen = WasmI32.load(stringPtr, 4n)
  let replacementLen = WasmI32.load(replacementPtr, 4n)
  // Bail if search str is longer than the string
  if (stringLen < patternLen) {
    return string
  }
  patternPtr += 8n
  stringPtr += 8n
  replacementPtr += 8n

  // Search for an instance of the string
  let mut foundIndex = -1n
  let stringEndPtr = stringPtr + stringLen - patternLen + 1n
  for (let mut i = stringPtr; i < stringEndPtr; i += 1n) {
    // check for match
    foundIndex += 1n
    if (Memory.compare(i, patternPtr, patternLen) == 0n) {
      // Create the new string
      let str = allocateString(stringLen - patternLen + replacementLen)
      let strPtr = str + 8n
      Memory.copy(strPtr, stringPtr, foundIndex)
      Memory.copy(strPtr + foundIndex, replacementPtr, replacementLen)
      Memory.copy(
        strPtr + foundIndex + replacementLen,
        stringPtr + foundIndex + patternLen,
        stringLen - foundIndex
      )
      // Copy over the str
      return WasmI32.toGrain(str): String
    }
  }

  return string
}

/**
 * Replaces the last appearance of the search pattern in the string with the replacement value.
 *
 * @param searchPattern: The string to replace
 * @param replacement: The replacement
 * @param string: The string to change
 * @returns A new string with the last occurrence of the search pattern replaced
 *
 * @example String.replaceLast("ðŸŒ¾", "ðŸŒŽ", "Hello ðŸŒ¾ðŸŒ¾") == "Hello ðŸŒ¾ðŸŒŽ"
 *
 * @since v0.5.4
 */
@unsafe
provide let replaceLast = (
  searchPattern: String,
  replacement: String,
  string: String,
) => {
  use WasmI32.{ (+), (-), gtU as (>), ltU as (<), (==) }

  let mut patternPtr = WasmI32.fromGrain(searchPattern)
  let mut stringPtr = WasmI32.fromGrain(string)
  let mut replacementPtr = WasmI32.fromGrain(replacement)

  let patternLen = WasmI32.load(patternPtr, 4n)
  let stringLen = WasmI32.load(stringPtr, 4n)
  let replacementLen = WasmI32.load(replacementPtr, 4n)

  // Bail if search str is longer than the string
  if (stringLen < patternLen) {
    return string
  }
  patternPtr += 8n
  stringPtr += 8n
  replacementPtr += 8n

  let mut found = false
  // Search for an instance of the string
  let stringEndPtr = stringPtr + stringLen - patternLen
  let mut foundIndex = stringLen - patternLen + 1n
  for (let mut i = stringEndPtr; i > stringPtr - 1n; i -= 1n) {
    // check for match
    foundIndex -= 1n
    if (Memory.compare(i, patternPtr, patternLen) == 0n) {
      // Create the new string
      let str = allocateString(stringLen - patternLen + replacementLen)
      let strPtr = str + 8n
      Memory.copy(strPtr, stringPtr, foundIndex)
      Memory.copy(strPtr + foundIndex, replacementPtr, replacementLen)
      Memory.copy(
        strPtr + foundIndex + replacementLen,
        stringPtr + foundIndex + patternLen,
        stringLen - foundIndex
      )
      // Copy over the str
      return WasmI32.toGrain(str): String
    }
  }

  return string
}

/**
 * Replaces every appearance of the search pattern in the string with the replacement value.
 *
 * @param searchPattern: The string to replace
 * @param replacement: The replacement
 * @param string: The string to change
 * @returns A new string with each occurrence of the search pattern replaced
 *
 * @example String.replaceAll("ðŸŒ¾", "ðŸŒŽ", "Hello ðŸŒ¾ðŸŒ¾") == "Hello ðŸŒŽðŸŒŽ"
 *
 * @since v0.5.4
 */
@unsafe
provide let replaceAll = (
  searchPattern: String,
  replacement: String,
  string: String,
) => {
  use WasmI32.{ (+), (-), (*), (>>), gtU as (>), ltU as (<), (==) }

  let mut patternPtr = WasmI32.fromGrain(searchPattern)
  let mut stringPtr = WasmI32.fromGrain(string)
  let mut replacementPtr = WasmI32.fromGrain(replacement)

  let patternLen = WasmI32.load(patternPtr, 4n)
  let stringLen = WasmI32.load(stringPtr, 4n)
  let replacementLen = WasmI32.load(replacementPtr, 4n)

  // Bail if search str is longer than the string
  if (stringLen < patternLen) {
    string
  } else {
    patternPtr += 8n
    stringPtr += 8n
    replacementPtr += 8n

    let mut found = false
    // Search for an instance of the string
    let stringEndPtr = stringPtr + stringLen - patternLen
    let mut foundIndex = stringLen - patternLen + 1n
    let mut foundIndexes = []
    let mut foundCount = 0n
    for (let mut i = stringEndPtr; i > stringPtr - 1n; i -= 1n) {
      // check for match
      foundIndex -= 1n
      if (Memory.compare(i, patternPtr, patternLen) == 0n) {
        found = true
        foundCount += 1n
        foundIndexes = [tagSimpleNumber(foundIndex), ...foundIndexes]
        foundIndex -= patternLen - 1n
        i -= patternLen - 1n
      }
    }
    if (found) {
      // Create the new string
      let str = allocateString(
        stringLen - (patternLen - replacementLen) * foundCount
      )
      let mut strPtr = str + 8n
      let mut lastIndex = 0n
      while (true) {
        match (foundIndexes) {
          [idx, ...rest] => {
            let index = untagSimpleNumber(idx)
            // Copy the part before
            Memory.copy(strPtr, stringPtr + lastIndex, index - lastIndex)
            strPtr += index - lastIndex
            // Copy the part after
            Memory.copy(strPtr, replacementPtr, replacementLen)
            strPtr += replacementLen
            lastIndex = index + patternLen
            foundIndexes = rest
          },
          [] => break,
        }
      }
      // Copy remaining string
      Memory.copy(strPtr, stringPtr + lastIndex, stringLen - lastIndex)
      WasmI32.toGrain(str): String
    } else {
      string
    }
  }
}

// String->Byte encoding and helper functions:

// these are globals to avoid memory leaks
let _START_NAME = "start"
let _SIZE_NAME = "size"
let _OFFSET_NAME = "offset"

@unsafe
let grainToWasmNumber = (num, name) => {
  use WasmI32.{ (&), (>>), (<) }
  let num = WasmI32.fromGrain(num)
  if (WasmI32.eqz(num & 1n)) {
    let str = " argument must be an integer"
    throw Exception.InvalidArgument(name ++ str)
  }
  let num = num >> 1n
  if (num < 0n) {
    let str = " argument must be non-negative"
    throw Exception.InvalidArgument(name ++ str)
  }
  num
}

@unsafe
let utf16Length = (s: String) => {
  use WasmI32.{ (+), (&), (>>>), (<<), ltU as (<), (==) }

  let size = WasmI32.fromGrain(byteLength(s)) >>> 1n
  let len = WasmI32.fromGrain(length(s)) >>> 1n

  let s = WasmI32.fromGrain(s)

  let mut ptr = s + 8n
  let end = ptr + size
  let mut size = 0n // <- number of UTF-16 code words

  while (ptr < end) {
    let byte = WasmI32.load8U(ptr, 0n)
    let n = if ((byte & 0x80n) == 0x00n) {
      1n
    } else if ((byte & 0xF0n) == 0xF0n) {
      4n
    } else if ((byte & 0xE0n) == 0xE0n) {
      3n
    } else {
      2n
    }
    if (n == 4n) {
      size += 2n
    } else {
      size += 1n
    }
    ptr += n
  }
  // multiply by two to get number of bytes
  tagSimpleNumber(size << 1n)
}

@unsafe
let encodedLength = (s: String, encoding) => {
  match (encoding) {
    UTF32_BE => length(s) * 4,
    UTF32_LE => length(s) * 4,
    UTF16_BE => utf16Length(s),
    UTF16_LE => utf16Length(s),
    UTF8 => byteLength(s),
  }
}

@unsafe
let mut _BYTES_SIZE_OFFSET = 4n
@unsafe
let mut _BYTES_OFFSET = 8n

@unsafe
let encodeAtHelp = (
  string: String,
  encoding: Encoding,
  includeBom: Bool,
  dest: Bytes,
  destPos: Number,
) => {
  use WasmI32.{ (+), (-), (&), (>>>), ltU as (<), (>), leU as (<=), (==) }
  let byteSize = WasmI32.fromGrain(byteLength(string)) >>> 1n
  let len = WasmI32.fromGrain(length(string)) >>> 1n

  let string = WasmI32.fromGrain(string)

  let mut ptr = string + 8n
  let end = ptr + byteSize

  let bytes = WasmI32.fromGrain(dest)
  let mut bytesIdx = grainToWasmNumber(destPos, _OFFSET_NAME)

  let destSize = WasmI32.load(bytes, _BYTES_SIZE_OFFSET)

  if (includeBom) {
    match (encoding) {
      UTF8 => {
        if (bytesIdx + 3n > destSize) {
          throw IndexOutOfBounds
        }
        WasmI32.store8(bytes + bytesIdx, 0xEFn, _BYTES_OFFSET)
        WasmI32.store8(bytes + bytesIdx + 1n, 0xBBn, _BYTES_OFFSET)
        WasmI32.store8(bytes + bytesIdx + 2n, 0xBFn, _BYTES_OFFSET)
        bytesIdx += 3n
      },
      UTF16_BE => {
        if (bytesIdx + 2n > destSize) {
          throw IndexOutOfBounds
        }
        WasmI32.store8(bytes + bytesIdx, 0xFEn, _BYTES_OFFSET)
        WasmI32.store8(bytes + bytesIdx + 1n, 0xFFn, _BYTES_OFFSET)
        bytesIdx += 2n
      },
      UTF16_LE => {
        if (bytesIdx + 2n > destSize) {
          throw IndexOutOfBounds
        }
        WasmI32.store8(bytes + bytesIdx, 0xFFn, _BYTES_OFFSET)
        WasmI32.store8(bytes + bytesIdx + 1n, 0xFEn, _BYTES_OFFSET)
        bytesIdx += 2n
      },
      UTF32_BE => {
        if (bytesIdx + 4n > destSize) {
          throw IndexOutOfBounds
        }
        WasmI32.store8(bytes + bytesIdx, 0n, _BYTES_OFFSET)
        WasmI32.store8(bytes + bytesIdx + 1n, 0n, _BYTES_OFFSET)
        WasmI32.store8(bytes + bytesIdx + 2n, 0xFEn, _BYTES_OFFSET)
        WasmI32.store8(bytes + bytesIdx + 3n, 0xFFn, _BYTES_OFFSET)
        bytesIdx += 4n
      },
      UTF32_LE => {
        if (bytesIdx + 4n > destSize) {
          throw IndexOutOfBounds
        }
        WasmI32.store8(bytes + bytesIdx, 0xFFn, _BYTES_OFFSET)
        WasmI32.store8(bytes + bytesIdx + 1n, 0xFEn, _BYTES_OFFSET)
        WasmI32.store8(bytes + bytesIdx + 2n, 0n, _BYTES_OFFSET)
        WasmI32.store8(bytes + bytesIdx + 3n, 0n, _BYTES_OFFSET)
        bytesIdx += 4n
      },
    }
  }

  match (encoding) {
    UTF8 => {
      // Optimization: since internally strings in Grain are UTF8 encoded, when
      // the target encoding is UTF8 as well, then copy the entire memory range
      // in bulk. No need to iterate individual characters.
      if (bytesIdx + byteSize > destSize) {
        throw IndexOutOfBounds
      }
      Memory.copy(bytes + bytesIdx + _BYTES_OFFSET, ptr, byteSize)
    },
    _ => {
      while (ptr < end) {
        let byte = WasmI32.load8U(ptr, 0n)
        // number of bytes spanning this UTF-8-encoded scalar value
        let n = if ((byte & 0x80n) == 0x00n) {
          1n
        } else if ((byte & 0xF0n) == 0xF0n) {
          4n
        } else if ((byte & 0xE0n) == 0xE0n) {
          3n
        } else {
          2n
        }
        match (encoding) {
          UTF8 => {
            // With the optimization above for bulk memory copy, this match
            // should never occur for the UTF8 case.
            if (bytesIdx + n > destSize) {
              throw IndexOutOfBounds
            }
            Memory.copy(bytes + bytesIdx + _BYTES_OFFSET, ptr, n)
            bytesIdx += n
          },
          UTF16_BE => {
            let codePoint = getCodePoint(ptr)
            if (codePoint <= 0xFFFFn) {
              // <hi><lo>
              if (bytesIdx + 2n > destSize) {
                throw IndexOutOfBounds
              }
              WasmI32.store8(
                bytes + bytesIdx,
                (codePoint & 0xff00n) >>> 8n,
                _BYTES_OFFSET
              )
              WasmI32.store8(
                bytes + bytesIdx + 1n,
                codePoint & 0xffn,
                _BYTES_OFFSET
              )
              bytesIdx += 2n
            } else {
              // https://en.wikipedia.org/wiki/UTF-16#Code_points_from_U+010000_to_U+10FFFF
              if (bytesIdx + 4n > destSize) {
                throw IndexOutOfBounds
              }
              let uPrime = codePoint - 0x10000n
              let w1 = ((uPrime & 0b11111111110000000000n) >>> 10n) + 0xD800n // High surrogate
              let w2 = (uPrime & 0b00000000001111111111n) + 0xDC00n // Low surrogate
              WasmI32.store8(
                bytes + bytesIdx,
                (w1 & 0xff00n) >>> 8n,
                _BYTES_OFFSET
              )
              WasmI32.store8(bytes + bytesIdx + 1n, w1 & 0xffn, _BYTES_OFFSET)
              WasmI32.store8(
                bytes + bytesIdx + 2n,
                (w2 & 0xff00n) >>> 8n,
                _BYTES_OFFSET
              )
              WasmI32.store8(bytes + bytesIdx + 3n, w2 & 0xffn, _BYTES_OFFSET)
              bytesIdx += 4n
            }
          },
          UTF16_LE => {
            let codePoint = getCodePoint(ptr)
            if (codePoint <= 0xFFFFn) {
              if (bytesIdx + 2n > destSize) {
                throw IndexOutOfBounds
              }
              // <lo><hi>
              WasmI32.store8(bytes + bytesIdx, codePoint & 0xffn, _BYTES_OFFSET)
              WasmI32.store8(
                bytes + bytesIdx + 1n,
                (codePoint & 0xff00n) >>> 8n,
                _BYTES_OFFSET
              )
              bytesIdx += 2n
            } else {
              // https://en.wikipedia.org/wiki/UTF-16#Code_points_from_U+010000_to_U+10FFFF
              if (bytesIdx + 4n > destSize) {
                throw IndexOutOfBounds
              }
              let uPrime = codePoint - 0x10000n
              let w1 = ((uPrime & 0b11111111110000000000n) >>> 10n) + 0xD800n // High surrogate
              let w2 = (uPrime & 0b00000000001111111111n) + 0xDC00n // Low surrogate
              WasmI32.store8(bytes + bytesIdx, w1 & 0xffn, _BYTES_OFFSET)
              WasmI32.store8(
                bytes + bytesIdx + 1n,
                (w1 & 0xff00n) >>> 8n,
                _BYTES_OFFSET
              )
              WasmI32.store8(bytes + bytesIdx + 2n, w2 & 0xffn, _BYTES_OFFSET)
              WasmI32.store8(
                bytes + bytesIdx + 3n,
                (w2 & 0xff00n) >>> 8n,
                _BYTES_OFFSET
              )
              bytesIdx += 4n
            }
          },
          UTF32_BE => {
            if (bytesIdx + 4n > destSize) {
              throw IndexOutOfBounds
            }
            let codePoint = getCodePoint(ptr)
            WasmI32.store8(
              bytes + bytesIdx,
              (codePoint & 0xff000000n) >>> 24n,
              _BYTES_OFFSET
            )
            WasmI32.store8(
              bytes + bytesIdx + 1n,
              (codePoint & 0xff0000n) >>> 16n,
              _BYTES_OFFSET
            )
            WasmI32.store8(
              bytes + bytesIdx + 2n,
              (codePoint & 0xff00n) >>> 8n,
              _BYTES_OFFSET
            )
            WasmI32.store8(
              bytes + bytesIdx + 3n,
              codePoint & 0xffn,
              _BYTES_OFFSET
            )
            bytesIdx += 4n
          },
          UTF32_LE => {
            if (bytesIdx + 4n > destSize) {
              throw IndexOutOfBounds
            }
            let codePoint = getCodePoint(ptr)
            WasmI32.store8(bytes + bytesIdx, codePoint & 0xffn, _BYTES_OFFSET)
            WasmI32.store8(
              bytes + bytesIdx + 1n,
              (codePoint & 0xff00n) >>> 8n,
              _BYTES_OFFSET
            )
            WasmI32.store8(
              bytes + bytesIdx + 2n,
              (codePoint & 0xff0000n) >>> 16n,
              _BYTES_OFFSET
            )
            WasmI32.store8(
              bytes + bytesIdx + 3n,
              (codePoint & 0xff000000n) >>> 24n,
              _BYTES_OFFSET
            )
            bytesIdx += 4n
          },
        }
        ptr += n
      }
    },
  }

  dest
}

/**
 * Encodes the given string into a byte sequence at the supplied position using the encoding scheme provided.
 *
 * @param string: The input string
 * @param encoding: The encoding to use
 * @param dest: The byte sequence that will be copied
 * @param destPos: The location in the byte sequence to write the output
 * @param includeBom: Whether or not to include a byte order marker (false by default)
 * @returns A copy of the input bytes with the encoded string replaced at the given position
 *
 * @throws InvalidArgument(String): When `destPos` is not an integer
 * @throws InvalidArgument(String): When `destPos` is negative
 *
 * @since v0.4.0
 * @history v0.6.0: Added `includeBom` default argument
 */
provide let encodeAt = (string, encoding, dest, destPos, includeBom=false) => {
  encodeAtHelp(string, encoding, includeBom, dest, destPos)
}

@unsafe
let encodeHelp = (string: String, encoding: Encoding, includeBom: Bool) => {
  let size = encodedLength(string, encoding) + (if (includeBom) {
    match (encoding) {
      UTF8 => 3,
      UTF16_LE => 2,
      UTF16_BE => 2,
      UTF32_LE => 4,
      UTF32_BE => 4,
    }
  } else {
    0
  })
  use WasmI32.{ (>>>) }
  let bytes = WasmI32.toGrain(allocateBytes(WasmI32.fromGrain(size) >>> 1n))
  encodeAtHelp(string, encoding, includeBom, bytes, 0)
}

/**
 * Encodes the given string using the given encoding scheme.
 *
 * @param string: The input string
 * @param encoding: The encoding to use
 * @param includeBom: Whether or not to include a byte order marker (false by default)
 * @returns The byte representation of the string in the given encoding
 *
 * @since v0.4.0
 * @history v0.6.0: Added `includeBom` default argument
 */
provide let encode = (string: String, encoding: Encoding, includeBom=false) => {
  encodeHelp(string, encoding, includeBom)
}

// Byte->String decoding and helper functions:

@unsafe
let writeUtf8CodePoint = (ptr, codePoint) => {
  use WasmI32.{ (+), (-), (&), (|), (>>>), ltU as (<), leU as (<=), (==) }
  if (codePoint <= 0x007Fn) {
    // Code points in the ASCII range are written as just one byte with the
    // leading bit equal to zero (0xxxxxxx). Just store the value as one byte
    // directly. Note that the value is already guaranteed to start with most
    // significant bit equal to zero because of the check in the if statement
    // above, so there's no need to bit-mask it.
    WasmI32.store8(ptr, codePoint, 0n)
    1n
  } else if (codePoint <= 0x07FFn) {
    // Code points in the range 0x0080..0x07FF are written as two bytes.
    // The first byte has a three bit prefix of 110, followed by 5 bits of the
    // codepoint. The second byte has a two bit prefix of 10, followed by 6 bits
    // of the codepoint.
    let high = codePoint >>> 6n & 0b000_11111n | 0b110_00000n
    let low = codePoint & 0b00_111111n | 0b10_000000n
    WasmI32.store8(ptr, high, 0n)
    WasmI32.store8(ptr + 1n, low, 0n)
    2n
  } else if (codePoint <= 0xFFFFn) {
    // Code points in the range 0x0800..0xFFFF are written as three bytes.
    // The first byte has a four bit prefix of 1110, followed by 4 bits of the
    // codepoint. Remaining bytes each have a two bit prefix of 10, followed by
    // 6 bits of the codepoint.
    let high = codePoint >>> 12n & 0b0000_1111n | 0b1110_0000n
    let mid = codePoint >>> 6n & 0b00_111111n | 0b10_000000n
    let low = codePoint & 0b00_111111n | 0b10_000000n
    WasmI32.store8(ptr, high, 0n)
    WasmI32.store8(ptr + 1n, mid, 0n)
    WasmI32.store8(ptr + 2n, low, 0n)
    3n
  } else {
    // Code points in the range 0x10000..0x10FFFF are written as four bytes.
    // The first byte has a five bit prefix of 11110, followed by 3 bits of the
    // codepoint. Remaining bytes each have a two bit prefix of 10, followed by
    // 6 bits of the codepoint.
    let high = codePoint >>> 18n & 0b00000_111n | 0b11110_000n
    let mid1 = codePoint >>> 12n & 0b00_111111n | 0b10_000000n
    let mid2 = codePoint >>> 6n & 0b00_111111n | 0b10_000000n
    let low = codePoint & 0b00_111111n | 0b10_000000n
    WasmI32.store8(ptr, high, 0n)
    WasmI32.store8(ptr + 1n, mid1, 0n)
    WasmI32.store8(ptr + 2n, mid2, 0n)
    WasmI32.store8(ptr + 3n, low, 0n)
    4n
  }
}

@unsafe
let bytesHaveBom = (bytes: Bytes, encoding: Encoding, start: WasmI32) => {
  use WasmI32.{ (+), geU as (>=), (==) }
  let ptr = WasmI32.fromGrain(bytes)
  let bytesSize = WasmI32.load(ptr, 4n)
  let ptr = ptr + start
  match (encoding) {
    UTF8 => {
      bytesSize >= 3n &&
        WasmI32.load8U(ptr, _BYTES_OFFSET) == 0xEFn &&
        WasmI32.load8U(ptr + 1n, _BYTES_OFFSET) == 0xBBn &&
        WasmI32.load8U(ptr + 2n, _BYTES_OFFSET) == 0xBFn
    },
    UTF16_BE => {
      bytesSize >= 2n &&
        WasmI32.load8U(ptr, _BYTES_OFFSET) == 0xFEn &&
        WasmI32.load8U(ptr + 1n, _BYTES_OFFSET) == 0xFFn
    },
    UTF16_LE => {
      bytesSize >= 2n &&
        WasmI32.load8U(ptr, _BYTES_OFFSET) == 0xFFn &&
        WasmI32.load8U(ptr + 1n, _BYTES_OFFSET) == 0xFEn
    },
    UTF32_BE => {
      bytesSize >= 4n &&
        WasmI32.load8U(ptr, _BYTES_OFFSET) == 0x00n &&
        WasmI32.load8U(ptr + 1n, _BYTES_OFFSET) == 0x00n &&
        WasmI32.load8U(ptr + 2n, _BYTES_OFFSET) == 0xFEn &&
        WasmI32.load8U(ptr + 3n, _BYTES_OFFSET) == 0xFFn
    },
    UTF32_LE => {
      bytesSize >= 4n &&
        WasmI32.load8U(ptr, _BYTES_OFFSET) == 0xFFn &&
        WasmI32.load8U(ptr + 1n, _BYTES_OFFSET) == 0xFEn &&
        WasmI32.load8U(ptr + 2n, _BYTES_OFFSET) == 0x00n &&
        WasmI32.load8U(ptr + 3n, _BYTES_OFFSET) == 0x00n
    },
  }
}

@unsafe
let decodedLength = (
  bytes: Bytes,
  encoding: Encoding,
  start: WasmI32,
  size: WasmI32,
) => {
  use WasmI32.{
    (+),
    (-),
    (&),
    (|),
    (>>>),
    (<<),
    ltU as (<),
    gtU as (>),
    geU as (>=),
    leU as (<=),
    (==),
    (!=),
  }
  let ptr = WasmI32.fromGrain(bytes)
  let bytesSize = {
    let tmp = WasmI32.load(ptr, 4n) - start
    if (size < tmp) {
      size
    } else {
      tmp
    }
  }
  let start = ptr + _BYTES_OFFSET + start
  match (encoding) {
    UTF8 => bytesSize,
    UTF16_BE => {
      let end = start + bytesSize
      let mut ptr = start
      let mut count = 0n
      while (ptr < end) {
        let codeWord = WasmI32.load8U(ptr, 0n) << 8n | WasmI32.load8U(ptr, 1n)
        let codeWord = if (codeWord >= 0xD800n && codeWord <= 0xDBFFn) {
          // high surrogate. need to check that next character is low srurrogate
          let ret = if (ptr + 2n >= end) {
            throw MalformedUnicode
          } else {
            let nextCodeWord = WasmI32.load8U(ptr, 2n) << 8n |
              WasmI32.load8U(ptr, 3n)
            if (nextCodeWord < 0xDC00n || nextCodeWord > 0xDFFFn) {
              // high surrogate without low surrogate
              throw MalformedUnicode
            } else {
              let w1 = (codeWord & 0x03FFn) << 10n
              let w2 = nextCodeWord & 0x03FFn
              w1 + w2 + 0x10000n
            }
          }
          // no problems, so go past both code words
          ptr += 4n
          ret
        } else {
          ptr += 2n
          codeWord
        }
        if (codeWord <= 0x007Fn) {
          count += 1n
        } else if (codeWord <= 0x07FFn) {
          count += 2n
        } else if (codeWord <= 0xFFFFn) {
          count += 3n
        } else {
          count += 4n
        }
      }
      count
    },
    UTF16_LE => {
      let end = start + bytesSize
      let mut ptr = start
      let mut count = 0n
      while (ptr < end) {
        let codeWord = WasmI32.load8U(ptr, 1n) << 8n | WasmI32.load8U(ptr, 0n)
        let codeWord = if (codeWord >= 0xD800n && codeWord <= 0xDBFFn) {
          // high surrogate. need to check that next character is low srurrogate
          let ret = if (ptr + 2n >= end) {
            throw MalformedUnicode
          } else {
            let nextCodeWord = WasmI32.load8U(ptr, 3n) << 8n |
              WasmI32.load8U(ptr, 2n)
            if (nextCodeWord < 0xDC00n || nextCodeWord > 0xDFFFn) {
              // high surrogate without low surrogate
              throw MalformedUnicode
            } else {
              let w1 = (codeWord & 0x03FFn) << 10n
              let w2 = nextCodeWord & 0x03FFn
              w1 + w2 + 0x10000n
            }
          }
          // no problems, so go past both code words
          ptr += 4n
          ret
        } else {
          ptr += 2n
          codeWord
        }
        if (codeWord <= 0x007Fn) {
          count += 1n
        } else if (codeWord <= 0x07FFn) {
          count += 2n
        } else if (codeWord <= 0xFFFFn) {
          count += 3n
        } else {
          count += 4n
        }
      }
      count
    },
    UTF32_BE => {
      // if not divisible by four, not proper UTF-32 sequence
      if ((bytesSize & 0b11n) != 0n) {
        throw MalformedUnicode
      }
      let end = start + bytesSize
      let mut ptr = start
      let mut count = 0n
      while (ptr < end) {
        let codeWord = WasmI32.load8U(ptr, 0n) << 24n |
          WasmI32.load8U(ptr, 1n) << 16n |
          WasmI32.load8U(ptr, 2n) << 8n |
          WasmI32.load8U(ptr, 3n)
        ptr += 4n
        if (codeWord <= 0x007Fn) {
          count += 1n
        } else if (codeWord <= 0x07FFn) {
          count += 2n
        } else if (codeWord <= 0xFFFFn) {
          count += 3n
        } else {
          count += 4n
        }
      }
      count
    },
    UTF32_LE => {
      // if not divisible by four, not proper UTF-32 sequence
      if ((bytesSize & 0b11n) != 0n) {
        throw MalformedUnicode
      }
      let end = start + bytesSize
      let mut ptr = start
      let mut count = 0n
      while (ptr < end) {
        let codeWord = WasmI32.load8U(ptr, 3n) << 24n |
          WasmI32.load8U(ptr, 2n) << 16n |
          WasmI32.load8U(ptr, 1n) << 8n |
          WasmI32.load8U(ptr, 0n)
        ptr += 4n
        if (codeWord <= 0x007Fn) {
          count += 1n
        } else if (codeWord <= 0x07FFn) {
          count += 2n
        } else if (codeWord <= 0xFFFFn) {
          count += 3n
        } else {
          count += 4n
        }
      }
      count
    },
  }
}

@unsafe
let decodeRangeHelp = (
  bytes: Bytes,
  encoding: Encoding,
  skipBom: Bool,
  start: Number,
  size: Number,
) => {
  use WasmI32.{
    (+),
    (-),
    (&),
    (|),
    (>>>),
    (<<),
    ltU as (<),
    geU as (>=),
    leU as (<=),
    (==),
  }
  let start = grainToWasmNumber(start, _START_NAME)
  let size = grainToWasmNumber(size, _SIZE_NAME)
  let hasBom = bytesHaveBom(bytes, encoding, start)
  let stringSize = decodedLength(bytes, encoding, start, size)
  let stringSize = if (skipBom && hasBom) stringSize - 3n else stringSize
  let str = allocateString(stringSize)
  let mut bytesPtr = WasmI32.fromGrain(bytes)
  let bytesSize = {
    let tmp = WasmI32.load(bytesPtr, 4n) - start
    if (size < tmp) {
      size
    } else {
      tmp
    }
  }
  bytesPtr += _BYTES_OFFSET + start
  let mut strPtr = str + 8n
  let mut bomRead = false
  if (skipBom && hasBom) {
    bytesPtr += match (encoding) {
      UTF8 => 3n,
      UTF16_LE => 2n,
      UTF16_BE => 2n,
      UTF32_LE => 4n,
      UTF32_BE => 4n,
    }
  }
  if (stringSize == 0n) {
    WasmI32.toGrain(str): String
  } else {
    match (encoding) {
      UTF8 => {
        Memory.copy(strPtr, bytesPtr, stringSize)
      },
      UTF16_BE => {
        // NOTE: Because the size check passed, we know the string is well-formed
        let end = bytesPtr + bytesSize
        while (bytesPtr < end) {
          let w1 = WasmI32.load8U(bytesPtr, 0n) << 8n |
            WasmI32.load8U(bytesPtr, 1n)
          let codeWord = if (w1 >= 0xD800n && w1 <= 0xDBFFn) {
            // high surrogate. next character is low srurrogate
            let w1 = (w1 & 0x03FFn) << 10n
            let w2 = (
              WasmI32.load8U(bytesPtr, 2n) << 8n |
              WasmI32.load8U(bytesPtr, 3n)
            ) &
              0x03FFn
            let codeWord = w1 + w2 + 0x10000n
            // no problems, so go past both code words
            bytesPtr += 4n
            codeWord
          } else {
            bytesPtr += 2n
            w1
          }
          strPtr += writeUtf8CodePoint(strPtr, codeWord)
        }
      },
      UTF16_LE => {
        // NOTE: Because the size check passed, we know the string is well-formed
        let end = bytesPtr + bytesSize
        while (bytesPtr < end) {
          let w1 = WasmI32.load8U(bytesPtr, 1n) << 8n |
            WasmI32.load8U(bytesPtr, 0n)
          let codeWord = if (w1 >= 0xD800n && w1 <= 0xDBFFn) {
            // high surrogate. next character is low srurrogate
            let w1 = (w1 & 0x03FFn) << 10n
            let w2 = (
              WasmI32.load8U(bytesPtr, 3n) << 8n |
              WasmI32.load8U(bytesPtr, 2n)
            ) &
              0x03FFn
            //let uPrime = codePoint - 0x10000n
            //let w1 = ((uPrime & 0b11111111110000000000n) >>> 10n) + 0xD800n // High surrogate
            //let w2 = (uPrime & 0b00000000001111111111n) + 0xDC00n // Low surrogate
            let codeWord = w1 + w2 + 0x10000n
            // no problems, so go past both code words
            bytesPtr += 4n
            codeWord
          } else {
            bytesPtr += 2n
            w1
          }
          strPtr += writeUtf8CodePoint(strPtr, codeWord)
        }
      },
      UTF32_BE => {
        let end = bytesPtr + bytesSize
        while (bytesPtr < end) {
          let codeWord = WasmI32.load8U(bytesPtr, 0n) << 24n |
            WasmI32.load8U(bytesPtr, 1n) << 16n |
            WasmI32.load8U(bytesPtr, 2n) << 8n |
            WasmI32.load8U(bytesPtr, 3n)
          bytesPtr += 4n
          strPtr += writeUtf8CodePoint(strPtr, codeWord)
        }
      },
      UTF32_LE => {
        let end = bytesPtr + bytesSize
        while (bytesPtr < end) {
          let codeWord = WasmI32.load8U(bytesPtr, 3n) << 24n |
            WasmI32.load8U(bytesPtr, 2n) << 16n |
            WasmI32.load8U(bytesPtr, 1n) << 8n |
            WasmI32.load8U(bytesPtr, 0n)
          bytesPtr += 4n
          strPtr += writeUtf8CodePoint(strPtr, codeWord)
        }
      },
    }
    WasmI32.toGrain(str): String
  }
}

/**
 * Decodes the given byte sequence of the specified range into a string using the encoding scheme provided.
 *
 * @param bytes: The input bytes
 * @param encoding: The encoding to use
 * @param start: The byte offset to begin decoding from
 * @param size: The maximum number of bytes to decode
 * @param keepBom: Whether or not to include a byte order marker (false by default)
 * @returns The decoded string
 *
 * @throws InvalidArgument(String): When `start` is not an integer
 * @throws InvalidArgument(String): When `start` is negative
 * @throws InvalidArgument(String): When `size` is not an integer
 * @throws InvalidArgument(String): When `size` is negative
 *
 * @since v0.4.0
 * @history v0.6.0: Added `keepBom` default argument
 */
provide let decodeRange = (
  bytes: Bytes,
  encoding: Encoding,
  start: Number,
  size: Number,
  keepBom=false,
) => {
  decodeRangeHelp(bytes, encoding, !keepBom, start, size)
}

@unsafe
let decodeHelp = (bytes: Bytes, encoding: Encoding, skipBom: Bool) => {
  let bytesPtr = WasmI32.fromGrain(bytes)
  let bytesSize = WasmI32.load(bytesPtr, 4n)
  decodeRangeHelp(bytes, encoding, skipBom, 0, tagSimpleNumber(bytesSize))
}

/**
 * Decodes the given byte sequence into a string using the given encoding scheme.
 *
 * @param bytes: The input bytes
 * @param encoding: The encoding to use
 * @param keepBom: Whether or not to include a byte order marker (false by default)
 * @returns The decoded string
 *
 * @since v0.4.0
 * @history v0.6.0: Added `keepBom` default argument
 */
provide let decode = (bytes: Bytes, encoding: Encoding, keepBom=false) => {
  decodeHelp(bytes, encoding, !keepBom)
}

/**
 * Iterates over Unicode code points in a string.
 *
 * @param fn: The iterator function
 * @param str: The string to iterate
 *
 * @example String.forEachCodePoint(print, "Hello world")
 *
 * @since v0.4.0
 */
@unsafe
provide let forEachCodePoint = (fn: Number => Void, str: String) => {
  use WasmI32.{ (+), (-), (&), (>>>), ltU as (<), leU as (<=), (==) }

  let strPtr = WasmI32.fromGrain(str)

  let byteSize = WasmI32.load(strPtr, 4n)

  let mut ptr = strPtr + 8n
  let end = ptr + byteSize

  let mut idx = 0n
  while (ptr < end) {
    let byte = WasmI32.load8U(ptr, 0n)
    let codePointByteCount = if ((byte & 0x80n) == 0x00n) {
      1n
    } else if ((byte & 0xF0n) == 0xF0n) {
      4n
    } else if ((byte & 0xE0n) == 0xE0n) {
      3n
    } else {
      2n
    }

    // Note that even if up to 4 bytes are needed to represent Unicode
    // codepoints, this doesn't mean 32 bits. The highest allowed code point is
    // 0x10FFFF and it should not change in future versions of Unicode. This
    // means no more than 21 bits are necessary to represent a code point and
    // thus we can use Grain's "simple" numbers that hold up to 31 bits and
    // avoid heap allocations. `getCodePoint` will throw
    // MalformedUnicode exception for values exceeding this limit.
    let codePoint = getCodePoint(ptr)
    fn(tagSimpleNumber(codePoint))

    ptr += codePointByteCount
    idx += 1n
  }
  void
}

/**
 * Iterates over Unicode code points in a string. This is the same as
 * `forEachCodePoint`, but provides the code point's index in the string
 * as the second argument to the iterator function.
 *
 * @param fn: The iterator function
 * @param str: The string to iterate
 *
 * @example String.forEachCodePointi((codepoint, index) => print((codepoint, index)), "Hello world")
 *
 * @since v0.4.0
 */
@unsafe
provide let forEachCodePointi = (fn: (Number, Number) => Void, str: String) => {
  use WasmI32.{ (+), (-), (&), (>>>), ltU as (<), leU as (<=), (==) }

  let strPtr = WasmI32.fromGrain(str)

  let byteSize = WasmI32.load(strPtr, 4n)

  let mut ptr = strPtr + 8n
  let end = ptr + byteSize

  let mut idx = 0n
  while (ptr < end) {
    let byte = WasmI32.load8U(ptr, 0n)
    let codePointByteCount = if ((byte & 0x80n) == 0x00n) {
      1n
    } else if ((byte & 0xF0n) == 0xF0n) {
      4n
    } else if ((byte & 0xE0n) == 0xE0n) {
      3n
    } else {
      2n
    }

    // Note that even if up to 4 bytes are needed to represent Unicode
    // codepoints, this doesn't mean 32 bits. The highest allowed code point is
    // 0x10FFFF and it should not change in future versions of Unicode. This
    // means no more than 21 bits are necessary to represent a code point and
    // thus we can use Grain's "simple" numbers that hold up to 31 bits and
    // avoid heap allocations. `getCodePoint` will throw
    // MalformedUnicode exception for values exceeding this limit.
    let codePoint = getCodePoint(ptr)
    fn(tagSimpleNumber(codePoint), tagSimpleNumber(idx))

    ptr += codePointByteCount
    idx += 1n
  }
  void
}

@unsafe
let trimString = (stringPtr: WasmI32, byteLength: WasmI32, fromEnd: Bool) => {
  use WasmI32.{ (+), (-), (*), (>>>), ltU as (<), (==), (!=) }
  let mut i = 0n
  and offset = 1n
  if (fromEnd) {
    i = byteLength - 1n
    offset = -1n
  }
  let mut count = 0n
  for (; i < byteLength; i += offset) {
    // Get the byte, not necessarily a full UTF-8 codepoint
    let byte = WasmI32.load8U(stringPtr, i)
    // TODO(#661): Use unicode whitespace property and unicode line terminator
    if (!fromEnd) {
      if (
        byte == 0xEFn && // Check for the first BOM byte
        // Check for the full BOM codepoint, 0xEFBBBF. Bytes are reversed because wasm is little-endian
        WasmI32.load(stringPtr, i - 1n) >>> 8n == 0xBFBBEFn
      ) {
        i += 2n
        count += 3n
        continue
      }
    } else {
      if (
        byte == 0xBFn && // Check for the last BOM byte
        // Check for the full BOM codepoint, 0xEFBBBF. Bytes are reversed because wasm is little-endian
        WasmI32.load(stringPtr, i - 3n) >>> 8n == 0xBFBBEFn
      ) {
        i -= 2n
        count += 3n
        continue
      }
    }
    if (
      byte != 0x20n && // Space
      byte != 0x0Dn && // LF
      byte != 0x0An && // CR
      byte != 0x09n && // Tab
      byte != 0x0Bn && // LINE TABULATION
      byte != 0x0Cn && // FORM FEED (FF)
      byte != 0xA0n // No Break Space
    ) {
      break
    }
    count += 1n
  }
  count
}
/**
 * Trims the beginning of a stringâ€”removing any leading whitespace characters.
 *
 * @param string: The string to be trimmed
 * @returns The trimmed string
 *
 * @example String.trimStart("   Hello World") == "Hello World"
 *
 * @since v0.4.2
 */
@unsafe
provide let trimStart = (string: String) => {
  use WasmI32.{ (-), (+) }
  let mut stringPtr = WasmI32.fromGrain(string)
  let byteLength = WasmI32.load(stringPtr, 4n)
  stringPtr += 8n
  let count = trimString(stringPtr, byteLength, false)
  let str = allocateString(byteLength - count)
  Memory.copy(str + 8n, stringPtr + count, byteLength - count)
  WasmI32.toGrain(str): String
}
/**
 * Trims the end of a stringâ€”removing any trailing whitespace characters.
 *
 * @param string: The string to be trimmed
 * @returns The trimmed string
 *
 * @example String.trimEnd("Hello World   ") == "Hello World"
 *
 * @since v0.4.2
 */
@unsafe
provide let trimEnd = (string: String) => {
  use WasmI32.{ (-), (+) }
  let mut stringPtr = WasmI32.fromGrain(string)
  let byteLength = WasmI32.load(stringPtr, 4n)
  stringPtr += 8n
  let count = trimString(stringPtr, byteLength, true)
  let str = allocateString(byteLength - count)
  Memory.copy(str + 8n, stringPtr, byteLength - count)
  WasmI32.toGrain(str): String
}
/**
 * Trims a stringâ€”removing all leading and trailing whitespace characters.
 *
 * @param string: The string to be trimmed
 * @returns The trimmed string
 *
 * @example String.trim("   Hello World   ") == "Hello World"
 *
 * @since v0.4.2
 */
@unsafe
provide let trim = (string: String) => {
  use WasmI32.{ (-), (+), (==) }
  let mut stringPtr = WasmI32.fromGrain(string)
  let byteLength = WasmI32.load(stringPtr, 4n)
  stringPtr += 8n
  let startCount = trimString(stringPtr, byteLength, false)
  if (startCount == byteLength) return ""
  let endCount = trimString(stringPtr, byteLength, true)
  let str = allocateString(byteLength - startCount - endCount)
  Memory.copy(
    str + 8n,
    stringPtr + startCount,
    byteLength - startCount - endCount
  )
  return WasmI32.toGrain(str): String
}

/**
 * Converts all ASCII uppercase characters in the string to lowercase.
 *
 * @param string: The string to convert
 * @returns The lowercased string
 *
 * @example assert String.toAsciiLowercase("aBc123") == "abc123"
 *
 * @since v0.6.0
 */
provide let toAsciiLowercase = string => {
  let chars = explode(string)
  let len = arrayLength(chars)
  for (let mut i = 0; i < len; i += 1) {
    chars[i] = Char.toAsciiLowercase(chars[i])
  }
  implode(chars)
}

/**
 * Converts all ASCII lowercase characters in the string to uppercase.
 *
 * @param string: The string to convert
 * @returns The uppercased string
 *
 * @example assert String.toAsciiUppercase("aBc123") == "ABC123"
 *
 * @since v0.6.0
 */
provide let toAsciiUppercase = string => {
  let chars = explode(string)
  let len = arrayLength(chars)
  for (let mut i = 0; i < len; i += 1) {
    chars[i] = Char.toAsciiUppercase(chars[i])
  }
  implode(chars)
}
